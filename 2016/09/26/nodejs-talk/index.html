<!doctype html>    

<html class="theme-next pisces use-motion">

<head>
	<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="经验之谈,在路上,node," />





  <link rel="alternate" href="/atom.xml" title="♀昨日的世界♂" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="接下来用’nj’来表示’Node.Js’.全都是。。。参考了网上几个地方的文档总结快速教程之类的，总的来说我就说自己是转载参考了这个吧！向原作者致敬，thx。">
<meta property="og:type" content="article">
<meta property="og:title" content="关于node.js的几句话">
<meta property="og:url" content="http://zrdsj.cc/2016/09/26/nodejs-talk/index.html">
<meta property="og:site_name" content="♀昨日的世界♂">
<meta property="og:description" content="接下来用’nj’来表示’Node.Js’.全都是。。。参考了网上几个地方的文档总结快速教程之类的，总的来说我就说自己是转载参考了这个吧！向原作者致敬，thx。">
<meta property="og:image" content="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo3.png">
<meta property="og:updated_time" content="2017-03-10T15:18:41.854Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于node.js的几句话">
<meta name="twitter:description" content="接下来用’nj’来表示’Node.Js’.全都是。。。参考了网上几个地方的文档总结快速教程之类的，总的来说我就说自己是转载参考了这个吧！向原作者致敬，thx。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6319607726116701000,
      author: '作者'
    }
  };
</script>




  <link rel="canonical" href="http://zrdsj.cc/2016/09/26/nodejs-talk/"/>

	<title> 关于node.js的几句话 | ♀昨日的世界♂ </title>

	</script>
</head>



<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">


	
	<script type="text/javascript" src="/js/src/canvas-nest.min.js"></script>
	 


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-82625969-1', 'auto');
  ga('send', 'pageview');
</script>







    

	<div class="container one-collumn sidebar-position-left page-post-detail ">
		<div class="headband"></div>

		<header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
			<div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">♀昨日的世界♂</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">✞此心光明 亦复何言✞</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
		</header>

		<main id="main" class="main">
			<div class="main-inner">
				<div class="content-wrap">
					<div id="content" class="content">
						

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                关于node.js的几句话
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-26T16:35:43+08:00" content="Sep 26 2016">
              Sep 26 2016
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/sixpence/" itemprop="url" rel="index">
                    <span itemprop="name">sixpence</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/26/nodejs-talk/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/26/nodejs-talk/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>接下来用’nj’来表示’Node.Js’.全都是。。。参考了网上几个地方的文档总结快速教程之类的，总的来说我就说自己是转载参考了<a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">这个</a>吧！向原作者致敬，thx。</p>
<a id="more"></a>
<h3 id="基础">基础</h3>
<h4 id="nodejs是啥">node.js是啥</h4>
<p><code>是一个解析器</code></p>
<p>前展思考：</p>
<ul>
<li>脚本语言的运行需要什么？</li>
<li>独立运行的js又是怎么样？</li>
</ul>
<h4 id="nodejs干啥用的">node.js干啥用的</h4>
<p><code>实现高性能Web服务器</code></p>
<p>不是我说的，是nj作者说的。</p>
<p>值得关注的两个点：</p>
<ul>
<li>事件机制</li>
<li>异步IO模型的优越性？</li>
</ul>
<p>哪种编程语言不自带IO功能，又可以良好支持事件机制？2333</p>
<p>sth else:</p>
<blockquote>
<p>对于前端而言，虽然不是人人都要拿NodeJS写一个服务器程序，但简单可至使用命令交互模式调试JS代码片段，复杂可至编写工具提升工作效率。</p>
</blockquote>
<h4 id="安装">安装</h4>
<p><a href="http://nodejs.cn/download/" target="_blank" rel="external">http://nodejs.cn/download/</a></p>
<h4 id="使用">使用</h4>
<p>法1：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo1.png" alt=""></p>
<p>法2：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo2.png" alt=""></p>
<p>then</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo3.png" alt=""></p>
<blockquote>
<p>你用的Linux？</p>
</blockquote>
<blockquote>
<p>哦，那我不会。。。😒</p>
</blockquote>
<h4 id="模块">模块</h4>
<p>（这是很jb大的一个话题其实）</p>
<p><strong>将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名</strong>。在编写每个模块时，都有<a href="http://www.cnblogs.com/pigtail/archive/2013/01/14/2859929.html" target="_blank" rel="external">require</a>、<a href="https://liuzhichao.com/p/1669.html" target="_blank" rel="external">exports</a>、<a href="http://www.cnblogs.com/dolphinX/p/3485260.html" target="_blank" rel="external">module</a>三个预先定义好的变量可供使用。</p>
<p>还应该注意的点：</p>
<ul>
<li>模块初始化</li>
<li>主模块</li>
</ul>
<h4 id="二进制模块">二进制模块</h4>
<p>一般使用js编写模块就可以了，但nj也支持使用C/C++编写二进制模块。</p>
<p>编译好的二进制模块除了文件扩展名是.node外，和js模块的使用方式相同。</p>
<blockquote>
<p><code>二进制模块能使用操作系统提供的所有功能，拥有无限的潜能.</code></p>
<p><code>对于前端而言并不容易，并且难以跨平台使用。</code></p>
</blockquote>
<p>so不再多说。</p>
<h3 id="代码组织部署">代码组织部署</h3>
<p>先来说说，这第二部分是干什么的。在我自己十分有限的学识当中，我的看法是这样：</p>
<blockquote>
<p>你写的程序通常不会仅仅是一个文件一个界面这类的，那么这些东西多起来的话就得对代码（藏在文件文件夹中的代码）按着某种合理高效的方式做一些处理。比如说<code>目录结构</code>和<code>部署方式</code>，这些事情就像盖房子时搭的脚手架一样。</p>
</blockquote>
<p>####模块路径解析规则</p>
<p>在第一部分提到的<code>require</code>，是一个函数，是nj中的一个模块了。它支持一定规则的路径写法，<a href="http://nqdeng.github.io/7-days-nodejs/#1.5.1" target="_blank" rel="external">详情</a>点击即可。但这两种路径在模块之间建立了<code>耦合关系</code>，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。</p>
<p>因此，require函数支持第三种形式的路径，写法类似于<code>foo/bar</code>，并依次按照以下规则解析路径，直到找到模块位置。</p>
<ul>
<li>
<p>内置模块</p>
<p>传递给require函数的是nj内置模块名称，不做路径解析直接返回内部模块的导出对象。例如<code>require('fs')</code>。</p>
</li>
<li>
<p>node_modules目录</p>
<p>nj定义了一个特殊的<code>node_modules</code>目录用于存放模块。例如某个模块的绝对路径是<code>/home/user/hello.js</code>，在该模块中使用<code>require('foo/bar')</code>方式加载模块时，则nj依次尝试使用以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/home/user/node_modules/foo/bar</div><div class="line">/home/node_modules/foo/bar</div><div class="line">/node_modules/foo/bar</div></pre></td></tr></table></figure>
</li>
<li>
<p>NODE_PATH环境变量</p>
<p>与PATH环境变量类似，nj允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用<code>:</code>分隔，在Windows下使用<code>;</code>分隔。例如定义了以下NODE_PATH环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NODE_PATH=/home/user/lib:/home/lib</div></pre></td></tr></table></figure>
<p>当使用<code>require('foo/bar')</code>的方式加载模块时，则NodeJS依次尝试以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/home/user/lib/foo/bar</div><div class="line">/home/lib/foo/bar</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="包package">包（package）</h4>
<p>nj中一个js模块，最小也得是一个js文件，大了呢我们的描述就会变成：<strong>多个子模块组成的复杂模块</strong>。为了便于使用与管理，我们将<u>许多由子模块组成的大模块成为<strong><em>包</em></strong></u>。并把所有子模块放在同一个目录里。</p>
<p>在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- /home/user/lib/</div><div class="line">  - cat/</div><div class="line">    head.js</div><div class="line">    body.js</div><div class="line">    main.js</div></pre></td></tr></table></figure>
<p>其中<code>cat</code>目录定义了一个包，其中包含了3个子模块。<code>main.js</code>作为入口模块，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var head = require(&apos;./head&apos;);</div><div class="line">var body = require(&apos;./body&apos;);</div><div class="line"></div><div class="line">exports.create = function (name) &#123;</div><div class="line">  return &#123;</div><div class="line">    name: name,</div><div class="line">    head: head.create(),</div><div class="line">    body: body.create()</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在其它模块里使用此包的时候，需要加载包的入口模块。接着上例，使用<code>require('/home/user/lib/cat/main')</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。</p>
<h5 id="indexjs">index.js</h5>
<p>当模块的文件名是<code>index.js</code>，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var cat = require(&apos;/home/user/lib/cat&apos;);</div><div class="line">var cat = require(&apos;/home/user/lib/cat/index&apos;);</div></pre></td></tr></table></figure>
<p>这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。</p>
<h5 id="pactagejson">pactage.json</h5>
<p>如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个<code>package.json</code>文件，并在其中指定入口模块的路径。上例中的<code>cat</code>模块可以重构如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- /home/user/lib/</div><div class="line">  - cat/</div><div class="line">    + doc/</div><div class="line">      - lib/</div><div class="line">        head.js</div><div class="line">        body.js</div><div class="line">        main.js</div><div class="line">      + tests/</div><div class="line">        package.json</div></pre></td></tr></table></figure>
<p>其中package.json内容如下。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;cat&quot;,</div><div class="line">  &quot;main&quot;: &quot;./lib/main.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此一来，就同样可以使用<code>require('/home/user/lib/cat')</code>的方式加载模块。NodeJS会根据包目录下的<code>package.json</code>找到入口模块所在位置。</p>
<h4 id="命令行程序">命令行程序</h4>
<p>使用nj编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。</p>
<p>例如我们用nj写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，我们把该程序部署在<code>/home/user/bin/node-echo.js</code>这个位置。为了在任何目录下都能运行该程序，我们需要使用以下终端命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node /home/user/bin/node-echo.js Hello World</div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>这种使用方式看起来不怎么像是一个命令行程序，下边的才是我们期望的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node-echo Hello World</div></pre></td></tr></table></figure>
<p>在Windows系统(这是个不太友好的开发环境，鄙人当前依然在使用)下的做法完全不同，我们得靠<code>.cmd</code>文件来解决问题。假设<code>node-echo.js</code>存放在<code>C:\Users\user\bin</code>目录，并且该目录已经添加到PATH环境变量里了。接下来需要在该目录下新建一个名为<code>node-echo.cmd</code>的文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@node &quot;C:\User\user\bin\node-echo.js&quot; %*</div></pre></td></tr></table></figure>
<p>这样处理后，我们就可以在任何目录下使用<code>node-echo</code>命令了。</p>
<p>最后再说一下这个Windows下的做法，我没试过也压根没去想。一般情况下我要执行node去运行某个js之类的操作时，我都是用相关bash工具去执行的，并不用cmd。。。</p>
<h4 id="工程目录">工程目录</h4>
<p>了解了以上知识后，现在我们来完整地规划一个工程目录（试试看）。</p>
<p>以编写一个<code>命令行程序</code>为例，一般我们会同时提供<code>命令行模式</code>和<code>API模式</code>两种使用方式，并且我们会借助三方包来编写代码。</p>
<p>除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- /home/user/workspace/node-echo/   # 工程目录</div><div class="line">- /home/user/workspace/node-echo/   # 工程目录</div><div class="line">  - bin/                          # 存放命令行相关代码</div><div class="line">    node-echo</div><div class="line">  + doc/                          # 存放文档</div><div class="line">  - lib/                          # 存放API相关代码</div><div class="line">    echo.js</div><div class="line">  - node_modules/                 # 存放三方包</div><div class="line">    + argv/</div><div class="line">  + tests/                        # 存放测试用例</div><div class="line">  package.json                    # 元数据文件</div><div class="line">  README.md                       # 说明文件</div></pre></td></tr></table></figure>
<p>其中部分文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* bin/node-echo */</div><div class="line">var argv = require(&apos;argv&apos;),</div><div class="line">echo = require(&apos;../lib/echo&apos;);</div><div class="line">console.log(echo(argv.join(&apos; &apos;)));</div><div class="line"></div><div class="line">/* lib/echo.js */</div><div class="line">module.exports = function (message) &#123;</div><div class="line">  return message;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* package.json */</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;node-echo&quot;,</div><div class="line">  &quot;main&quot;: &quot;./lib/echo.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上例子中分类存放了不同类型的文件，并通过<code>node_moudles</code>目录直接使用三方包名加载模块。此外，定义了<code>package.json</code>之后，<code>node-echo</code>目录也可被当作一个包来使用。</p>
<h4 id="npm">npm</h4>
<p>NPM是随同nj一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>可以看到，NPM建立了一个nj生态圈，nj开发者和用户可以在里边互通有无。以下分别介绍这三种场景下怎样使用NPM。</p>
<h5 id="下载三方包">下载三方包</h5>
<p>需要使用三方包时，首先得知道有哪些包可用。虽然官方–&gt;<a href="https://npmjs.org/" target="_blank" rel="external">npmjs.org</a>提供了个搜索框可以根据包名来搜索，但如果连想使用的三方包的名字都不确定的话，就请自行百度。知道了包名后，比如上边例子中的<code>argv</code>，就可以在工程目录下打开终端，使用以下命令来下载三方包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install argv</div><div class="line">...</div><div class="line">argv@0.0.2 node_modules\argv</div></pre></td></tr></table></figure>
<p>下载好之后，<strong><code>argv</code>包就放在了工程目录下的<code>node_modules</code>目录中</strong>，因此在<strong>代码中只需要通过<code>require('argv')</code>的方式就好，无需指定三方包路径</strong>。</p>
<p>以上命令默认下载最新版三方包，如果想要下载指定版本的话，可以在包名后边加上<code>@</code>，例如通过以下命令可下载0.0.x版的<code>argv</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install argv@0.0.1</div><div class="line">...</div><div class="line">argv@0.0.1 node_modules\argv</div></pre></td></tr></table></figure>
<p>如果使用到的三方包比较多，在终端下一个包一条命令地安装未免太人肉了。因此NPM对<code>package.json</code>的字段做了扩展，允许在其中申明三方包依赖。因此，上边例子中的<code>package.json</code>可以改写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;node-echo&quot;,</div><div class="line">  &quot;main&quot;: &quot;./lib/echo.js&quot;,</div><div class="line">  &quot;dependencies&quot;: &#123;  </div><div class="line">    &quot;argv&quot;: &quot;0.0.2&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样处理后，在工程目录下就可以使用<code>npm install</code>命令批量安装三方包了。更重要的是，当以后<code>node-echo</code>也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用<code>npm install node-echo</code>命令时，NPM会自动创建以下目录结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- project/</div><div class="line">  - node_modules/</div><div class="line">    - node-echo</div><div class="line">      - node_modules/</div><div class="line">        + argv/</div><div class="line">        ...</div><div class="line">...</div></pre></td></tr></table></figure>
<p>如此一来，用户只需关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系。</p>
<h5 id="安装命令行程序">安装命令行程序</h5>
<p>从NPM服务上下载安装一个命令行程序的方法与三方包类似。例如上例中的<code>node-echo</code>提供了命令行使用方式，只要<code>node-echo</code>自己配置好了相关的<code>package.json</code>字段，对于用户而言，只需要使用以下命令安装程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install node-echo -g</div></pre></td></tr></table></figure>
<p>参数中的<code>-g</code>表示全局安装，因此<code>node-echo</code>会默认安装到以下位置，并且NPM会自动创建好Windows系统下需要的<code>.cmd</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- /usr/local/               # Linux系统下</div><div class="line">  - lib/node_modules/</div><div class="line">    + node-echo/</div><div class="line">        ...</div><div class="line">    - bin/</div><div class="line">      node-echo</div><div class="line">        ...</div><div class="line">    ...</div><div class="line"></div><div class="line">- %APPDATA%\npm\            # Windows系统下</div><div class="line">  - node_modules\</div><div class="line">    + node-echo\</div><div class="line">        ...</div><div class="line">    node-echo.cmd</div><div class="line"> ...</div></pre></td></tr></table></figure>
<h5 id="发布代码">发布代码</h5>
<p>先给一个<a href="http://www.jianshu.com/p/26029206ad3e" target="_blank" rel="external">链接</a>。</p>
<p>第一次使用NPM发布代码前需要注册一个账号。终端下运行<code>npm adduser</code>，之后按照提示做即可。账号搞定后，接着我们需要编辑<code>package.json</code>文件，加入NPM必需的字段。接着上边<code>node-echo</code>的例子，<code>package.json</code>里必要的字段如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;node-echo&quot;,           # 包名，在NPM服务器上须要保持唯一</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,            # 当前版本号</div><div class="line">  &quot;dependencies&quot;: &#123;              # 三方包依赖，需要指定包名和版本号</div><div class="line">    &quot;argv&quot;: &quot;0.0.2&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;main&quot;: &quot;./lib/echo.js&quot;,       # 入口模块位置</div><div class="line">  &quot;bin&quot; : &#123;</div><div class="line">    &quot;node-echo&quot;: &quot;./bin/node-echo&quot;      # 命令行程序名和主模块位置</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后，我们就可以在<code>package.json</code>所在目录下运行<code>npm publish</code>发布代码了。</p>
<h5 id="版本号">版本号</h5>
<p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>
<p>语义版本号分为<code>X.Y.Z</code>三位，分别代表主版本号x、次版本号y和补丁版本号z。当代码变更时，版本号按以下原则更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ 如果只是修复bug，需要更新Z位。</div><div class="line"></div><div class="line">+ 如果是新增了功能，但是向下兼容，需要更新Y位。</div><div class="line"></div><div class="line">+ 如果有大变动，向下不兼容，需要更新X位。</div></pre></td></tr></table></figure>
<p>版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如<code>&quot;argv&quot;: &quot;0.0.x&quot;</code>表示依赖于<code>0.0.x</code>系列的最新版<code>argv</code>。NPM支持的所有版本号范围指定方式可以查看<a href="https://npmjs.org/doc/files/package.json.html#dependencies" target="_blank" rel="external">官方文档</a>。</p>
<h5 id="else">else</h5>
<p>除了本jie介绍的部分外，NPM还提供了很多功能，<code>package.json</code>里也有很多其它有用的字段。除了可以在<a href="https://npmjs.org/doc/" target="_blank" rel="external">npmjs.org/doc/</a>查看官方文档外，这里再介绍一些NPM常用命令。</p>
<ul>
<li>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</li>
<li>使用<code>npm help</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</li>
<li>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用<code>npm update</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</li>
<li>使用<code>npm update -g</code>可以把全局安装的对应命令行程序更新至最新版。</li>
<li>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</li>
<li>使用<code>npm unpublish @</code>可以撤销发布自己发布过的某个版本代码。</li>
</ul>
<h3 id="文件操作">文件操作</h3>
<p>让前端觉得如获神器的可能不是nj能做网络编程，而是nj能够操作文件。从<em>文件查找</em>到<em>代码编译</em>，几乎没有一个前端工具不操作文件。换个角度讲，几乎也只需要一些数据处理逻辑，再加上一些文件操作，就能够编写出大多数前端工具。本章将介绍与之相关的nj内置模块。</p>
<h4 id="开门红">开门红</h4>
<p>nj提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。与<code>copy</code>命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。</p>
<h5 id="小文件拷贝">小文件拷贝</h5>
<p>使用nj内置的<code>fs</code>模块简单实现这个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">function copy(src, dst) &#123;</div><div class="line">  fs.writeFileSync(dst, fs.readFileSync(src));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">  copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p>以上程序使用<code>fs.readFileSync</code>从源路径读取文件内容，并使用<code>fs.writeFileSync</code>将文件内容写入目标路径。</p>
<p>其中<code>process</code>是一个全局变量，可通过<code>process.argv</code>获得命令行参数。由于<code>argv[0]</code>固定等于nj执行程序的绝对路径，<code>argv[1]</code>固定等于主模块的绝对路径，因此第一个命令行参数从<code>argv[2]</code>这个位置开始。</p>
<h5 id="大文件拷贝">大文件拷贝</h5>
<p>上边的程序拷贝一些小文件没有问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。（试想你的服务器有一个数g的iso文件，如果想要将这个文件进行操作的话，，hh显然不可能一下进行操作，那样会弄炸你的服务器）对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">function copy(src, dst) &#123;</div><div class="line">  fs.createReadStream(src).pipe(fs.createWriteStream(dst));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">  copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p>以上程序使用<code>fs.createReadStream</code>创建了一个源文件的只读数据流，并使用<code>fs.createWriteStream</code>创建了一个目标文件的只写数据流，并且用<code>pipe</code>方法把两个数据流连接了起来。连接起来后发生的事情，说得抽象点的话，水顺着水管从一个桶流到了另一个桶。</p>
<h4 id="api">API</h4>
<p>我们大致看看nj提供了哪些和文件操作有关的API。并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h5 id="buffer数据块">Buffer（数据块）</h5>
<p><a href="https://nodejs.org/api/buffer.html" target="_blank" rel="external">官方文档</a></p>
<p>JavaScript语言自身只有字符串数据类型，没有二进制数据类型，因此nj提供了一个与<code>String</code>对等的全局构造函数<code>Buffer</code>来提供对二进制数据的操作。除了可以读取文件得到<code>Buffer</code>的实例外，还能够直接构造，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串类似，除了可以用<code>.length</code>属性得到字节长度外，还可以用<code>[index]</code>方式读取指定位置的字节，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin[0]; // =&gt; 0x68;</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串能够互相转化，例如可以使用指定编码将二进制数据转化为字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var str = bin.toString(&apos;utf-8&apos;); // =&gt; &quot;hello&quot;</div></pre></td></tr></table></figure>
<p>或者反过来，将字符串转换为指定编码下的二进制数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer(&apos;hello&apos;, &apos;utf-8&apos;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于<code>Buffer</code>，更像是可以做指针操作的C语言数组。例如，可以用<code>[index]</code>方式直接修改某个位置的字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin[0] = 0x48;</div></pre></td></tr></table></figure>
<p>而<code>.slice</code>方法也不是返回一个新的<code>Buffer</code>，而更像是返回了指向原<code>Buffer</code>中间的某个位置的指针，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]</div><div class="line">    ^           ^</div><div class="line">    |           |</div><div class="line">   bin     bin.slice(2)</div></pre></td></tr></table></figure>
<p>因此对<code>.slice</code>方法返回的<code>Buffer</code>的修改会作用于原<code>Buffer</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div><div class="line">var sub = bin.slice(2);</div><div class="line"></div><div class="line">sub[0] = 0x65;</div><div class="line">console.log(bin); // =&gt; &lt;Buffer 68 65 65 6c 6f&gt;</div></pre></td></tr></table></figure>
<p>也因此，如果想要拷贝一份<code>Buffer</code>，得首先创建一个新的<code>Buffer</code>，并通过<code>.copy</code>方法把原<code>Buffer</code>中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div><div class="line">var dup = new Buffer(bin.length);</div><div class="line"></div><div class="line">bin.copy(dup);</div><div class="line">dup[0] = 0x48;</div><div class="line">console.log(bin); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</div><div class="line">console.log(dup); // =&gt; &lt;Buffer 48 65 65 6c 6f&gt;</div></pre></td></tr></table></figure>
<p>总之，<code>Buffer</code>将JS的数据处理能力从字符串扩展到了任意二进制数据。</p>
<h5 id="stream数据流">Stream（数据流）</h5>
<p><a href="http://nodejs.org/api/buffer.html" target="_blank" rel="external">官方文档</a></p>
<p>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种<code>Stream</code>来提供对数据流的操作。</p>
<p>以上边的大文件拷贝程序为例，现在为数据来源创建一个只读数据流，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(pathname);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  doSomething(chunk);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  cleanUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Stream</code>基于事件机制工作，所有<code>Stream</code>的实例都继承于NodeJS提供的<a href="http://nodejs.org/api/events.html" target="_blank" rel="external">EventEmitter</a>。</p>
<p>上边的代码中<code>data</code>事件会源源不断地被触发，不管<code>doSomething</code>函数是否处理得过来。代码可以继续做如下改造，以解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  rs.pause();</div><div class="line">  doSomething(chunk, function () &#123;</div><div class="line">    rs.resume();</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  cleanUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上代码给<code>doSomething</code>函数加上了回调，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。</p>
<p>此外，我们也可以为数据目标创建一个只写数据流，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line">var ws = fs.createWriteStream(dst);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  ws.write(chunk);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  ws.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>把<code>doSomething</code>换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据<code>.write</code>方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据<code>drain</code>事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。因此代码可以继续改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line">var ws = fs.createWriteStream(dst);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  if (ws.write(chunk) === false) &#123;</div><div class="line">    rs.pause();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  ws.end();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ws.on(&apos;drain&apos;, function () &#123;</div><div class="line">    rs.resume();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上代码实现了数据从只读数据流到只写数据流的搬运，并包括了防爆仓控制。因为这种使用场景很多，例如上边的大文件拷贝程序，NodeJS直接提供了<code>.pipe</code>方法来做这件事情，其内部实现方式与上边的代码类似。</p>
<h5 id="file-system文件系统">File System（文件系统）</h5>
<p><a href="http://nodejs.org/api/fs.html" target="_blank" rel="external">官方文档</a></p>
<p>NodeJS通过<code>fs</code>内置模块提供对文件的操作。<code>fs</code>模块提供的API基本上可以分为以下三类：</p>
<ul>
<li>
<p>文件属性读写。</p>
<p>其中常用的有<code>fs.stat</code>、<code>fs.chmod</code>、<code>fs.chown</code>等等。</p>
</li>
<li>
<p>文件内容读写。</p>
<p>其中常用的有<code>fs.readFile</code>、<code>fs.readdir</code>、<code>fs.writeFile</code>、<code>fs.mkdir</code>等等。</p>
</li>
<li>
<p>底层文件操作。</p>
<p>其中常用的有<code>fs.open</code>、<code>fs.read</code>、<code>fs.write</code>、<code>fs.close</code>等等。</p>
</li>
</ul>
<p>NodeJS最精华的异步IO模型在<code>fs</code>模块里有着充分的体现，例如上边提到的这些API都通过回调函数传递结果。以<code>fs.readFile</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.readFile(pathname, function (err, data) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">      // Deal with error.</div><div class="line">  &#125; else &#123;</div><div class="line">      // Deal with data.</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如上边代码所示，基本上所有<code>fs</code>模块API的回调参数都有两个。第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果。</p>
<p>此外，<code>fs</code>模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况。同步API除了方法名的末尾多了一个<code>Sync</code>之外，异常对象与执行结果的传递方式也有相应变化。同样以<code>fs.readFileSync</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  var data = fs.readFileSync(pathname);</div><div class="line">  // Deal with data.</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  // Deal with error.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>fs</code>模块提供的API很多，这里不一一介绍，需要时请自行查阅官方文档。</p>
<p><a href="http://nodejs.org/api/path.html" target="_blank" rel="external">官方文档</a></p>
<p>操作文件时难免与文件路径打交道。NodeJS提供了<code>path</code>内置模块来简化路径相关操作，并提升代码可读性。以下是几个常用的API简介。</p>
<ul>
<li>
<p>path.normalize</p>
<p>将传入的路径转换为标准路径，具体讲的话，除了解析路径中的<code>.</code>与<code>..</code>外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var cache = &#123;&#125;;</div><div class="line"></div><div class="line">function store(key, value) &#123;</div><div class="line">  cache[path.normalize(key)] = value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store(&apos;foo/bar&apos;, 1);</div><div class="line">store(&apos;foo//baz//../bar&apos;, 2);</div><div class="line">console.log(cache);  // =&gt; &#123; &quot;foo/bar&quot;: 2 &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>**坑出没注意： **标准化之后的路径里的斜杠在Windows系统下是<code>\</code>，而在Linux系统下是<code>/</code>。如果想保证任何系统下都使用<code>/</code>作为路径分隔符的话，需要用<code>.replace(/\\/g, '/')</code>再替换一下标准路径。</p>
</blockquote>
<ul>
<li>
<p>path.join</p>
<p>将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot;</div></pre></td></tr></table></figure>
</li>
<li>
<p>path.extname</p>
<p>当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>path</code>模块提供的其余方法也不多，稍微看一下官方文档就能全部掌握。</p>
<h4 id="遍历目录">遍历目录</h4>
<p>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。</p>
<h5 id="递归算法">递归算法</h5>
<p>遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(n) &#123;</div><div class="line">  if(n === 1) &#123;</div><div class="line">    return 1;</div><div class="line">  &#125; else &#123;</div><div class="line">    return n * factorial(n - 1);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1。</p>
<blockquote>
<p><strong>陷阱</strong>： 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数！</p>
</blockquote>
<h5 id="遍历算法">遍历算法</h5>
<p>目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是<code>A &gt; B &gt; D &gt; E &gt; C &gt; F</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    A</div><div class="line">   / \</div><div class="line">  B   C</div><div class="line"> / \   \</div><div class="line">D   E   F</div></pre></td></tr></table></figure>
<h5 id="同步遍历">同步遍历</h5>
<p>了解了必要的算法后，我们可以简单地实现以下目录遍历函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function travel(dir, callback) &#123;</div><div class="line">  fs.readdirSync(dir).forEach(function (file) &#123;</div><div class="line">    var pathname = path.join(dir, file);</div><div class="line"></div><div class="line">    if(fs.statSync(pathname).isDirectory()) &#123;</div><div class="line">      travel(pathname, callback);</div><div class="line">    &#125; else &#123;</div><div class="line">      callback(pathname);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- /home/user/</div><div class="line">  - foo/</div><div class="line">    x.js</div><div class="line">  - bar/</div><div class="line">    y.js</div><div class="line">    z.css</div></pre></td></tr></table></figure>
<p>使用以下代码遍历该目录时，得到的输入如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">travel(&apos;/home/user&apos;, function (pathname) &#123;</div><div class="line">  console.log(pathname);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">------------------------</div><div class="line">/home/user/foo/x.js</div><div class="line">/home/user/bar/y.js</div><div class="line">/home/user/z.css</div></pre></td></tr></table></figure>
<h5 id="异步遍历">异步遍历</h5>
<p>如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。<code>travel</code>函数的异步版本如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function travel(dir, callback, finish) &#123;</div><div class="line">  fs.readdir(dir, function (err, files) &#123;</div><div class="line">    (function next(i) &#123;</div><div class="line">       if(i &lt; files.length) &#123;</div><div class="line">         var pathname = path.join(dir, files[i]);</div><div class="line"></div><div class="line">         fs.stat(pathname, function (err, stats) &#123;</div><div class="line">           if(stats.isDirectory()) &#123;</div><div class="line">             travel(pathname, callback, function () &#123;</div><div class="line">               next(i + 1);</div><div class="line">             &#125;);</div><div class="line">           &#125; else &#123;</div><div class="line">             callback(pathname, function () &#123;</div><div class="line">               next(i + 1);</div><div class="line">             &#125;);</div><div class="line">           &#125;</div><div class="line">         &#125;);</div><div class="line">       &#125; else &#123;</div><div class="line">         finish &amp;&amp; finish();</div><div class="line">         &#125;</div><div class="line">       &#125;(0));</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里不详细介绍异步遍历函数的编写技巧，在后续章节中会详细介绍这个。总之我们可以看到异步编程还是蛮复杂的。</p>
<h4 id="文本编码">文本编码</h4>
<p>使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有<code>UTF8</code>和<code>GBK</code>两种，并且<code>UTF8</code>文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的<code>UTF8</code>编码字符串后才能正常处理。</p>
<h5 id="bom的移除">BOM的移除</h5>
<p>BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（&quot;\uFEFF&quot;），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    Bytes      Encoding</div><div class="line">----------------------------</div><div class="line">    FE FF       UTF16BE</div><div class="line">    FF FE       UTF16LE</div><div class="line">    EF BB BF    UTF8</div></pre></td></tr></table></figure>
<p>因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。</p>
<p>例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM。例如，以下代码实现了识别和去除UTF8 BOM的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function readText(pathname) &#123;</div><div class="line">  var bin = fs.readFileSync(pathname);</div><div class="line"></div><div class="line">  if(bin[0] === 0xEF &amp;&amp; bin[1] === 0xBB &amp;&amp; bin[2] === 0xBF) </div><div class="line">    bin = bin.slice(3);</div><div class="line">  &#125;</div><div class="line">  return bin.toString(&apos;utf-8&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="gbk转utf8">GBK转UTF8</h5>
<p>NodeJS支持在读取文本文件时，或者在<code>Buffer</code>转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助<code>iconv-lite</code>这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var iconv = require(&apos;iconv-lite&apos;);</div><div class="line"></div><div class="line">function readGBKText(pathname) &#123;</div><div class="line">  var bin = fs.readFileSync(pathname);</div><div class="line">  return iconv.decode(bin, &apos;gbk&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="单字节编码">单字节编码</h5>
<p>有时候，我们无法预知需要读取的文件采用哪种编码，因此也就无法指定正确的编码。比如我们要处理的某些CSS文件中，有的用GBK编码，有的用UTF8编码。虽然可以一定程度可以根据文件的字节内容猜测出文本编码，但这里要介绍的是有些局限，但是要简单得多的一种技术。</p>
<p>首先我们知道，如果一个文本文件只包含英文字符，比如<code>Hello World</code>，那无论用GBK编码或是UTF8编码读取这个文件都是没问题的。这是因为在这些编码下，ASCII0~128范围内字符都使用相同的单字节编码。</p>
<p>反过来讲，即使一个文本文件中有中文等字符，如果我们需要处理的字符仅在ASCII0~128范围内，比如除了注释和字符串以外的JS代码，我们就可以统一使用单字节编码来读取文件，不用关心文件的实际编码是GBK还是UTF8。以下示例说明了这种方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1. GBK编码源文件内容：</div><div class="line">    var foo = &apos;中文&apos;;</div><div class="line">2. 对应字节：</div><div class="line">    76 61 72 20 66 6F 6F 20 3D 20 27 D6 D0 CE C4 27 3B</div><div class="line">3. 使用单字节编码读取后得到的内容：</div><div class="line">    var foo = &apos;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&apos;;</div><div class="line">4. 替换内容：</div><div class="line">    var bar = &apos;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&apos;;</div><div class="line">5. 使用单字节编码保存后对应字节：</div><div class="line">    76 61 72 20 62 61 72 20 3D 20 27 D6 D0 CE C4 27 3B</div><div class="line">6. 使用GBK编码读取后得到内容：</div><div class="line">    var bar = &apos;中文&apos;;</div></pre></td></tr></table></figure>
<h4 id="小结">小结</h4>
<p>本章介绍了使用NodeJS操作文件时需要的API以及一些技巧，总结起来有以下几点：</p>
<ul>
<li>学好文件操作，编写各种程序都不怕。</li>
<li>如果不是很在意性能，<code>fs</code>模块的同步API能让生活更加美好。</li>
<li>需要对文件读写做到字节级别的精细控制时，请使用<code>fs</code>模块的文件底层操作API。</li>
<li>不要使用拼接字符串的方式来处理路径，使用<code>path</code>模块。</li>
<li>掌握好目录遍历和文件编码处理技巧，很实用。</li>
</ul>
<h3 id="网络操作">网络操作</h3>
<p>一个合格的FE不能是不了解网络的，而NodeJS提供了一扇了解网络编程的窗口。通过NodeJS，除了可以编写一些服务端程序来协助前端开发和测试外，还能够学习一些HTTP协议与Socket协议的相关知识，这些知识在优化前端性能和排查前端故障时说不定能派上用场。本章将介绍与之相关的<em>NodeJS内置模块</em>。</p>
<h4 id="引入">引入</h4>
<p>NodeJS本来的用途是编写高性能Web服务器。我们首先在这里重复一下官方文档里的例子，使用NodeJS内置的<code>http</code>模块简单实现一个HTTP服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text-plain&apos; &#125;);</div><div class="line">  response.end(&apos;Hello World\n&apos;);</div><div class="line">&#125;).listen(8124);</div></pre></td></tr></table></figure>
<p>以上程序创建了一个HTTP服务器并监听<code>8124</code>端口，打开浏览器访问该端口<code>http://127.0.0.1:8124/</code>就能够看到效果。</p>
<blockquote>
<p><strong>xiao知识：</strong> 在Linux系统下，监听1024以下端口需要root权限。因此，如果想监听80或443端口的话，需要使用<code>sudo</code>命令启动程序。</p>
</blockquote>
<h4 id="api-watching">API watching</h4>
<p>先大致看看NodeJS提供了哪些和网络操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h5 id="http">HTTP</h5>
<p><a href="http://nodejs.org/api/http.html" target="_blank" rel="external">官方文档</a></p>
<p>'http’模块提供两种使用方式：</p>
<ul>
<li>作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。</li>
<li>作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。</li>
</ul>
<p>先来看看<strong>服务端模式</strong>下如何工作。如前文的例子所示，首先需要使用<code>.createServer</code>方法创建一个服务器，然后调用<code>.listen</code>方法监听端口。之后，每当来了一个客户端请求，创建服务器时传入的回调函数就被调用一次。可以看出，这是一种事件机制。</p>
<p>http请求本质上是一个数据流，由请求头（headers）和请求体（body）组成。例如以下是一个完整的HTTP请求数据内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST / HTTP/1.1</div><div class="line">User-Agent: curl/7.26.0</div><div class="line">Host: localhost</div><div class="line">Accept: */*</div><div class="line">Content-Length: 11</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>可以看到，空行之上是请求头，之下是请求体。http请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而<code>http</code>模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。在回调函数中，除了可以使用<code>request</code>对象访问请求头数据外，还能把<code>request</code>对象当作一个只读数据流来访问请求体数据。</p>
<p>以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var body = [];</div><div class="line"></div><div class="line">  console.log(request.method);</div><div class="line">  console.log(request.headers);</div><div class="line"></div><div class="line">  request.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  request.on(&apos;end&apos;, function () &#123;</div><div class="line">    body = Buffer.concat(body);</div><div class="line">    console.log(body.toString());</div><div class="line">  &#125;);</div><div class="line">&#125;).listen(80);</div><div class="line"></div><div class="line">------------------------------------</div><div class="line">POST</div><div class="line">&#123; &apos;user-agent&apos;: &apos;curl/7.26.0&apos;,</div><div class="line">  host: &apos;localhost&apos;,</div><div class="line">  accept: &apos;*/*&apos;,</div><div class="line">  &apos;content-length&apos;: &apos;11&apos;,</div><div class="line">  &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;</div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>http响应本质上也是一个数据流，同样由响应头（headers）和响应体（body）组成。例如以下是一个完整的 http请求数据内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: text/plain</div><div class="line">Content-Length: 11</div><div class="line">Date: Tue, 05 Nov 2013 05:31:38 GMT</div><div class="line">Connection: keep-alive</div><div class="line"></div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>在回调函数中，除了可以使用<code>response</code>对象来写入响应头数据外，还能把<code>response</code>对象当作一个只写数据流来写入响应体数据。例如在以下例子中，服务端原样将客户端请求的请求体数据返回给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">    response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</div><div class="line"></div><div class="line">    request.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">        response.write(chunk);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    request.on(&apos;end&apos;, function () &#123;</div><div class="line">        response.end();</div><div class="line">    &#125;);</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接下来看客户端模式下如何工作。为了发起一个客户端http请求，我们需要指定目标服务器的位置并发送请求头和请求体，以下示例演示了具体做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  hostname: &apos;www.example.com&apos;,</div><div class="line">  port: 80,</div><div class="line">  path: &apos;/upload&apos;,</div><div class="line">  method: &apos;POST&apos;,</div><div class="line">  headers: &#123;</div><div class="line">    &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var request = http.request(options, function (response) &#123;&#125;);</div><div class="line"></div><div class="line">request.write(&apos;Hello World&apos;);</div><div class="line">request.end();</div></pre></td></tr></table></figure>
<p>可以看到，<code>.request</code>方法创建了一个客户端，并指定请求目标和请求头数据。之后，就可以把<code>request</code>对象当作一个只写数据流来写入请求体数据和结束请求。另外，由于HTTP请求中<code>GET</code>请求是最常见的一种，并且不需要请求体，因此<code>http</code>模块也提供了以下便捷API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http.get(&apos;http://www.example.com/&apos;, function (response) &#123;&#125;);</div></pre></td></tr></table></figure>
<p>当客户端发送请求并接收到完整的服务端响应头时，就会调用回调函数。在回调函数中，除了可以使用<code>response</code>对象访问响应头数据外，还能把<code>response</code>对象当作一个只读数据流来访问响应体数据。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">http.get(&apos;http://www.example.com/&apos;, function (response) &#123;</div><div class="line">  var body = [];</div><div class="line"></div><div class="line">  console.log(response.statusCode);</div><div class="line">  console.log(response.headers);</div><div class="line"></div><div class="line">  response.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  response.on(&apos;end&apos;, function () &#123;</div><div class="line">    body = Buffer.concat(body);</div><div class="line">    console.log(body.toString());</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">------------------------------------</div><div class="line">200</div><div class="line">&#123; &apos;content-type&apos;: &apos;text/html&apos;,</div><div class="line">  server: &apos;Apache&apos;,</div><div class="line">  &apos;content-length&apos;: &apos;801&apos;,</div><div class="line">  date: &apos;Tue, 05 Nov 2013 06:08:41 GMT&apos;,</div><div class="line">  connection: &apos;keep-alive&apos; &#125;</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">...</div></pre></td></tr></table></figure>
<h5 id="https">HTTPS</h5>
<p><a href="http://nodejs.org/api/https.html" target="_blank" rel="external">官方文档</a></p>
<p><code>https</code>模块与<code>http</code>模块极为类似，区别在于<code>https</code>模块需要额外处理SSL证书。</p>
<p>在服务端模式下，创建一个HTTPS服务器的示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  key: fs.readFileSync(&apos;./ssl/default.key&apos;),</div><div class="line">  cert: fs.readFileSync(&apos;./ssl/default.cer&apos;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var server = https.createServer(options, function (request, response) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>可以看到，与创建HTTP服务器相比，多了一个<code>options</code>对象，通过<code>key</code>和<code>cert</code>字段指定了HTTPS服务器使用的私钥和公钥。</p>
<p>另外，NodeJS支持<a href="https://shansing.com/read/355/" target="_blank" rel="external">SNI技术</a> ，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。接着上例，可以使用以下方法为HTTPS服务器添加多组证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server.addContext(&apos;foo.com&apos;, &#123;</div><div class="line">  key: fs.readFileSync(&apos;./ssl/foo.com.key&apos;),</div><div class="line">  cert: fs.readFileSync(&apos;./ssl/foo.com.cer&apos;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.addContext(&apos;bar.com&apos;, &#123;</div><div class="line">  key: fs.readFileSync(&apos;./ssl/bar.com.key&apos;),</div><div class="line">  cert: fs.readFileSync(&apos;./ssl/bar.com.cer&apos;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在客户端模式下，发起一个HTTPS客户端请求与<code>http</code>模块几乎相同，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  hostname: &apos;www.example.com&apos;,</div><div class="line">  port: 443,</div><div class="line">  path: &apos;/&apos;,</div><div class="line">  method: &apos;GET&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var request = https.request(options, function (response) &#123;&#125;);</div><div class="line"></div><div class="line">request.end();</div></pre></td></tr></table></figure>
<p>但如果目标服务器使用的SSL证书是自制的，不是从颁发机构购买的，默认情况下<code>https</code>模块会拒绝连接，提示说有证书安全问题。在<code>options</code>里加入<code>rejectUnauthorized: false</code>字段可以禁用对证书有效性的检查，从而允许<code>https</code>模块请求开发环境下使用自制证书的HTTPS服务器。</p>
<h5 id="url">URL</h5>
<p><a href="http://nodejs.org/api/url.html" target="_blank" rel="external">官方文档</a></p>
<p>处理HTTP请求时<code>url</code>模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。首先我们来看看一个完整的URL的各组成部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                           href</div><div class="line"> -----------------------------------------------------------------</div><div class="line">                            host              path</div><div class="line">                      --------------- ----------------------------</div><div class="line"> http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash</div><div class="line"> -----    ---------   --------   ---- -------- ------------- -----</div><div class="line">protocol     auth     hostname   port pathname     search     hash</div><div class="line">                                                ------------</div><div class="line">                                                   query</div></pre></td></tr></table></figure>
<p>我们可以使用<code>.parse</code>方法来将一个URL字符串转换为URL对象，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">url.parse(&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;);</div><div class="line">/* =&gt;</div><div class="line">&#123; protocol: &apos;http:&apos;,</div><div class="line">  auth: &apos;user:pass&apos;,</div><div class="line">  host: &apos;host.com:8080&apos;,</div><div class="line">  port: &apos;8080&apos;,</div><div class="line">  hostname: &apos;host.com&apos;,</div><div class="line">  hash: &apos;#hash&apos;,</div><div class="line">  search: &apos;?query=string&apos;,</div><div class="line">  query: &apos;query=string&apos;,</div><div class="line">  pathname: &apos;/p/a/t/h&apos;,</div><div class="line">  path: &apos;/p/a/t/h?query=string&apos;,</div><div class="line">  href: &apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos; &#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>传给<code>.parse</code>方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，<code>request.url</code>不包含协议头和域名，但同样可以用<code>.parse</code>方法解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var tmp = request.url; // =&gt; &quot;/foo/bar?a=b&quot;</div><div class="line">  url.parse(tmp);</div><div class="line">  /* =&gt;</div><div class="line">  &#123; protocol: null,</div><div class="line">    slashes: null,</div><div class="line">    auth: null,</div><div class="line">    host: null,</div><div class="line">    port: null,</div><div class="line">    hostname: null,</div><div class="line">    hash: null,</div><div class="line">    search: &apos;?a=b&apos;,</div><div class="line">    query: &apos;a=b&apos;,</div><div class="line">    pathname: &apos;/foo/bar&apos;,</div><div class="line">    path: &apos;/foo/bar?a=b&apos;,</div><div class="line">    href: &apos;/foo/bar?a=b&apos; </div><div class="line">  &#125;</div><div class="line">  */</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p><code>.parse</code>方法还支持第二个和第三个布尔类型可选参数。第二个参数等于<code>true</code>时，该方法返回的URL对象中，<code>query</code>字段不再是一个字符串，而是一个经过<code>querystring</code>模块转换后的参数对象。第三个参数等于<code>true</code>时，该方法可以正确解析不带协议头的URL，例如<code>//www.example.com/foo/bar</code>。</p>
<p>反过来，<code>format</code>方法允许将一个URL对象转换为URL字符串，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">url.format(&#123;</div><div class="line">  protocol: &apos;http:&apos;,</div><div class="line">  host: &apos;www.example.com&apos;,</div><div class="line">  pathname: &apos;/p/a/t/h&apos;,</div><div class="line">  search: &apos;query=string&apos;</div><div class="line">&#125;);</div><div class="line">/* =&gt;</div><div class="line">&apos;http://www.example.com/p/a/t/h?query=string&apos;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>另外，<code>.resolve</code>方法可以用于拼接URL，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">url.resolve(&apos;http://www.example.com/foo/bar&apos;, &apos;../baz&apos;);</div><div class="line">/* =&gt;</div><div class="line">http://www.example.com/baz</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="query-string">Query String</h5>
<p><a href="http://nodejs.org/api/querystring.html" target="_blank" rel="external">官方文档</a></p>
<p><code>querystring</code>模块用于实现URL参数字符串与参数对象的互相转换，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;);</div><div class="line">/* =&gt;</div><div class="line">&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;</div><div class="line">*/</div><div class="line"></div><div class="line">querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;);</div><div class="line">/* =&gt;</div><div class="line">&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="zlib">Zlib</h5>
<p><a href="http://nodejs.org/api/zlib.html" target="_blank" rel="external">官方文档</a></p>
<p><code>zlib</code>模块提供了数据压缩和解压的功能。当处理HTTP请求和响应时，可能需要用到这个模块。</p>
<p>首先看一个使用<code>zlib</code>模块压缩HTTP响应体数据的例子。这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用<code>zlib</code>模块返回gzip之后的响应体数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var i = 1024,</div><div class="line">      data = &apos;&apos;;</div><div class="line"></div><div class="line">  while (i--) &#123;</div><div class="line">    data += &apos;.&apos;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if((request.headers[&apos;accept-encoding&apos;] || &apos;&apos;).indexOf(&apos;gzip&apos;) !== -1) &#123;</div><div class="line">    zlib.gzip(data, function (err, data) &#123;</div><div class="line">      response.writeHead(200, &#123;</div><div class="line">        &apos;Content-Type&apos;: &apos;text/plain&apos;,</div><div class="line">        &apos;Content-Encoding&apos;: &apos;gzip&apos;</div><div class="line">      &#125;);</div><div class="line">      response.end(data);</div><div class="line">    &#125;);</div><div class="line">  &#125; else &#123;</div><div class="line">    response.writeHead(200, &#123;</div><div class="line">      &apos;Content-Type&apos;: &apos;text/plain&apos;</div><div class="line">    &#125;);</div><div class="line">    response.end(data);</div><div class="line">  &#125;</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接着我们看一个使用<code>zlib</code>模块解压HTTP响应体数据的例子。这个例子中，判断了服务端响应是否使用gzip压缩，并在压缩的情况下使用<code>zlib</code>模块解压响应体数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  hostname: &apos;www.example.com&apos;,</div><div class="line">  port: 80,</div><div class="line">  path: &apos;/&apos;,</div><div class="line">  method: &apos;GET&apos;,</div><div class="line">  headers: &#123;</div><div class="line">    &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">http.request(options, function (response) &#123;</div><div class="line">  var body = [];</div><div class="line"></div><div class="line">  response.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  response.on(&apos;end&apos;, function () &#123;</div><div class="line">    body = Buffer.concat(body);</div><div class="line"></div><div class="line">  if(response.headers[&apos;content-encoding&apos;] === &apos;gzip&apos;) &#123;</div><div class="line">    zlib.gunzip(body, function (err, data) &#123;</div><div class="line">      console.log(data.toString());</div><div class="line">    &#125;);</div><div class="line">  &#125; else &#123;</div><div class="line">    console.log(data.toString());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;).end();</div></pre></td></tr></table></figure>
<h5 id="net">Net</h5>
<p><a href="http://nodejs.org/api/net.html" target="_blank" rel="external">官方文档</a></p>
<p><code>net</code>模块可用于创建Socket服务器或Socket客户端。由于Socket在前端领域的使用范围还不是很广，这里先不涉及到WebSocket的介绍，仅仅简单演示一下如何从Socket层面来实现HTTP请求和响应。</p>
<p>首先我们来看一个使用Socket搭建一个很不严谨的HTTP服务器的例子。这个HTTP服务器不管收到啥请求，都固定返回相同的响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">net.createServer(function (conn) &#123;</div><div class="line">  conn.on(&apos;data&apos;, function (data) &#123;</div><div class="line">    conn.write([</div><div class="line">      &apos;HTTP/1.1 200 OK&apos;,</div><div class="line">      &apos;Content-Type: text/plain&apos;,</div><div class="line">      &apos;Content-Length: 11&apos;,</div><div class="line">      &apos;&apos;,</div><div class="line">      &apos;Hello World&apos;</div><div class="line">    ].join(&apos;\n&apos;));</div><div class="line">  &#125;);</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接着来看一个使用Socket发起HTTP客户端请求的例子。这个例子中，Socket客户端在建立连接后发送了一个HTTP GET请求，并通过<code>data</code>事件监听函数来获取服务器响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  port: 80,</div><div class="line">  host: &apos;www.example.com&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var client = net.connect(options, function () &#123;</div><div class="line">  client.write([</div><div class="line">    &apos;GET / HTTP/1.1&apos;,</div><div class="line">    &apos;User-Agent: curl/7.26.0&apos;,</div><div class="line">    &apos;Host: www.baidu.com&apos;,</div><div class="line">    &apos;Accept: */*&apos;,</div><div class="line">    &apos;&apos;,</div><div class="line">    &apos;&apos;</div><div class="line">  ].join(&apos;\n&apos;));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">client.on(&apos;data&apos;, function (data) &#123;</div><div class="line">  console.log(data.toString());</div><div class="line">  client.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="灵机一点">灵机一点</h4>
<p>使用NodeJS操作网络，特别是操作HTTP请求和响应时会遇到一些惊喜，这里对一些常见问题做解答。</p>
<ul>
<li>
<p>问： 为什么通过<code>headers</code>对象访问到的HTTP请求头或响应头字段不是驼峰的？</p>
<p>答： 从规范上讲，HTTP请求头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个HTTP服务端或客户端程序都严格遵循规范，所以NodeJS在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如<code>headers['content-length']</code>。</p>
</li>
<li>
<p>问： 为什么<code>http</code>模块创建的HTTP服务器返回的响应是<code>chunked</code>传输方式的？</p>
<p>答： 因为默认情况下，使用<code>.writeHead</code>方法写入响应头后，允许使用<code>.write</code>方法写入任意长度的响应体数据，并使用<code>.end</code>方法结束一个响应。由于响应体数据长度不确定，因此NodeJS自动在响应头里添加了<code>Transfer-Encoding: chunked</code>字段，并采用<code>chunked</code>传输方式。但是当响应体数据长度确定时，可使用<code>.writeHead</code>方法在响应头里加上<code>Content-Length</code>字段，这样做之后NodeJS就不会自动添加<code>Transfer-Encoding</code>字段和使用<code>chunked</code>传输方式。</p>
</li>
<li>
<p>问： 为什么使用<code>http</code>模块发起HTTP客户端请求时，有时候会发生<code>socket hang up</code>错误？</p>
<p>答： 发起客户端HTTP请求前需要先创建一个客户端。<code>http</code>模块提供了一个全局客户端<code>http.globalAgent</code>，可以让我们使用<code>.request</code>或<code>.get</code>方法时不用手动创建客户端。但是全局客户端默认只允许5个并发Socket连接，当某一个时刻HTTP客户端请求创建过多，超过这个数字时，就会发生<code>socket hang up</code>错误。解决方法也很简单，通过<code>http.globalAgent.maxSockets</code>属性把这个数字改大些即可。另外，<code>https</code>模块遇到这个问题时也一样通过<code>https.globalAgent.maxSockets</code>属性来处理。</p>
</li>
</ul>
<h4 id="小结">小结</h4>
<p>本章介绍了使用NodeJS操作网络时需要的API以及一些坑回避技巧，总结起来有以下几点：</p>
<ul>
<li><code>http</code>和<code>https</code>模块支持服务端模式和客户端模式两种使用方式。</li>
<li><code>request</code>和<code>response</code>对象除了用于读写头数据外，都可以当作数据流来操作。</li>
<li><code>url.parse</code>方法加上<code>request.url</code>属性是处理HTTP请求时的固定搭配。</li>
<li>使用<code>zlib</code>模块可以减少使用HTTP协议时的数据传输量。</li>
<li>通过<code>net</code>模块的Socket服务器与客户端可对HTTP协议做底层操作。</li>
<li>小心踩坑。</li>
</ul>
<h3 id="进程管理">进程管理</h3>
<p>NodeJS可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。本章除了介绍与之相关的NodeJS内置模块外，还会重点介绍典型的使用场景。</p>
<h4 id="开门红">开门红</h4>
<p>我们已经知道了NodeJS自带的<code>fs</code>模块比较基础，把一个目录里的所有文件和子目录都拷贝到另一个目录里需要写不少代码。另外我们也知道，终端下的<code>cp</code>命令比较好用，一条<code>cp -r source/* target</code>命令就能搞定目录拷贝。那我们首先看看如何使用NodeJS调用终端命令来简化目录拷贝，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var child_process = require(&apos;child_process&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line"></div><div class="line">function copy(source, target, callback) &#123;</div><div class="line">  child_process.exec(</div><div class="line">    util.format(&apos;cp -r %s/* %s&apos;, source, target), callback);</div><div class="line">&#125;</div><div class="line"></div><div class="line">copy(&apos;a&apos;, &apos;b&apos;, function (err) &#123;</div><div class="line">    // ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>从以上代码中可以看到，子进程是异步运行的，通过回调函数返回执行结果。</p>
<h4 id="api">API</h4>
<p>先大致看看NodeJS提供了哪些和进程管理有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h5 id="process">Process</h5>
<p><a href="http://nodejs.org/api/process.html" target="_blank" rel="external">官方文档</a></p>
<p>任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。在NodeJS中，可以通过<code>process</code>对象感知和控制NodeJS自身进程的方方面面。另外需要注意的是，<code>process</code>不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。</p>
<h5 id="child-process">Child Process</h5>
<p><a href="http://nodejs.org/api/child_process.html" target="_blank" rel="external">官方文档</a></p>
<p>使用<code>child_process</code>模块可以创建和控制子进程。该模块提供的API中最核心的是<code>.spawn</code>，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。</p>
<h5 id="cluster">Cluster</h5>
<p><a href="http://nodejs.org/api/cluster.html" target="_blank" rel="external">官方文档</a></p>
<p><code>cluster</code>模块是对<code>child_process</code>模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。</p>
<h4 id="应用场景">应用场景</h4>
<p>和进程管理相关的API单独介绍起来比较枯燥，因此这里从一些典型的应用场景出发，分别介绍一些重要API的使用方法。</p>
<h5 id="如何获取命令行参数">如何获取命令行参数</h5>
<p>在NodeJS中可以通过<code>process.argv</code>获取命令行参数。但是比较意外的是，<code>node</code>执行程序路径和主模块文件路径固定占据了<code>argv[0]</code>和<code>argv[1]</code>两个位置，而第一个命令行参数从<code>argv[2]</code>开始。为了让<code>argv</code>使用起来更加自然，可以按照以下方式处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function main(argv) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<h5 id="如何退出程序">如何退出程序</h5>
<p>通常一个程序做完所有事情后就正常退出了，这时程序的退出状态码为<code>0</code>。或者一个程序运行时发生了异常后就挂了，这时程序的退出状态码不等于<code>0</code>。如果我们在代码中捕获了某个异常，但是觉得程序不应该继续运行下去，需要立即退出，并且需要把退出状态码设置为指定数字，比如<code>1</code>，就可以按照以下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    // ...</div><div class="line">&#125; catch (err) &#123;</div><div class="line">    // ...</div><div class="line">    process.exit(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="如何控制输入输出">如何控制输入输出</h5>
<p>NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应<code>process.stdin</code>、<code>process.stdout</code>和<code>process.stderr</code>，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。例如，<code>console.log</code>可以按照以下方式实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function log() &#123;</div><div class="line">  process.stdout.write(</div><div class="line">    util.format.apply(util, arguments) + &apos;\n&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="如何降权">如何降权</h5>
<p>在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。以下是这样一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">http.createServer(callback).listen(80, function () &#123;</div><div class="line">  var env = process.env,</div><div class="line">  uid = parseInt(env[&apos;SUDO_UID&apos;] || process.getuid(), 10),</div><div class="line">  gid = parseInt(env[&apos;SUDO_GID&apos;] || process.getgid(), 10);</div><div class="line"></div><div class="line">  process.setgid(gid);</div><div class="line">  process.setuid(uid);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上例中有几点需要注意：</p>
<ol>
<li>如果是通过<code>sudo</code>获取root权限的，运行程序的用户的UID和GID保存在环境变量<code>SUDO_UID</code>和<code>SUDO_GID</code>里边。如果是通过<code>chmod +s</code>方式获取root权限的，运行程序的用户的UID和GID可直接通过<code>process.getuid</code>和<code>process.getgid</code>方法获取。</li>
<li><code>process.setuid</code>和<code>process.setgid</code>方法只接受<code>number</code>类型的参数。</li>
<li>降权时必须先降GID再降UID，否则顺序反过来的话就没权限更改程序的GID了。</li>
</ol>
<h5 id="如何创建子进程">如何创建子进程</h5>
<p>以下是一个创建NodeJS子进程的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;xxx.js&apos; ]);</div><div class="line"></div><div class="line">child.stdout.on(&apos;data&apos;, function (data) &#123;</div><div class="line">  console.log(&apos;stdout: &apos; + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.stderr.on(&apos;data&apos;, function (data) &#123;</div><div class="line">  console.log(&apos;stderr: &apos; + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.on(&apos;close&apos;, function (code) &#123;</div><div class="line">  console.log(&apos;child process exited with code &apos; + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上例中使用了<code>.spawn(exec, args, options)</code>方法，该方法支持三个参数。第一个参数是执行文件路径，可以是执行文件的相对或绝对路径，也可以是根据PATH环境变量能找到的执行文件名。第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。</p>
<p>另外，上例中虽然通过子进程对象的<code>.stdout</code>和<code>.stderr</code>访问子进程的输出，但通过<code>options.stdio</code>字段的不同配置，可以将子进程的输入输出重定向到任何数据流上，或者让子进程共享父进程的标准输入输出流，或者直接忽略子进程的输入输出。</p>
<h5 id="进程间如何通讯">进程间如何通讯</h5>
<p>在Linux系统下，进程之间可以通过信号互相通信。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ]);</div><div class="line"></div><div class="line">child.kill(&apos;SIGTERM&apos;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;SIGTERM&apos;, function () &#123;</div><div class="line">  cleanUp();</div><div class="line">  process.exit(0);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上例中，父进程通过<code>.kill</code>方法向子进程发送<code>SIGTERM</code>信号，子进程监听<code>process</code>对象的<code>SIGTERM</code>事件响应信号。不要被<code>.kill</code>方法的名称迷惑了，该方法本质上是用来给进程发送信号的，进程收到信号后具体要做啥，完全取决于信号的种类和进程自身的代码。</p>
<p>另外，如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ], &#123;</div><div class="line">  stdio: [ 0, 1, 2, &apos;ipc&apos; ]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">  console.log(msg);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.send(&#123; hello: &apos;hello&apos; &#125;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">  msg.hello = msg.hello.toUpperCase();</div><div class="line">  process.send(msg);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，父进程在创建子进程时，在<code>options.stdio</code>字段中通过<code>ipc</code>开启了一条IPC通道，之后就可以监听子进程对象的<code>message</code>事件接收来自子进程的消息，并通过<code>.send</code>方法给子进程发送消息。在子进程这边，可以在<code>process</code>对象上监听<code>message</code>事件接收来自父进程的消息，并通过<code>.send</code>方法向父进程发送消息。数据在传递过程中，会先在发送端使用<code>JSON.stringify</code>方法序列化，再在接收端使用<code>JSON.parse</code>方法反序列化。</p>
<h5 id="如何守护子进程">如何守护子进程</h5>
<p>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。以下是一种实现方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* daemon.js */</div><div class="line">function spawn(mainModule) &#123;</div><div class="line">  var worker = child_process.spawn(&apos;node&apos;, [ mainModule ]);</div><div class="line"></div><div class="line">  worker.on(&apos;exit&apos;, function (code) &#123;</div><div class="line">    if(code !== 0) &#123;</div><div class="line">      spawn(mainModule);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn(&apos;worker.js&apos;);</div></pre></td></tr></table></figure>
<p>可以看到，工作进程非正常退出时，守护进程立即重启工作进程。</p>
<h4 id="小结">小结</h4>
<p>本章介绍了使用NodeJS管理进程时需要的API以及主要的应用场景，总结起来有以下几点：</p>
<ul>
<li>使用<code>process</code>对象管理自身。</li>
<li>使用<code>child_process</code>模块创建和管理子进程。</li>
</ul>
<h3 id="异步编程">异步编程</h3>
<p>NodeJS最大的卖点——事件机制和异步IO，对开发者并不是透明的。开发者需要按异步方式编写代码才用得上这个卖点，而这一点也遭到了一些NodeJS反对者的抨击。但不管怎样，异步编程确实是NodeJS最大的特点，没有掌握异步编程就不能说是真正学会了NodeJS。本章将介绍与异步编程相关的各种知识。</p>
<h4 id="回调">回调</h4>
<p>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。我们首先可以看看以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function heavyCompute(n, callback) &#123;</div><div class="line">  var count = 0,</div><div class="line">       i, j;</div><div class="line"></div><div class="line">  for(i = n; i &gt; 0; --i) &#123;</div><div class="line">    for(j = n; j &gt; 0; --j) &#123;</div><div class="line">      count += 1;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  callback(count);</div><div class="line">&#125;</div><div class="line"></div><div class="line">heavyCompute(10000, function (count) &#123;</div><div class="line">  console.log(count);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;hello&apos;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">100000000</div><div class="line">hello</div></pre></td></tr></table></figure>
<p>可以看到，以上代码中的回调函数仍然先于后续代码执行。JS本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念。</p>
<p>但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。我们接着看看以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">setTimeout(function () &#123;</div><div class="line">  console.log(&apos;world&apos;);</div><div class="line">&#125;, 1000);</div><div class="line"></div><div class="line">console.log(&apos;hello&apos;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">hello</div><div class="line">world</div></pre></td></tr></table></figure>
<p>这次可以看到，回调函数后于后续代码执行了。如同上边所说，JS本身是单线程的，无法异步执行，因此我们可以认为<code>setTimeout</code>这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了<code>setTimeout</code>、<code>setInterval</code>这些常见的，这类函数还包括NodeJS提供的诸如<code>fs.readFile</code>之类的异步API。</p>
<p>另外，我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。以下就是这么一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function heavyCompute(n) &#123;</div><div class="line">  var count = 0,</div><div class="line">      i, j;</div><div class="line"></div><div class="line">  for (i = n; i &gt; 0; --i) &#123;</div><div class="line">    for (j = n; j &gt; 0; --j) &#123;</div><div class="line">      count += 1;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var t = new Date();</div><div class="line"></div><div class="line">setTimeout(function () &#123;</div><div class="line">  console.log(new Date() - t);</div><div class="line">&#125;, 1000);</div><div class="line"></div><div class="line">heavyCompute(50000);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">8520</div></pre></td></tr></table></figure>
<p>可以看到，本来应该在1秒后被调用的回调函数因为JS主线程忙于运行其它代码，实际执行时间被大幅延迟。</p>
<h4 id="代码设计模式">代码设计模式</h4>
<p>异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下分别介绍一些常见的模式。</p>
<h5 id="函数返回值">函数返回值</h5>
<p>使用一个函数的输出作为另一个函数的输入是很常见的需求，在同步方式下一般按以下方式编写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var output = fn1(fn2(&apos;input&apos;));</div><div class="line">// Do something.</div></pre></td></tr></table></figure>
<p>而在异步方式下，由于函数执行结果不是通过返回值，而是通过回调函数传递，因此一般按以下方式编写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fn2(&apos;input&apos;, function (output2) &#123;</div><div class="line">  fn1(output2, function (output1) &#123;</div><div class="line">    // Do something.</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，这种方式就是一个回调函数套一个回调函多，套得太多了很容易写出<code>&gt;</code>形状的代码。</p>
<h5 id="遍历数组">遍历数组</h5>
<p>在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。如果函数是同步执行的，一般就会写出以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var len = arr.length,</div><div class="line">    i = 0;</div><div class="line"></div><div class="line">for(; i &lt; len; ++i) &#123;</div><div class="line">  arr[i] = sync(arr[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// All array items have processed.</div></pre></td></tr></table></figure>
<p>如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(function next(i, len, callback) &#123;</div><div class="line">  if(i &lt; len) &#123;</div><div class="line">    async(arr[i], function (value) &#123;</div><div class="line">      arr[i] = value;</div><div class="line">      next(i + 1, len, callback);</div><div class="line">    &#125;);</div><div class="line">  &#125; else &#123;</div><div class="line">    callback();</div><div class="line">  &#125;</div><div class="line">&#125;(0, arr.length, function () &#123;</div><div class="line">    // All array items have processed.</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>可以看到，以上代码在异步函数执行一次并返回执行结果后才传入下一个数组成员并开始下一轮执行，直到所有数组成员处理完毕后，通过回调的方式触发后续代码的执行。</p>
<p>如果数组成员可以并行处理，但后续代码仍然需要所有数组成员处理完毕后才能执行的话，则异步代码会调整成以下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(function (i, len, count, callback) &#123;</div><div class="line">  for(; i &lt; len; ++i) &#123;</div><div class="line">    (function (i) &#123;</div><div class="line">      async(arr[i], function (value) &#123;</div><div class="line">        arr[i] = value;</div><div class="line">        if(++count === len) &#123;</div><div class="line">          callback();</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;(i));</div><div class="line">  &#125;</div><div class="line">&#125;(0, arr.length, 0, function () &#123;</div><div class="line">    // All array items have processed.</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员，并通过计数器变量来判断什么时候所有数组成员都处理完毕了。</p>
<h5 id="异常处理">异常处理</h5>
<p>JS自身提供的异常捕获和处理机制——<code>try..catch..</code>，只能用于同步执行的代码。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function sync(fn) &#123;</div><div class="line">  return fn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  sync(null);</div><div class="line">    // Do something.</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">Error: object is not a function</div></pre></td></tr></table></figure>
<p>可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个<code>try</code>语句时被捕获住。但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到<code>try</code>语句，就作为一个全局异常抛出。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function async(fn, callback) &#123;</div><div class="line">    // Code execution path breaks here.</div><div class="line">  setTimeout(function ()　&#123;</div><div class="line">    callback(fn());</div><div class="line">  &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  async(null, function (data) &#123;</div><div class="line">        // Do something.</div><div class="line">&#125;);</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">/home/user/test.js:4</div><div class="line">        callback(fn());</div><div class="line">                 ^</div><div class="line">TypeError: object is not a function</div><div class="line">  at null._onTimeout (/home/user/test.js:4:13)</div><div class="line">  at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)</div></pre></td></tr></table></figure>
<p>因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用<code>try</code>语句把异常捕获住，并通过回调函数传递被捕获的异常。于是我们可以像下边这样改造上边的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function async(fn, callback) &#123;</div><div class="line">    // Code execution path breaks here.</div><div class="line">  setTimeout(function ()　&#123;</div><div class="line">    try &#123;</div><div class="line">      callback(null, fn());</div><div class="line">    &#125; catch (err) &#123;</div><div class="line">    callback(err);</div><div class="line">    &#125;</div><div class="line">  &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">async(null, function (err, data) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">    console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">  &#125; else &#123;</div><div class="line">    // Do something.</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">Error: object is not a function</div></pre></td></tr></table></figure>
<p>可以看到，异常再次被捕获住了。在NodeJS中，几乎所有异步API都按照以上方式设计，回调函数中第一个参数都是<code>err</code>。因此我们在编写自己的异步函数时，也可以按照这种方式来处理异常，与NodeJS的设计风格保持一致。</p>
<p>有了异常处理方式后，我们接着可以想一想一般我们是怎么写代码的。基本上，我们的代码都是做一些事情，然后调用一个函数，然后再做一些事情，然后再调用一个函数，如此循环。如果我们写的是同步代码，只需要在代码入口点写一个<code>try</code>语句就能捕获所有冒泡上来的异常，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function main() &#123;</div><div class="line">    // Do something.</div><div class="line">  syncA();</div><div class="line">    // Do something.</div><div class="line">  syncB();</div><div class="line">    // Do something.</div><div class="line">  syncC();</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  main();</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  // Deal with exception.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，如果我们写的是异步代码，就只有呵呵了。由于每次异步函数调用都会打断代码执行路径，只能通过回调函数来传递异常，于是我们就需要在每个回调函数里判断是否有异常发生，于是只用三次异步函数调用，就会产生下边这种代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function main(callback) &#123;</div><div class="line">    // Do something.</div><div class="line">  asyncA(function (err, data) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">    callback(err);</div><div class="line">  &#125; else &#123;</div><div class="line">    // Do something</div><div class="line">    asyncB(function (err, data) &#123;</div><div class="line">      if(err) &#123;</div><div class="line">        callback(err);</div><div class="line">      &#125; else &#123;</div><div class="line">        // Do something</div><div class="line">        asyncC(function (err, data) &#123;</div><div class="line">          if(err) &#123;</div><div class="line">            callback(err);</div><div class="line">          &#125; else &#123;</div><div class="line">            // Do something</div><div class="line">            callback(null);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(function (err) &#123;</div><div class="line">  if(err) &#123;</div><div class="line">    // Deal with exception.</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，回调函数已经让代码变得复杂了，而异步方式下对异常的处理更加剧了代码的复杂度。如果NodeJS的最大卖点最后变成这个样子，那就没人愿意用NodeJS了，因此接下来会介绍NodeJS提供的一些解决方案。</p>
<h4 id="域domain">域（Domain）</h4>
<p><a href="http://nodejs.org/api/domain.html" target="_blank" rel="external">官方文档</a></p>
<p>NodeJS提供了<code>domain</code>模块，可以简化异步代码的异常处理。在介绍该模块之前，我们需要首先理解“域”的概念。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过<code>process</code>对象提供了捕获全局异常的方法，示例代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</div><div class="line">  console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(function (fn) &#123;</div><div class="line">  fn();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">Error: undefined is not a function</div></pre></td></tr></table></figure>
<p>虽然全局异常有个地方可以捕获了，但是对于大多数异常，我们希望尽早捕获，并根据结果决定代码的执行路径。我们用以下HTTP服务器代码作为例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function async(request, callback) &#123;</div><div class="line">    // Do something.</div><div class="line">  asyncA(request, function (err, data) &#123;</div><div class="line">    if(err) &#123;</div><div class="line">      callback(err);</div><div class="line">    &#125; else &#123;</div><div class="line">      // Do something</div><div class="line">      asyncB(request, function (err, data) &#123;</div><div class="line">        if(err) &#123;</div><div class="line">          callback(err);</div><div class="line">        &#125; else &#123;</div><div class="line">          // Do something</div><div class="line">          asyncC(request, function (err, data) &#123;</div><div class="line">            if(err) &#123;</div><div class="line">              callback(err);</div><div class="line">            &#125; else &#123;</div><div class="line">              // Do something</div><div class="line">              callback(null, data);</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  async(request, function (err, data) &#123;</div><div class="line">    if(err) &#123;</div><div class="line">      response.writeHead(500);</div><div class="line">      response.end();</div><div class="line">    &#125; else &#123;</div><div class="line">      response.writeHead(200);</div><div class="line">      response.end(data);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上代码将请求对象交给异步函数处理后，再根据处理结果返回响应。这里采用了使用回调函数传递异常的方案，因此<code>async</code>函数内部如果再多几个异步函数调用的话，代码就变成上边这副鬼样子了。为了让代码好看点，我们可以在每处理一个请求时，使用<code>domain</code>模块创建一个子域（JS子运行环境）。在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的<code>error</code>事件统一捕获。于是以上代码可以做如下改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function async(request, callback) &#123;</div><div class="line">    // Do something.</div><div class="line">  asyncA(request, function (data) &#123;</div><div class="line">      // Do something</div><div class="line">    asyncB(request, function (data) &#123;</div><div class="line">        // Do something</div><div class="line">      asyncC(request, function (data) &#123;</div><div class="line">          // Do something</div><div class="line">        callback(data);</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var d = domain.create();</div><div class="line"></div><div class="line">  d.on(&apos;error&apos;, function () &#123;</div><div class="line">    response.writeHead(500);</div><div class="line">    response.end();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  d.run(function () &#123;</div><div class="line">    async(request, function (data) &#123;</div><div class="line">      response.writeHead(200);</div><div class="line">      response.end(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，我们使用<code>.create</code>方法创建了一个子域对象，并通过<code>.run</code>方法进入需要在子域中运行的代码的入口点。而位于子域中的异步函数回调函数由于不再需要捕获异常，代码一下子瘦身很多。</p>
<h5 id="陷阱">陷阱</h5>
<p>无论是通过<code>process</code>对象的<code>uncaughtException</code>事件捕获到全局异常，还是通过子域对象的<code>error</code>事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。按照官方文档的说法，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。</p>
<p>但这里需要澄清一些事实。JS本身的<code>throw..try..catch</code>异常处理机制并不会导致内存泄漏，也不会让程序的执行结果出乎意料，但NodeJS并不是存粹的JS。NodeJS里大量的API内部是用C/C++实现的，因此NodeJS程序的运行过程中，代码执行路径穿梭于JS引擎内部和外部，而JS的异常抛出机制可能会打断正常的代码执行流程，导致C/C++部分的代码表现异常，进而导致内存泄漏等问题。</p>
<p>因此，使用<code>uncaughtException</code>或<code>domain</code>捕获异常，代码执行路径里涉及到了C/C++部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用<code>try</code>语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上诉问题。</p>
<h4 id="小结">小结</h4>
<p>本章介绍了JS异步编程相关的知识，总结起来有以下几点：</p>
<ul>
<li>不掌握异步编程就不算学会NodeJS。</li>
<li>异步编程依托于回调来实现，而使用回调不一定就是异步编程。</li>
<li>异步编程下的函数间数据传递、数组遍历和异常处理与同步编程有很大差别。</li>
<li>使用<code>domain</code>模块简化异步代码的异常处理，并小心陷阱</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/经验之谈/" rel="tag">#经验之谈</a>
          
            <a href="/tags/在路上/" rel="tag">#在路上</a>
          
            <a href="/tags/node/" rel="tag">#node</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/23/Bible-reading/" rel="next" title="圣经几个读经方法">
                <i class="fa fa-chevron-left"></i> 圣经几个读经方法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/27/Js-Object-oriented/" rel="prev" title="JS-面向对象编程sth">
                JS-面向对象编程sth <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/09/26/nodejs-talk/"
     data-title="关于node.js的几句话"
     data-content=""
     data-url="http://zrdsj.cc/2016/09/26/nodejs-talk/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>

  <div class="page-footer">
    
      <div id="eof" class="print-invisible">
        <hr class="eof">
      </div>

      <div class="copyright" style="clear:both;">
         <p><span>本文标题:</span><a href="/2016/09/26/nodejs-talk/">关于node.js的几句话</a></p>
         <p><span>文章作者:</span><a href="/" title="访问 jimmy_jude 的个人博客">jimmy_jude</a></p>
         <p><span>发布时间:</span>2016年9月26日 - 16时09分</p>
         <p><span>最后更新:</span>2017年3月10日 - 23时03分</p>         <p><span>原始链接:</span><a href="/2016/09/26/nodejs-talk/" title="关于node.js的几句话">http://zrdsj.cc/2016/09/26/nodejs-talk/</a></p>
         <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" title="Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)">Attribution-NonCommercial 4.0</a></p>
         <p><span>转载请保留以上信息。</span></p>
      </div>
    

    

  </div>


					</div>
					

 
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/09/26/nodejs-talk/"
           data-title="关于node.js的几句话" data-url="http://zrdsj.cc/2016/09/26/nodejs-talk/">
      </div>
    
  </div>


				</div>
				 
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/l.jpg"
               alt="jimmy_jude" />
          <p class="site-author-name" itemprop="name">jimmy_jude</p>
          <p class="site-description motion-element" itemprop="description">a deviant programmer</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">33</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/lyz001" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/zrdsj" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.douban.com/people/zrdsj/" target="_blank" title="douban">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  douban
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/zrdsj" target="_blank" title="Facebook">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                  Facebook
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友链
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://puyart.net/" title="PuYart" target="_blank">PuYart</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础"><span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nodejs是啥"><span class="nav-text">node.js是啥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nodejs干啥用的"><span class="nav-text">node.js干啥用的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安装"><span class="nav-text">安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用"><span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块"><span class="nav-text">模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制模块"><span class="nav-text">二进制模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码组织部署"><span class="nav-text">代码组织部署</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#包package"><span class="nav-text">包（package）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#indexjs"><span class="nav-text">index.js</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pactagejson"><span class="nav-text">pactage.json</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令行程序"><span class="nav-text">命令行程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工程目录"><span class="nav-text">工程目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#npm"><span class="nav-text">npm</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#下载三方包"><span class="nav-text">下载三方包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#安装命令行程序"><span class="nav-text">安装命令行程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#发布代码"><span class="nav-text">发布代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#版本号"><span class="nav-text">版本号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#else"><span class="nav-text">else</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件操作"><span class="nav-text">文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#开门红"><span class="nav-text">开门红</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#小文件拷贝"><span class="nav-text">小文件拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#大文件拷贝"><span class="nav-text">大文件拷贝</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#api"><span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#buffer数据块"><span class="nav-text">Buffer（数据块）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stream数据流"><span class="nav-text">Stream（数据流）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#file-system文件系统"><span class="nav-text">File System（文件系统）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历目录"><span class="nav-text">遍历目录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#递归算法"><span class="nav-text">递归算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历算法"><span class="nav-text">遍历算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#同步遍历"><span class="nav-text">同步遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异步遍历"><span class="nav-text">异步遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文本编码"><span class="nav-text">文本编码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#bom的移除"><span class="nav-text">BOM的移除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gbk转utf8"><span class="nav-text">GBK转UTF8</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#单字节编码"><span class="nav-text">单字节编码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络操作"><span class="nav-text">网络操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引入"><span class="nav-text">引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#api-watching"><span class="nav-text">API watching</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#http"><span class="nav-text">HTTP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#https"><span class="nav-text">HTTPS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#url"><span class="nav-text">URL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#query-string"><span class="nav-text">Query String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#zlib"><span class="nav-text">Zlib</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#net"><span class="nav-text">Net</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#灵机一点"><span class="nav-text">灵机一点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程管理"><span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#开门红"><span class="nav-text">开门红</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#api"><span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#process"><span class="nav-text">Process</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#child-process"><span class="nav-text">Child Process</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cluster"><span class="nav-text">Cluster</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用场景"><span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#如何获取命令行参数"><span class="nav-text">如何获取命令行参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何退出程序"><span class="nav-text">如何退出程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何控制输入输出"><span class="nav-text">如何控制输入输出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何降权"><span class="nav-text">如何降权</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何创建子进程"><span class="nav-text">如何创建子进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程间如何通讯"><span class="nav-text">进程间如何通讯</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何守护子进程"><span class="nav-text">如何守护子进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步编程"><span class="nav-text">异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#回调"><span class="nav-text">回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码设计模式"><span class="nav-text">代码设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#函数返回值"><span class="nav-text">函数返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历数组"><span class="nav-text">遍历数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异常处理"><span class="nav-text">异常处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#域domain"><span class="nav-text">域（Domain）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#陷阱"><span class="nav-text">陷阱</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-text">小结</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>

 
			</div>
		</main>

		<footer id="footer" class="footer">
			<div class="footer-inner">
				<div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-tree"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jimmy_jude</span>
</div>


<script>


(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
 
 
			</div>
		</footer>

		<div class="back-to-top">
			<i class="fa fa-arrow-up"></i>
		</div>
	</div>

	

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

 


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>

  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>

 
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>

 


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>

 

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jimmyjude"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementById('footer')
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  





  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

 
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

 
 
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>

</html>
