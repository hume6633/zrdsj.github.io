<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>♀昨日的世界♂</title>
  <subtitle>✞此心光明 亦复何言✞</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zrdsj.cc/"/>
  <updated>2017-03-11T18:55:08.665Z</updated>
  <id>http://zrdsj.cc/</id>
  
  <author>
    <name>jimmy_jude</name>
    <email>jimmy@zrdsj.cc</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Less的若干记述</title>
    <link href="http://zrdsj.cc/2017/03/10/less/"/>
    <id>http://zrdsj.cc/2017/03/10/less/</id>
    <published>2017-03-10T13:05:41.831Z</published>
    <updated>2017-03-11T18:55:08.665Z</updated>
    
    <content type="html"><![CDATA[<p><strong><u>什么是<a href="https://github.com/less/less.js" target="_blank" rel="external">Less</a>？</u></strong></p>
<p>一门CSS预处理语言，一切都为CSS更好使。</p>
<a id="more"></a>
<p><u><strong>什么是 CSS 预处理语言？</strong></u></p>
<p>CSS <a href="https://zh.wikipedia.org/wiki/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8" target="_blank" rel="external">预处理器</a>定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。</p>
<p>通俗来讲，“CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题”。</p>
<p>So你可以在 CSS预处理语言中使用<strong>变量</strong>、<strong>简单的逻辑程序</strong>、<strong>函数</strong>等等编程语言中的一些基本特性，可以让其生成的的 CSS <strong>更加简洁</strong>、<strong>适应性更强</strong>、<strong>可读性更佳</strong>，<strong>更易于代码的维护</strong>。</p>
<p>一些 CSS 预处理语言：</p>
<p>CSS 预处理器技术已经非常的成熟，而且也涌现出了很多种不同的 <strong>CSS 预处理器语言</strong>，比如说：</p>
<ul>
<li>Sass（SCSS）</li>
<li>LESS    — ⭐️</li>
<li>Stylus</li>
<li>Turbine</li>
<li>Swithch CSS</li>
<li>CSS Cacheer</li>
<li>DT CSS</li>
</ul>
<p>Less是一种动态的样式语言。Less扩展了CSS的动态行为，比如说，设置变量（<strong>Variables</strong>）、混合书写模式（<strong>mixins</strong>）、操作（<strong>operations</strong>）和功能（<strong>functions</strong>）等等，最棒的是，Less使用了现有的CSS语法，也就是说，你可以直接把你现成的样式文件“style.css”直接改成“style.less”，也能正常工作。</p>
<h3 id="起步">起步</h3>
<p>Less的使用，在不同平台上（服务器端、客户端和集成的第三方环境等等）也不太一样，但一样的是都可以使用。</p>
<h4 id="服务器">服务器</h4>
<p>在服务器上安装Less的最简单的方法是通过npm，node.js包管理器，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g less</div></pre></td></tr></table></figure>
<p>之后是用命令行使用我们的这个CSS编译器了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lessc styles.less</div></pre></td></tr></table></figure>
<p>这将输出编译之后的 CSS 代码到 <code>stdout</code>，将输出重定向到一个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lessc styles.less &gt; styles.css</div></pre></td></tr></table></figure>
<p>若要输出压缩过的 CSS，只需添加 <code>-x</code> 选项。如果希望获得更好的压缩效果，还可以通过 <code>--clean-css</code> 选项启用 <a href="https://github.com/GoalSmashers/clean-css" target="_blank" rel="external">Clean CSS</a> 进行压缩。</p>
<p>执行 lessc 且不带任何参数，就会在命令行上输出所有可用选项的列表。</p>
<h4 id="代码生成">代码生成</h4>
<blockquote>
<p>这部分是我当前不理解的，在我目前的经验中，这种方法并不合理难以体现<strong>更好用</strong>。</p>
</blockquote>
<p>Nodejs的用法，写调用模块的JavaScript即可。例子（来自<a href="http://lesscss.org/" target="_blank" rel="external">官网</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var less = require(&apos;less&apos;);</div><div class="line"></div><div class="line">less.render(&apos;.class &#123; width: (1 + 1) &#125;&apos;, function (e, css) &#123;</div><div class="line">  console.log(css);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其实结果就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.class &#123;</div><div class="line">  width: 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>手动调用分析器（paser）和编译器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var parser = new(less.Parser);</div><div class="line"></div><div class="line">parser.parse(&apos;.class &#123; width: (1 + 1) &#125;&apos;, function (err, tree) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">    return console.error(err)</div><div class="line">  &#125;</div><div class="line">  console.log(tree.toCSS());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里（官方文档）其实提到了一些工具，第三方的命令行工具，基本没什么必要说。po出在<a href="http://www.runoob.com/manual/lessguide/#using-less-third-party-tools" target="_blank" rel="external">这里</a>。</p>
<h4 id="浏览器">浏览器</h4>
<p>在客户端使用 Less.js 是最容易的方式，并且在开发阶段很方便，但是，在生产环境中，性能和可靠性非常重要， 建议最好使用 node.js 或其它第三方工具进行预编译。</p>
<ol>
<li>在页面中加入 <code>.less</code> 样式表的链接，并将 <code>rel</code> 属性设置为 “<code>stylesheet/less</code>”：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt;</div></pre></td></tr></table></figure>
<ol start="2">
<li>下来，下载 <a href="https://github.com/less/less.js/archive/master.zip" target="_blank" rel="external">less.js</a> 并通过 <code>&lt;script&gt;&lt;/script&gt;</code> 标签将其引入，放置于页面的<code>&lt;head&gt;</code> 元素内：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;less.js&quot; type=&quot;text/javascript&quot;&gt;  -content-  &lt;/script&gt;</div></pre></td></tr></table></figure>
<p>也可以使用一些网站的CDN，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>然后就好了。</p>
<h3 id="使用">使用</h3>
<h4 id="变量">变量</h4>
<p>Less中的变量充许你在样式中的某个地方对常用的值进行定义，然后应用到样式中，这样只要改变你定义的变量参数值就可以达到改变全局的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*======== 定义变量===========*/</div><div class="line">@color: #4d926f;</div><div class="line">/*======== 应用到元素中 ========*/</div><div class="line">#header &#123;</div><div class="line">	color: @color;</div><div class="line">&#125;</div><div class="line">h2 &#123;</div><div class="line">	color: @color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是Less代码，编译成为CSS如下—&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #4d926f;</div><div class="line">&#125;</div><div class="line">h2 &#123;</div><div class="line">  color: #4d926f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Less还有计算功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@nice-blue: #5b83ad;</div><div class="line">@light-blue: @nice-blue + #111;</div><div class="line">#header &#123;</div><div class="line">	color: @light-blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译CSS为—&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #6c94be;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Less定义一个变量名为变量，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@color: #253636;</div><div class="line">@highlight: &quot;color&quot;;</div><div class="line">#header &#123;</div><div class="line">	color: @@highlight;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译CSS为—&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #253636;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在Less中的变量实际上就是一个“常量”，因为它们只能被定义一次。</strong></p>
<p>Less code；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@color: #253636;</div><div class="line">@highlight: &quot;color&quot;;</div><div class="line">@color: #ff3636;</div><div class="line">#header &#123;</div><div class="line">  color: @@highlight;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Compiled Css code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #ff3636;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="混入">混入</h4>
<p>混入其实是一种嵌套，它充许你将一个类嵌入到另一个类中，而被嵌入的这个类也称为是一个变量。</p>
<p>换句话说，你可以用一个类定义CSS，然后把整个为当作一个变量来使用，嵌入到另一个类中当作他的属性；另外混入也像一个带有参数的functions，如下在的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*========= 定义一个类 ===========*/			Less code</div><div class="line">.roundedCorners(@radius:5px) &#123;</div><div class="line">	-moz-border-radius: @radius;</div><div class="line">	-webkit-border-radius: @radius;</div><div class="line">	border-radius: @radius;</div><div class="line">&#125;</div><div class="line">/*＝＝＝＝＝＝＝＝＝＝ 定义的类应用到另个一个类中 ＝＝＝＝＝＝＝＝＝＝＝*/</div><div class="line">＃header &#123;</div><div class="line">    .roundedCorners;</div><div class="line">&#125;</div><div class="line">#footer &#123;</div><div class="line">    .roundedCorners(10px);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译过后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#header &#123;							      CSS code									</div><div class="line">  -moz-border-radius: 5px;</div><div class="line">  -webkit-border-radius: 5px;</div><div class="line">  border-radius: 5px;</div><div class="line">&#125;</div><div class="line">#footer &#123;</div><div class="line">  -moz-border-radius: 10px;</div><div class="line">  -webkit-border-radius: 10px;</div><div class="line">  border-radius: 10px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>这样任何CSS的类或ID下的样式都可以当作变量，使用混入模式用来当作另一个元素的属性值。</strong></p>
<p>混入(Mixin)有一个名词叫“混入参数（Parametric Mixins）”。Less具有一个特殊类型的规则集，就是一个类可以当作另一个元素的属生值，并且还可以接受其自己的参数。如下的Less</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*========== 定义一个规则，并且不设置默认参数值 ============*/</div><div class="line">.borderRadius(@radius)&#123;</div><div class="line">	-moz-border-radius: @radius;</div><div class="line">	-webkit-border-radius: @radius;</div><div class="line">	border-radius: @radius;</div><div class="line">&#125;</div><div class="line">/*============ 应用到元素中 ============*/</div><div class="line">#header &#123;</div><div class="line">    .borderRadius(10px); /*把10px传给变量@radius*/</div><div class="line">&#125;</div><div class="line">.btn &#123;</div><div class="line">    .borderRadius(3px);/*把3px传给变量@radius*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Complied CSS code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#header &#123;						 /*把10px传给变量@radius*/</div><div class="line">  -moz-border-radius: 10px;</div><div class="line">  -webkit-border-radius: 10px;			</div><div class="line">  border-radius: 10px;  </div><div class="line">&#125;</div><div class="line">.btn &#123;							 /*把3px传给变量@radius*/</div><div class="line">  -moz-border-radius: 3px;</div><div class="line">  -webkit-border-radius: 3px;</div><div class="line">  border-radius: 3px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mixins的参数定义默认值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.borderRadius(@radius:5px) &#123;</div><div class="line">	-moz-border-radius: @radius;</div><div class="line">	-webkit-border-radius: @radius;</div><div class="line">	border-radius: @radius;</div><div class="line">&#125;</div><div class="line">.btn &#123;</div><div class="line">    .borderRadius;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的CSS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.btn &#123;</div><div class="line">  -moz-border-radius: 5px;</div><div class="line">  -webkit-border-radius: 5px;</div><div class="line">  border-radius: 5px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;u&gt;什么是&lt;a href=&quot;https://github.com/less/less.js&quot;&gt;Less&lt;/a&gt;？&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一门CSS预处理语言，一切都为CSS更好使。&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="Less" scheme="http://zrdsj.cc/tags/Less/"/>
    
      <category term="CSS" scheme="http://zrdsj.cc/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>响应式设计笔记01</title>
    <link href="http://zrdsj.cc/2017/03/10/Responsive_Design_notes_1/"/>
    <id>http://zrdsj.cc/2017/03/10/Responsive_Design_notes_1/</id>
    <published>2017-03-10T09:44:43.434Z</published>
    <updated>2017-03-10T15:19:29.416Z</updated>
    
    <content type="html"><![CDATA[<p>主要是针对一些学习中</p>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是针对一些学习中&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="前端" scheme="http://zrdsj.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="响应式" scheme="http://zrdsj.cc/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>上帝的名字</title>
    <link href="http://zrdsj.cc/2017/03/07/god_name/"/>
    <id>http://zrdsj.cc/2017/03/07/god_name/</id>
    <published>2017-03-07T15:38:54.993Z</published>
    <updated>2017-03-10T15:15:36.048Z</updated>
    
    <content type="html"><![CDATA[<p>**读经：**创22：14、出15：26、17：15、士6：23-24、诗23：1、耶23：6、结48：35</p>
<hr>
<a id="more"></a>
<p>在上周的主日礼拜中，主讲张恩惠教士有意无意提到了一个话题，神（上帝）名字的数量。当时他直接给出了答案：<em>是七个不同的名字</em>。</p>
<p>在之后的时间里，我倒是渐渐地记下了这个可供学习的point。</p>
<p>我所谓的学习，当然是要理解贯彻了信仰的阅读与记录。但是对于此类的特性之特殊，我姑且做回引用，依然渴望荣耀我主，阿门。</p>
<h3 id="旧约圣经中神的名字部份">旧约圣经中神的名字（部份）</h3>
<p>圣经中的名字常常有特别意义，来表明那人的特点或与他有特别关系的历史，好像亚伯拉罕的意思是「<code>多国之父</code>」，撒拉是「<code>多国之母</code>」，以色列是「<code>尊荣的王子</code>」，……这些名字不仅有上述的特殊意义，更重要的是<strong>记录神的计划和神的应许</strong>。</p>
<p>神自己的名字更是如此，在圣经中神使用过好多个名字，每个名字都有特别的启示，把神自己向人启示，从神的名字便可以知道神是怎样的一位神，他性情又是怎样。</p>
<blockquote>
<p>没有一个名字可以把神包括起来，因为神的丰盛与无限是一个名字所不容易表达得完整的。</p>
</blockquote>
<p>不信的人以为神有那么多不同的名字，便据此而说圣经不是神的话，而是希伯来人把许多民族的神话累集而成。 <strong>这是无知的话</strong>。</p>
<p>看见神在某一个环境中就用某一个名字，而这名字正好配合那一个环境里所要有的启示，不是随意胡乱使用一个名字。在我有限的属灵生命当中，较早的时候我就体会到了，圣经、基督教信仰、灵修等等事务活动都是在一定的环境当中才得意义。</p>
<p>​	**以罗欣（ Elohim，希伯来文）**是圣经中最先出现的神的名字，中文圣经都把以罗欣翻作「<code>神</code>」。 这名字的意思是大能者，或是信实的大能者，当受敬拜的大能者。 这个名字常常使用在关乎神的创造上，创世记一章全章的「神」字都是以罗欣，是这样一位大能者创造了天地。 在看顾人这一面，神也常用以罗欣这个名字，叫接受启示的人得安息，也享用了安全的保证，因为他是信实的大能者。 创世记五十章廿四节里就是这样使用这个名字。 神这个名字在旧约里使用得最多，从创世记到玛拉基书都使用过这个名字，次数超过了2000次。</p>
<p>​	**耶和华（Yahweh，希伯来文）<em><em>是神的另外一个名字，这</em>道出了神是自自永有者的意思，并且指出了神一面是永有的神，一面又是现在的神。</em> 他固然是一切的源头，但又是时刻供应人的，特别是及时（现在）作人的供应。 神向摩西启示他是耶和华，就是让他知道神有这样的性情，使他可以安心的接受神的差遣。 在关乎救赎的启示上，神常常使用这一个名字（创3： 21 ；出:3： 12 ～ 17）。</p>
<p>​	<strong>阿多乃（Adonai）</strong> ，意思就是我的主，中文的圣经都翻译作「主」，这个意义很明朗，向人启示神就是主，是应当顺服祂的，这明显的指出神就是人顺服的对象。 认识神的人都有这一个学习，因为这是人对神唯一的正确态度，人在神面前出事就是出在不持守这一个正确的态度上（创15： 28 ，18： 3 、 27 、 30 ，20： 4 ；诗篇7： 13 ）。</p>
<p>以上神的三个名字是在旧约中最常见的，在诗篇中也是最多见的。</p>
<p>​	还有另外一个神也用的<a href="https://zh.wikipedia.org/wiki/%E4%BC%8A%E5%8B%92%E6%B2%99%E4%BB%A3" target="_blank" rel="external">名字</a>就是<strong>以勒沙代（El Shaddai）</strong> ，意思是全能的神，神向人这样启示祂自己，要叫人明白在祂那里是样样都有的，什么都不缺。 在亚伯拉罕等候得儿子的事上，神让他看见在不可能的环境中，神还是能的，因为祂是全有全足全丰的神。 人所短缺的，在祂那里还是丰足的，等候祂的人可以放心倚靠祂又取用祂（创17： 1 ～ 8 ，28： 3 ～ 4 ）。</p>
<p>神还用了好些其他的名字，这里不能都提。 但在提过这些名字以后，我们可以因此知道神的性情，更重要的是在那显示出父来的神的儿子身上，这些性情都一一显露，并且透过神的儿子叫我们蒙救赎的人也有份于神的性情（彼后1： 4 ）。</p>
<h3 id="耶和华的复名">耶和华的复名</h3>
<p>神在他自有永有的基础上，也透过了这一些复名更细致的向人启示祂自己和祂的救赎计划的内容。 有人以为耶和华的复名只有六个，有人以为有七个。</p>
<p>这里选择是七个的说法。</p>
<p>篇幅所限，不可能细致的描述耶和华的复名，甚于连神用这些名字启示他自己时的背景也不能提，但这些并不重要，重要的是我们存渴慕的心等候在主前面，让主借圣灵把他自己启示在我们里面，叫我们真认识他，又爱他。</p>
<p>耶和华的复名启示了在整个救赎计划上神供应人的事实，也是关乎神的儿子耶稣基督的工作内容。 按在圣经内出现的次序叫我们可以看到神的计划是如何安排的。</p>
<ol>
<li>
<p><strong>耶和华以勒</strong> （创22： 13 ～ 14 ）</p>
<p><code>“耶和华必为我们预备”</code>—&gt;这是亚伯拉罕献以撒的历史。神试验亚伯拉罕的顺服及他对神的爱心，要他将独生子以撒献上当作祭物，亚伯拉罕完全顺从，证明了他的忠心及对神的爱心，使神的心大满足。于是神预备了一只公羊羔代替以撒作为祭物，所以以撒就不需要死。在这件事里我们知道神的名字是耶和华以勒就是耶和华必预备意思。在这一个过程里，神启示他自己是为那些等候他的人作预备（羊羔）的神，从这名字 “神必预备” 里，使我们注意到，神要预备他自己的独生子作代赎的羔羊来献上，基督就是为我们得完全救赎而献上的燔祭。</p>
<p>在我们的日常生活中，也多次经历了耶和华以勒。另外，在基督徒的生活中我们也要学会顺从神，要有信心、忠心，神必为我们预备一切。</p>
</li>
</ol>
<ol start="2">
<li>
<p><strong>耶和华拉法</strong> （出15：26 ）</p>
<p>“<code>我耶和华是医治你的。”</code>—&gt;这个名字向我们启示那从替代者基督而来的医治恩典。以赛亚曾宣告，他诚然担当我们的忧患（疾病），背负我们的痛苦（疼痛）。（赛53：4）</p>
<p>当以色列人从埃及出来过红海以后，以色列人在旷野玛拉遇到水苦的事，神给他们一个方法来解决他们的需要，那时他们只看见自己的缺乏而吵闹，却没有看见神的大能，神给他们除去了缺乏，神就启示以色列人说耶和华是医治你的神，神就与他们立了约，这是医治的约。因此，耶和华拉法的意思是耶和华医治你的，这个名字向我们启示那从替代者基督而来的医治恩典。</p>
<p>以赛亚先知说：因他受的鞭伤，我们得医治。”(赛53：5)马太福音说：“他代替我们的软弱，担当我们的疾病。”(太 8：17)神医治了我们的灵魂，医治了我们内心的疾病。</p>
</li>
</ol>
<ol start="3">
<li>
<p><strong>耶和华尼西</strong> （出17： 8 ～ 13 ）</p>
<p><code>“耶和华是我的旌旗。”</code>—&gt;胜利、统率。（出17:15）基督在十字架上战胜了一切掌权的。（西2:15）他作为我们的替代者为我们提供了这样的恩典，这样我们就能“感谢神，使我们藉着我们的主耶稣基督得胜。”（林前15:57）</p>
<p>耶和华尼西的意思是耶和华是我的旌旗。这是神为以色列人争战的记录，藉摩西举手仰望神而显出得胜。当亚玛力人与以色列人争战的时候，摩西向天举起双手，以色列就得胜了。这名字的意思就是耶和华是我的旌旗（得胜），表示需要神的帮助。在基督徒的生活中，在我们的里面常常有属肉体和属灵的争战，只有神的帮助才能得胜。我们若信靠神就能胜过肉体、情欲、罪恶、魔鬼。基督在十字架上战胜了一切掌权的，他作为我们的替代者为我们提供了这样的恩典。这样，我们就能感谢神，使我们藉着我们的主耶稣基督得胜。</p>
</li>
</ol>
<ol start="4">
<li>
<p><strong>耶和华沙龙</strong> （士6： 24 ）</p>
<p><code>“耶和华赐平安。”</code>—&gt;它启示给我们救赎的恩典，得享他赐的平安。同样，耶稣也说：“我将我的平安赐给你们。”（约14：27） 这一祝福也是在救赎之中，因为“因他受的刑罚我们得平安”，（赛53：5）借着他在十字架上所流的血成就了和平。（西1：20）</p>
<p>以色列人在米甸人的困扰下，神向基甸显现并差遣他作以色列的拯救，他见了神的面还能存活，神藉此向人启示他自己是赐平安的神，耶和华沙龙意思就是耶和华赐平安，今天许多人在寻找精神和心灵的平安，可是找不着。人只有认识基督，得着救恩，才有真正的平安。《圣经》中主给我们留下了许多关于平安的宝贵应许。意外平安(腓 4：7)、十分平安(赛 26：3)、生命平安(罗 8：6)、长久平安(耶 14：13)。有人曾经数过，《圣经》中“平安”一词用过365次以上，表明一年365天中在主里天天都有平安。耶和华是我的平安，这是恩典内容之一，藉着基督，神把安息供应人。</p>
</li>
</ol>
<ol start="5">
<li>
<p><strong>耶和华锐亚</strong> （诗23： 1 ）</p>
<p><code>“耶和华是我的牧者。”</code>—&gt;耶稣是我们的牧者，“好牧人为羊舍命。”（约10：11,15）因此，这也是救赎带给我们的恩典。</p>
<p>诗篇23篇：</p>
<blockquote>
<p>【诗23:1】（大卫的诗。）耶和华是我的牧者，我必不至缺乏。
【诗23:2】他使我躺卧在青草地上，领我在可安歇的水边；
【诗23:3】他使我的灵魂苏醒，为自己的名引导我走义路。
【诗23:4】我虽然行过死荫的幽谷，也不怕遭害，因为你与我同在；你的杖，你的竿，都安慰我。
【诗23:5】在我敌人面前，你为我摆设筵席；你用油膏了我的头，使我的福杯满溢。
【诗23:6】我一生一世必有恩惠慈爱随着我，我且要住在耶和华的殿中，直到永远。</p>
</blockquote>
</li>
</ol>
<ol start="6">
<li>
<p><strong>耶和华齐根努</strong> （耶23： 6 ）</p>
<p>（齐根努）：<code>“耶和华是我们的义。”</code>—&gt;（耶23：6）耶稣在十字架上担当了我们的罪，由此他成了我们的义，我们接受了他所赐的义，（罗5：17）这是救赎的洪恩。</p>
<p>以色列人背逆神而仍然得神的记念的秘密，就是因为他们献祭的羔羊所预表的基督遮盖了他们，耶和华是我们义，这事到了新约就明显了。基督是我们的义，因为世人都犯了罪，亏欠了神的荣耀（罗3：23）。谁能够除去世人的罪孽？唯独耶稣能够，除了他以外，别无赎罪的救恩。耶稣拯救我们，代替我们死，使我们信而得救。保罗说：“乃是有信基督的义，就是因信神而有的义。”(腓3：9)</p>
</li>
</ol>
<ol start="7">
<li>
<p><strong>耶和华沙玛</strong> （结48：35）</p>
<p><code>“耶和华的所在。”</code>—&gt;它启示给我们救赎的恩典——得享与神的同在。耶稣应许：“我就常与你们同在。”（太28：20）这一祝福来自救赎之工，这一点已得到证实：你们从前远离神的人，如今却在基督耶稣里，靠着他的血，已经得亲近了。（弗2：13）</p>
<p>神与我们同在之处，在以西结书的记载里，这个地方是明明指国度的，也一直伸延到永世，也就是说耶和华在我们中间。主耶和华时刻与我们同在，这是我们最大的福份。有首诗歌说：“耶稣同在就是天堂。”有一位牧师说：“神与我同在，比我与你面对面在一起，更具体，更实在。”神在我们前面引导带领，神在我们后面看顾扶持，神在我们上面拯救眷顾，神在我们下面托住帮助。这就是耶和华的所在。</p>
</li>
</ol>
<h3 id="以罗欣和耶和华">以罗欣和耶和华</h3>
<p><strong>为何在创世记一章里不说耶和华、耶和华神，而只说神呢？</strong></p>
<blockquote>
<p>按原文的意思，神──以罗欣──字即那强有力者。 神这名字，是神对于造物方面说的，是指神在创造方面的关系说的。 耶和华是神与人发生关系的名字。</p>
<p>创世记二章是指神和人的关系，所以立刻说耶和华神；这是因为神同人的关系。 创世记一章没有人(第六日造人，还是注意创造)，所以说神。 创世记第二章有人，所以就说耶和华神。</p>
</blockquote>
<p><strong>每一次用耶和华神，即表明神和人发生关系。 每一次用神，就表明神的能力，和造物发生关系</strong>。</p>
<h3 id="interesting">Interesting</h3>
<p>以下是一些引用：</p>
<ul>
<li>中文的『神』字中文神字左边示字，上横两划表意上天下地，下三竖是日月星。 示字多是属天和属灵等字的部首。 神字右边申字谐音和会意，含义万物和万福是从神引伸出来的。</li>
<li>中文的『神』字神字在中文，是由一个缩写的名词和一个动词合成的。 左边是缩写的「神」字，右边是「申」字，引申的意思。 照说文，神的意思就是「天神引申万物」。 这样在创世记第一章用神字再合适也没有了，因为这一章告诉我们，神怎样创造万物。 当我们每次提到「神」字的时候，让我们记得，宇宙万物是祂创造的啊！ 》</li>
</ul>
<h3 id="我是自有永有的">我是自有永有的</h3>
<p>（出3:14）</p>
<blockquote>
<p>神对摩西说：「我是自有永有的(即耶和华) 。」 (这并非原文的字，这里译得不很好；不过当时译圣经的人，实有难处。因为他们若照原文直译，在中文就不成话。 )若是直译的话，就是：「我是，」「我就是我，」「我是那个，」「我就是那一个。」 「我就是我！」这真不成话。 不过这里面是包括自有永有之意。 我就是我，我就是那个我，译者只能用意译，译出我就是我之意思来。</p>
</blockquote>
<blockquote>
<p>若神在「我是」之下加上「能力」两字，就「我」不是「爱」了。 若加上「爱」字，就「我」是爱，而非能力、智慧、义、圣洁、救赎、安慰、保障、坚固台、避难所了。 神只说祂是…… ，而不说祂是什么，好让信祂的人自己在下面加上字眼， (哦，不是字眼，乃是属灵的实际！ )我们可以按 信心随便加上什么。 我们若有需要，同时并有信心，我们就可以在「神是」之下加上我们所需要的，而得 神补满我们那个需要。</p>
</blockquote>
<p>――倪柝声《耶和华》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;**读经：**创22：14、出15：26、17：15、士6：23-24、诗23：1、耶23：6、结48：35&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="moon" scheme="http://zrdsj.cc/categories/moon/"/>
    
    
      <category term="基督教" scheme="http://zrdsj.cc/tags/%E5%9F%BA%E7%9D%A3%E6%95%99/"/>
    
      <category term="圣经" scheme="http://zrdsj.cc/tags/%E5%9C%A3%E7%BB%8F/"/>
    
      <category term="以色列" scheme="http://zrdsj.cc/tags/%E4%BB%A5%E8%89%B2%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Vue-learn-notes.0</title>
    <link href="http://zrdsj.cc/2017/03/03/Vue-learn-notes/"/>
    <id>http://zrdsj.cc/2017/03/03/Vue-learn-notes/</id>
    <published>2017-03-03T07:51:19.000Z</published>
    <updated>2017-03-10T15:20:46.058Z</updated>
    
    <content type="html"><![CDATA[<p>sgerherhe</p>
<p>wegs</p>
<a id="more"></a>
<p>dbhgwer</p>
<p>hb</p>
<p>wreh</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sgerherhe&lt;/p&gt;
&lt;p&gt;wegs&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="经验之谈" scheme="http://zrdsj.cc/tags/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/"/>
    
      <category term="用户故事" scheme="http://zrdsj.cc/tags/%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B/"/>
    
      <category term="敏捷方法" scheme="http://zrdsj.cc/tags/%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>扯不下去的读后感2</title>
    <link href="http://zrdsj.cc/2017/03/02/book-review2/"/>
    <id>http://zrdsj.cc/2017/03/02/book-review2/</id>
    <published>2017-03-02T05:26:10.156Z</published>
    <updated>2017-03-10T15:14:24.893Z</updated>
    
    <content type="html"><![CDATA[<p>此篇是借之前某篇博客的续写，系列一共是7篇。本篇是第2篇，第一篇—<a href="http://zrdsj.cc/2016/09/23/book-review1/%E3%80%82">http://zrdsj.cc/2016/09/23/book-review1/。</a></p>
<a id="more"></a>
<h1 id="4444444444">4444444444</h1>
<p>这一章在书中的标题是：<strong>搜集故事</strong>。</p>
<blockquote>
<p>搜集故事，其实是告诉你如何与用户一起工作，通过互相的沟通来发现故事。熟练使用各种合适的方法，提出恰当的问题，获得用户真正的需求。</p>
</blockquote>
<ol>
<li>
<p>首先要说的是一个错误的想法—<strong>（我们）能够引出及捕捉需求</strong>。</p>
<p><em>引出(elicitation)</em>、<em>捕捉(catch)</em>，好像是捕鱼相关的术语，然而确实在1999年就有需求方面的专家引入了类似的概念[脱网（trawling）<a href="https://en.wikipedia.org/wiki/Trawling" target="_blank" rel="external">https://en.wikipedia.org/wiki/Trawling</a>]来描述收集需求的过程。</p>
<ul>
<li>不同的网用来捕获不同的鱼（需求）。</li>
<li>需求会像鱼一样，会成长会变化还会死亡。</li>
<li>某个区域进行拖网捕鱼不可能捕获所有的鱼（需求）。</li>
</ul>
<p>也就是说，我们可以通过用户故事来规定更为细化合理的职责分配，然而在具体的实施时，技能显得格外重要。就拿本小节的主题<u>需求</u>来说，一个好的需求分析人员(requirements trawler)知道到哪里寻找需求，而不会像新手一样在错误的地方浪费时间。</p>
<p>那么**（我们）能够引出及捕捉需求**这句话哪里错了呢？</p>
<blockquote>
<p>用户并不专业，也不能清楚地向我们解释他们的需求。需求并不是已经存在让用户去感受到并提供给我们（产品or开发）。</p>
<p>需求是可变的，不是一成不变的。及时找到了满意的需求并加以满足，但迭代的开发进行过后，需求会不会不再是需求？会不会膨胀？</p>
</blockquote>
</li>
<li>
<p>敏捷过程简单的方法之一，是<strong>辨别传统规范过程中搜集需求的方式</strong>！</p>
<p>传统规范过程的特征是它过分强调在项目早期正确地获取并写出全部的需求。敏捷项目并不要如此，敏捷过程也承认并没有一种理想的方法可以在一个单一阶段获取得到所有用户的用户故事。</p>
<p>即使如此。。。</p>
<p>我们还是应该在早期尝试编写我们可以编写的故事，即使是在十分笼统的阶段。</p>
<p>即：</p>
<blockquote>
<p>敏捷流程支持需求的后期涌现，依然需要对预期的发布进行展望并开始写下容易发现的故事。</p>
</blockquote>
</li>
<li>
<p>一些可以反复进行用户故事收集的方法。<strong>用户访谈</strong>、<strong>问卷调查</strong>、<strong>观察</strong>、<strong>故事编写工作坊</strong>。</p>
<ul>
<li><code>用户访谈</code>：大部分团队用来获取用户故事的默认方法。成功的关键在于是否选择到了正确的受访者。同时进行访谈时提问的技巧也很影响成功率，问题的选择是关键。</li>
<li><code>问卷调查</code>：这是另一种有效的方法，尤其在面对大规模的用户群体时，问卷调查显得格外有用。值得一提的是，问卷调查不适合作为脱网捕捞新故事的主要方法。主要是因为这是一种单向的静态问卷，不方便立即对用户的想法进行深入探讨。</li>
<li><code>观察</code>：唯一的缺点是能够产生的实际观察机会太少。优点是可以快速直接从用户处得到反馈，从而更早更频繁地发布软件。</li>
<li><code>故事编写工作坊</code>：理想情况下将各种与编写故事有帮助的人们聚集起来进行的会议。开发人员，用户，产品，客户等等都可以。每个人都尽可能多的编写要写的故事，在短时间内即可将产品的原型塑造。理想情况下，这种方式是最容易获取用户故事的。唯一的缺点在于，理想情况并不容易达到。</li>
</ul>
</li>
</ol>
<h1 id="5555555555">5555555555</h1>
<p>这一章在书中的标题是：<strong>与用户代理合作</strong>。</p>
<p>项目是做给别人的，准确来讲是做给客户的。客户团队因此必然显得举足轻重。</p>
<p>在客户团队中，拥有一个或者几个实际用户（真实用户）是重要的，遗憾的是我们很难有机会与实际用户一起工作，当我们无法求助于实际用户时候，我们就得求助于用户代理（user proxy)，他们代表着用户。</p>
<p>选择合适的用户代理对于项目的成功至关重要，要考虑潜在用户代理的背景和动机，不同领域的专家作为用户代理，是有差异的。</p>
<h5 id="用户的经理">用户的经理</h5>
<p>作为一个开发，你也许不会接触到很多的用户，却可能会接触到用户的经理，因为其代表着用户的立场可以讲作是用户代理。但是，<strong>如果用户的经理不是产品的实际用户，ta就不会是合适的用户代理</strong>。就不必为此上调其话语的优先级。</p>
<h5 id="开发经理">开发经理</h5>
<p>开发经理会试图担任用户代理，因为他们依然参加到了项目每天的细节之中。然而开发经理大多不是产品的用户，所以他们也不是理想的用户代理。</p>
<p>开发经理的立场不是用户甚至也不是企业的立场，他们也没有用户的亲身体验也不是领域专家。当然，如果其本身也是用户的话，一切处理当有所调整。</p>
<h5 id="销售人员">销售人员</h5>
<p>基本沿袭了老毛病。<strong>结论是：销售人员充当用户代理是危险的。</strong></p>
<p>销售人员必须避免把重点放在那些可以重新赢得已失去订单的故事上，在此基础上凭借着自己与用户的有效沟通，才可以很好的开发项目。</p>
<h5 id="领域专家">领域专家</h5>
<p>就是指那些主题专家，他们对软件应用领域的了解程度直接影响了软件的成败。尽管，在领域专家的丰富资源中，看似可以大加利用。实际上，<code>避免将产品开发成只适合那些与他们有相同水平的用户使用</code>才是重点。</p>
<h5 id="客户">客户</h5>
<p>你会不会感到惊讶？wtf？客户？</p>
<p>对的，我说的就是客户。</p>
<blockquote>
<p>在这里，我们所说的<u>客户</u>，和<u>用户</u>不一样的。</p>
</blockquote>
<p>作为做出决定购买决定的人，如果他们能与用户密切地交流，那么他们会是优秀的用户代理。如果他们本身也是用户，完美！（强无敌233</p>
<h5 id="else_1">else_1</h5>
<p>有一些培训师，业务分析师，系统分析师什么的，这些角色的问题也在于缺点的过于暴露。</p>
<blockquote>
<p>“术业有专攻”</p>
</blockquote>
<p>这些人员往往更关心产品（软件），而不是如何代表用户。</p>
<h5 id="else_2">else_2</h5>
<p>q:作为开发人员，这个过程我的职责是什么？</p>
<p>a:负责帮助组织机构为项目物色合适的客户。+负责了解不同类型的用户代理怎么考虑正在开发的产品。</p>
<p>q:负责客户的团队该干啥？</p>
<p>a:了解自己是属于哪类用户代理+了解自己作为用户代理可能存在的问题并加以防范克服。</p>
<h1 id="6666666666">6666666666</h1>
<p>用户故事验收测试</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此篇是借之前某篇博客的续写，系列一共是7篇。本篇是第2篇，第一篇—&lt;a href=&quot;http://zrdsj.cc/2016/09/23/book-review1/%E3%80%82&quot;&gt;http://zrdsj.cc/2016/09/23/book-review1/。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="经验之谈" scheme="http://zrdsj.cc/tags/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/"/>
    
      <category term="用户故事" scheme="http://zrdsj.cc/tags/%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B/"/>
    
      <category term="敏捷方法" scheme="http://zrdsj.cc/tags/%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95/"/>
    
      <category term="测试" scheme="http://zrdsj.cc/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>apm npm nvm cnpm都是什么鬼?</title>
    <link href="http://zrdsj.cc/2017/02/22/apm_npm_nvm_cnpm/"/>
    <id>http://zrdsj.cc/2017/02/22/apm_npm_nvm_cnpm/</id>
    <published>2017-02-22T10:57:24.336Z</published>
    <updated>2017-03-10T15:13:25.396Z</updated>
    
    <content type="html"><![CDATA[<p>来给自己普及下基本的几种工具的事情。</p>
<p>其实也不是那么有必要po出这么一篇，实在是，，，po主是太健忘。过上俩月，基本见面跟新的一样。。。wc，不敢想。</p>
<a id="more"></a>
<h3 id="apm">apm</h3>
<p>apm是啥啊？</p>
<blockquote>
<p>“我是搞node的，知道npm。这个apm呢······”</p>
</blockquote>
<p>还好你知道npm，hhhhhhhh</p>
<p>我想这么“简单”的东西，不会有人写博客来告诉你做什么怎么做了吧。似乎真是事实。</p>
<p>我们去Atom编辑器的官网上看看，就在 <a href="https://atom.io/" target="_blank" rel="external">https://atom.io/</a> 。点击<strong>Documentation</strong>:</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/atom-doc.jpg" alt="shenmegui"></p>
<p>搜索关键词：<strong>apm</strong>。结果就是那个所谓的<em>PackageManager</em>。。。</p>
<p>参考下npm (全称Node Package Manager，即node包管理器）是<a href="https://zh.wikipedia.org/wiki/Node.js" target="_blank" rel="external">Node.js</a>默认的、以<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="external">JavaScript</a>编写的<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1" target="_blank" rel="external">软件包管理系统</a>。)，很容易理解我所指的apm了。</p>
<blockquote>
<p>就是Atom编辑器的包管理器。</p>
</blockquote>
<p>用过Atom编辑器的话，你会知道这个apm是集成进了Atom安装包的，默认自带。再有多点了解的话你可能会点击GitHub的网站上看看这apm是个嘛玩意？传送门：<a href="https://github.com/atom/apm" target="_blank" rel="external">XXX</a></p>
<p>这一部分说的很清楚，只是全英文的阅读是有些难度的。。。<a href="https://github.com/atom/apm#apm" target="_blank" rel="external">https://github.com/atom/apm#apm</a>—atom-package-manager</p>
<p>至此，apm的事情就说完了。。。更多相关的学习，<a href="https://atom-china.org/" target="_blank" rel="external">https://atom-china.org/</a> Atom的中文社区，希望浏览的你可以有所收获。</p>
<h3 id="npm">npm</h3>
<p>这部分，我其实是拒绝的。我很想把官网的文档链接贴出来，留下句：“自己看吧” 就拍拍屁股走人的。结果，我拍拍屁股又回来了。</p>
<p>中文维基百科里面介绍了npm的前世今生，看这里 <a href="https://zh.wikipedia.org/wiki/Npm" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Npm</a> 。看上两遍，在有些nodejs基本认识的话，就很清楚了。</p>
<p>这个地方—<a href="https://docs.npmjs.com/" target="_blank" rel="external">官方文档</a>，你值得去看看（非常详细，但是全英文）。无论你是如何的使用npm，更不用说你和po主一样健忘类型的2333</p>
<p><strong>那么</strong>，node（npm）用户比atom（apm）用户要多得多，node用户都在用“npm”来做开发，那么。。。为啥不先讲npm呢？</p>
<blockquote>
<p>apm的规模不如npm，其使用模式却是和npm如出一辙。所以将apm一笔带过，在npm的论述上着重bb，在apm的理解上照旧就可以了。</p>
</blockquote>
<p>npm随着nodejs自动安装，在使用上也是依托命令行即可。</p>
<blockquote>
<p>在一个项目中存在package.json文件，那么即可使用<code>npm install</code>命令行自动安装维护项目所需的模块。在<code>package.json</code>文件中，开发者可以指定每个依赖项的版本范围，这样既可以保证模块自动更新，又不会因为所需模块功能大幅变化导致项目出现问题。开发者也可以选择将模块固定在某个版本之上。</p>
</blockquote>
<h4 id="">—</h4>
<p>以<em>express</em>为例，看看一个npm包都咋回事啊？？？</p>
<ol>
<li>在<a href="https://www.npmjs.com/" target="_blank" rel="external">npm官网</a>搜索到<a href="https://www.npmjs.com/package/express" target="_blank" rel="external">express框架</a>，这是一个快速简约的Web框架。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/express-pic.jpg" alt=""></p>
<ol start="2">
<li>
<p>继续浏览，可以看到使用的命令行说明，功能特性的更新等等。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/express-use.jpg" alt=""></p>
</li>
<li>
<p>是不是觉得我会把那个<a href="https://www.npmjs.com/package/express" target="_blank" rel="external">网页</a>接下来的每一项都给截图说明讲解？</p>
<p>，，，，，，</p>
<p>------不会的！😢</p>
</li>
</ol>
<ol start="4">
<li>接下来的说明也都是围绕着<em>express</em>框架的使用来进行的。文档、社区、安全问题、快速上手、原理、示例、测试等等一应俱全。也就是说，<strong>所有你在</strong><a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a><strong>找到的包</strong>，<strong>都会有类似的说明指导页面</strong>。</li>
<li>其实你若知道一些包的名称，直接谷歌得到的往往就是你要的。。。比如说<em>express</em>的google结果就是<img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/express-google.png" alt="233"></li>
</ol>
<h3 id="nvm">nvm</h3>
<p><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>是全称Node Version Manager，是专门管理不同版本的nodejs和npm的工具。这个工具是Mac下的专属工具，Windows的话可以使用<a href="https://github.com/hakobera/nvmw" target="_blank" rel="external">nvmw</a>或者<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">nvm-windows</a>.</p>
<p>那么我现在面临一个选择------我是继续说nvm?还是说Win平台的nvmw和nvm-windows?</p>
<p>我也不知道。</p>
<p>把每一个都提一下好了，毕竟自己的记性在那摆着，多写点也是有好处。</p>
<p>233</p>
<h4 id="nvm">nvm</h4>
<p><strong>nvm 不是一个 npm package，而是一个独立软件包。</strong></p>
<p>安装方式有两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</div></pre></td></tr></table></figure>
<p>以上脚本会把<code>nvm</code>库clone到<code>~/.nvm</code>，然后会在<code>~/.bash_profile</code>, <code>~/.zshrc</code>或<code>~/.profile</code>末尾添加source，安装完成之后，你可以用以下命令来安装node…</p>
<p><a href="https://github.com/creationix/nvm#usage" target="_blank" rel="external">https://github.com/creationix/nvm#usage</a></p>
<p>（逃</p>
<h4 id="n">n</h4>
<blockquote>
<p>你：这tm哪来的？是啥？</p>
</blockquote>
<blockquote>
<p>我：…</p>
</blockquote>
<p>其实讲到nvm其实是想说说node管理工具吧，哈哈。。。既然nvm只是支持Mac，那就说一个都支持都可用的—<a href="https://github.com/tj/n" target="_blank" rel="external">n</a>.</p>
<p>首先n 是一个需要全局安装的 <strong>npm</strong> 包(package)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g n</div></pre></td></tr></table></figure>
<p>这意味着，我们在使用 n 管理 node 版本前，首先需要一个 node 环境。</p>
<p>然后我们可以使用 n 来安装不同版本的 node。</p>
<p>在安装的时候，n 会先将指定版本的 node 存储下来，然后将其复制到我们熟知的路径 <code>/usr/local/bin</code>，非常简单明了。当然由于 n 会操作到非用户目录，所以需要加 <code>sudo</code> 来执行命令。</p>
<p>所以这样看来，n 在其实现上是一个非常容易理解的方案。</p>
<h4 id="n-or-nvm">n or nvm?</h4>
<p>这样看下来，nvm 和 n 的差异还是比较大的，具体体现在：</p>
<ol>
<li>安装简易度。nvm 安装起来显然是要麻烦不少；n 这种安装方式更符合 node 的惯性思维。见仁见智吧。</li>
<li>系统支持。注意， nvm 不支持 <a href="https://zh.wikipedia.org/zh-cn/Microsoft_Windows" target="_blank" rel="external">Windows</a>.</li>
<li>对全局模块的管理。n 对全局模块毫无作为，因此有可能在切换了 node 版本后发生全局模块执行出错的问题；nvm 的全局模块存在于各自版本的沙箱中，切换版本后需要重新安装，不同版本间也不存在任何冲突。</li>
<li>关于 node 路径。n 是万年不变的 <code>/usr/local/bin</code>；nvm 需要手动指定路径。</li>
</ol>
<p>所以，如何选择？见仁见智了，不过这里可以给出大体的建议：</p>
<ol>
<li>如果你使用 Windows，那没得选了，使用 n，或者换一台 Mac。</li>
<li>如果你会频繁切换 node 版本（比如本地经常测试最新版的特性，同时又要兼顾代码在生产环境的兼容性），那么从全局模块兼容性的角度考虑，只能使用 nvm。</li>
<li>如果你是一个轻量级的用户，不需要担心兼容性的问题，更关心 node 安装和使用上的体验，那么选择 n。</li>
</ol>
<p>参考出处—<a href="http://taobaofed.org/blog/2015/11/17/nvm-or-n/" target="_blank" rel="external">aaaaaaaaaa</a>.</p>
<h4 id="nvmw">nvmw</h4>
<p>这玩意相比nvm多了个w，其实就表达了这是在Windows平台使用的—Node.js版本管理工具。</p>
<p>这种玩意的官网一般没什么用（有没有都是一回事2333），直接在GitHub上看看去吧。。。<a href="https://github.com/hakobera/nvmw" target="_blank" rel="external">https://github.com/hakobera/nvmw</a></p>
<p>很不幸，在下方的README.md我们看到了这样一句话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SORRY, nvmw is no longer maintained. If someone wants to keep maintained, contact me by email or twitter.</div></pre></td></tr></table></figure>
<p>不再维护了，hehe.</p>
<p>不过呢，不维护有不是不能用了。。。继续看看吧</p>
<p>好的，</p>
<p>安装-用法-支持列表-镜像列表（好评啊，哈哈知道在瓷器国不能用2333）</p>
<p>这个项目已经是2年没有更新了，使用上可以预见的都是问题（主要是win作为开发平台我是不看好的）233</p>
<p>在<a href="https://segmentfault.com/" target="_blank" rel="external">Sf</a>找到了<a href="https://segmentfault.com/a/1190000004855835" target="_blank" rel="external">这篇文章</a>，也许是有些帮助的。需要的话，大家可以看看。</p>
<h4 id="nvm-windows">nvm-windows</h4>
<p>也就是一般说的<code>nvm for windows</code>，<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">链接</a>.</p>
<p>说到这里，如果还说用法和内容的话，没什么意思了。。。从apm讲到这里，其实都是一个样式的用法安装（我觉得可以这么说，虽然很不严谨）。</p>
<p>不再赘述，本小节的链接就很详细（全是英文233）.</p>
<h3 id="cnpm">cnpm</h3>
<p>俗称淘宝镜像。谷歌出的第一个结果是这个链接：<a href="https://npm.taobao.org/" target="_blank" rel="external">https://npm.taobao.org/</a> .</p>
<p>是个中文界面，剩下的不再说了。</p>
<p>其实就是npm在国内的网络环境下经常抽风不起作用，搭梯子也是不好使。然后国内的一些站点就引入了国外npm站点的全部资源，整个全给拷贝过来，然后呢这些国内站点就被称为<code>npm镜像资源</code>.</p>
<p>这些镜像资源的主页，大都是中文，很好理解与使用。</p>
<p>博客参考过的参考的几个页面：<a href="http://yijiebuyi.com/blog/b12eac891cdc5f0dff127ae18dc386d4.html" target="_blank" rel="external">1111</a>，<a href="http://riny.net/2014/cnpm/" target="_blank" rel="external">2222</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来给自己普及下基本的几种工具的事情。&lt;/p&gt;
&lt;p&gt;其实也不是那么有必要po出这么一篇，实在是，，，po主是太健忘。过上俩月，基本见面跟新的一样。。。wc，不敢想。&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="node" scheme="http://zrdsj.cc/tags/node/"/>
    
      <category term="Atom" scheme="http://zrdsj.cc/tags/Atom/"/>
    
      <category term="版本工具" scheme="http://zrdsj.cc/tags/%E7%89%88%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
    
      <category term="npm" scheme="http://zrdsj.cc/tags/npm/"/>
    
      <category term="nvm" scheme="http://zrdsj.cc/tags/nvm/"/>
    
  </entry>
  
  <entry>
    <title>搭衣服想起的事情---国旗下的演讲</title>
    <link href="http://zrdsj.cc/2017/02/19/speech-under-the-flag/"/>
    <id>http://zrdsj.cc/2017/02/19/speech-under-the-flag/</id>
    <published>2017-02-19T08:53:47.103Z</published>
    <updated>2017-03-10T15:20:29.608Z</updated>
    
    <content type="html"><![CDATA[<p>部署的最后一刻我仍觉得，这篇博客应该发成微博比较好，甚至是朋友圈的分量，都会好一些。</p>
<a id="more"></a>
<p>在第二实验小学的六年间，度过了所谓的童年。很多事情影响了后来的自己，这也是废话扯一下。要说的事情，其实是童年国旗下的演讲。</p>
<h3 id="演讲">演讲</h3>
<p>演讲的形式，是在每周一的早晨全校升国旗时候。国旗台前边总会有个孩子，拿着话筒郎朗上口地朗诵一篇《国旗下的演讲》。我清楚地记得每个人的第一句永远都一样，是：“老师好，同学们大家好，我是xx年纪x班的xxx,我今天国旗下演讲的题目是《Hello World😄》”，很单纯的套路，很单纯的年纪。</p>
<p>演讲是3-6（之前是5，有了6年级就是3-6了）年级，每个班轮流准备一名“演讲员”。我们每个年级只有两个班（二小规模小，后来证明仅仅是规模小，不耽误nb），所以每两个月总是能循环个一圈。</p>
<p>到我最终毕业成为初中生，我都没见过太多的同学登上这个台子。基本上这个任务是全班前3、4名的轮流任务，虽然他们不情愿（但别人也是不情愿），极少数情况下也有毛遂自荐的同学，一旦有人自荐，我看不到老师应有的欣喜反倒是那些本不愿演讲却被指派的同学会喜乐无比。（可能我还是太年轻，真的不懂得为什么老师不欣喜真心想演讲的同学）</p>
<h3 id="正题">正题</h3>
<p>在今天下午洗衣服的时候，我突然想到了旧时听了多次的一个<strong>国旗下的演讲主题</strong>。</p>
<p>很显然，<code>珍惜时间</code>是个好话题，如果是打鸡血催化信心，这个话题适合任何行业的任何级别的实际操作。因为我们没有无限的精力和时间。</p>
<p>是这样的：</p>
<p>我记得，很多次的演讲都是这个话题。这不奇怪。</p>
<p>我还记得，这个话题的多个演讲都有这样一个故事，穿插其中。</p>
<blockquote>
<p>是说有个人，怎么怎么样的碰到了一些mo法，可以让他返老孩童的一些事情。</p>
<p>这个人的设定是年纪很大的loser，这个人祈求啊求助啊，希望可以turn back time，可以一切再重来，可以再度活过。以便努力一波，成就新的成功人生。</p>
<p>返老孩童，多么浪漫的故事。</p>
<p>结局就是这个人又一次的生命中，依然浪费时光贪玩懒惰之类的。。。最后呢，又是一个老loser。。。</p>
<p>。。。。。。</p>
</blockquote>
<p>在有些版本中，这个返老孩童turn back time的次数甚至到了34次，不变的是。。这个主人公的结局，都是依然悲惨。</p>
<h3 id="so">so?</h3>
<p>那个时候，每年都要听上几遍这个故事。当时并没有很多的想法啊，只会感觉：啊，真的是要好好珍惜时间啊，人生短暂时间一去不返…之类的。。。</p>
<p>在今天下午，我想到这个事情的时候。</p>
<p>我在想，我为什么不是：<code>在当时和小伙伴们讨论下这个呢？深入思考一下为什么故事的结局是这个人反反复复一事无成，还觉得很合理呢？反思呢？</code></p>
<p>不知道看到这里的你，是否明白了我的意思呢？</p>
<p>这个事情，真的是细思极恐！<strong>可能</strong>是这个故事中的人有问题吧，才会反反复复如此low；也<strong>可能</strong>是这个人本身就是个zz，只知道happy &amp;&amp; lazy，最后loser了；还是说这故事本身有毒，就是告诉你对于大部分人来说，你就是那主人公，给你多少机会都是。。。。。。</p>
<p>stop！</p>
<p>停下来了，不再无休止的yy了。真的没什么用唉</p>
<p>多想这是个段子，笑一笑，结束了。。。</p>
<p>之所以会写这么多没用的事情，恐怕是在现实中找到了故事中的那个人的影子吧。想想看，作为号称有着智慧的人们，其中的一部分要是真的被返老孩童，恐怕以后还是那个b样吧。</p>
<p>相由心生，境由心造。不改变内心，何谈改过自己？</p>
<p>最后，段子结束吧</p>
<blockquote>
<p>如果代码敲的足够快，我的孤独就追不上我。
如果排查bug查的足够仔细，便能找回丢失的自己。
只要我程序里的坑埋的够深，就能骗过匆匆流逝的时光。</p>
<p>😢</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;部署的最后一刻我仍觉得，这篇博客应该发成微博比较好，甚至是朋友圈的分量，都会好一些。&lt;/p&gt;
    
    </summary>
    
      <category term="moon" scheme="http://zrdsj.cc/categories/moon/"/>
    
    
      <category term="情感" scheme="http://zrdsj.cc/tags/%E6%83%85%E6%84%9F/"/>
    
      <category term="杂谈" scheme="http://zrdsj.cc/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="回忆" scheme="http://zrdsj.cc/tags/%E5%9B%9E%E5%BF%86/"/>
    
      <category term="人生" scheme="http://zrdsj.cc/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>我妈开始催我结婚了</title>
    <link href="http://zrdsj.cc/2017/01/23/marry/"/>
    <id>http://zrdsj.cc/2017/01/23/marry/</id>
    <published>2017-01-23T14:38:02.622Z</published>
    <updated>2017-03-10T15:17:52.430Z</updated>
    
    <content type="html"><![CDATA[<p>妈妈开始逼我结婚了555555</p>
<a id="more"></a>
<h3 id="001">001</h3>
<p>说点什么吧，如题。约么是26个小时前（170122 20:00），我和我妈就这个话题开始了沟通，显而易见这是第一波沟通。</p>
<p>结果，也挺正常的结果。我们彼此表达了<code>最真最深</code>的个人态度，跟预想的一样，我果然困苦不堪。</p>
<p>我喜欢月亮，不仅是生活中的月亮，也是心中的月亮。</p>
<p>我们在足够多的地方，遇见过动人的话语，感人的台词，无非是点触到了我们内人柔弱的那部分！只要不是傲慢无礼，我们总会被“征服”，进而越发感慨反而在另一个方向影响了自己的生活，当然了，，，是有人愈发沉沦也有人倍加叛逆渴望新生。</p>
<h3 id="002">002</h3>
<p>我的恋爱经历不多，却也是被折磨得够呛。其中的缘由，想必是因为无知的时间太过持续而不能在那个年纪珍惜拥有吧。值得唏嘘的是，还好没有把彼此折磨死去活来才放手，这一点上，一直让我深深内疚有暗自庆幸。内疚的是我竟是如此忠于现实归于理性，庆幸的是过得不好还好没折磨自己去变得更差，大抵如此吧。</p>
<p>如果现在，在经历了算是人生年轻时可的“迷茫期”之后吧，对于即将大学毕业的我来说，爱是什么？</p>
<p>我做一番引用吧，是塞林格的一个句子。</p>
<blockquote>
<p>“There are some people who think love is sex and marriage and six o’clock-kisses and children, and perhaps it is, Miss Lester. But do you know what I think? <strong>I think love is a touch and yet not a touch.”</strong></p>
</blockquote>
<p>若即若离，翩然浮现，氤氲迷醉，若只初见。</p>
<h3 id="003">003</h3>
<p>初二时候，深深爱上了柯南道尔笔下的福尔摩斯，那个cool cool的侦探。不得不承认，那时候的自己，在不幸福的成长环境中，爱上那样的角色，是可怕的。</p>
<p>种子只要不发芽，就没什么问题。可是什么种子要是在心里生了根发了芽，就不平常了。</p>
<p>我得说，中二这种病，不管因为什么。。总之持续到了现在，就是问题了。<code>福尔摩斯对于女性的看法，在原著中的体现，放到今天是不合理的！极其不合理！！！</code></p>
<p>不幸的是，我虽然没有那种看法，却再难有了喜爱的心。我得说，我也不是虚伪，我所夸赞的女性的美和女性的好，我是真心的！两者的关系很<strong>矛盾</strong>，我说不清楚，我自己也是为此不快乐，我想这是<strong>矛盾</strong>的副作用吧。</p>
<h3 id="004">004</h3>
<p>结个尾，我妈催我结婚了。这意味着，曾经的哭哭啼啼恩恩怨怨小打小闹的日子快结束了。真正的人生吧，才要开始。我有多留恋天上的月亮，我的斗争就会有多jilie吧。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;妈妈开始逼我结婚了555555&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="情感" scheme="http://zrdsj.cc/tags/%E6%83%85%E6%84%9F/"/>
    
      <category term="人生" scheme="http://zrdsj.cc/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="谶语少bb" scheme="http://zrdsj.cc/tags/%E8%B0%B6%E8%AF%AD%E5%B0%91bb/"/>
    
      <category term="love" scheme="http://zrdsj.cc/tags/love/"/>
    
  </entry>
  
  <entry>
    <title>2017计划</title>
    <link href="http://zrdsj.cc/2017/01/20/plan-2017/"/>
    <id>http://zrdsj.cc/2017/01/20/plan-2017/</id>
    <published>2017-01-20T13:01:44.296Z</published>
    <updated>2017-03-10T15:19:17.579Z</updated>
    
    <content type="html"><![CDATA[<p>2017过去三周了，看着自己2016年1月1日的新年计划，完成度最终定格在了70%。按照60分是及格分的话，算是及格了。hehe</p>
<a id="more"></a>
<h2 id="2017该干点啥">2017该干点啥</h2>
<p>这是毕业年，总觉得会是意味着许多事情。。。却在写的时候不知道意味着什么。。。想到过统筹各个方面，去进行自己下一步计划的评估，最终却是不了了知。（can’t read my Poker Face  23333</p>
<p>最后想了几条大的，基本上和去年的计划一样。</p>
<h3 id="技能工作学习">技能/工作/学习</h3>
<ul>
<li>
<p>合格的前端</p>
<p><a href="https://www.zhihu.com/question/38922374" target="_blank" rel="external">1</a>   <a href="https://www.zhihu.com/question/40343934" target="_blank" rel="external">2</a>   <a href="https://www.zhihu.com/question/19657253" target="_blank" rel="external">3</a></p>
</li>
<li>
<p>清醒的头脑和更专心学习能力</p>
</li>
<li>
<p>顺利毕业</p>
</li>
<li>
<p>合适的工作</p>
</li>
</ul>
<h3 id="生活">生活</h3>
<ul>
<li>素食主义，再彻底些</li>
<li>可以的话，开始专业的健身。不可以的话，也得健健康康（拿手上的xx来做标准</li>
</ul>
<h3 id="life">life</h3>
<ul>
<li>BIBLE</li>
<li>全年12条朋友圈</li>
<li>尽量在年底给自己一台Mac</li>
<li>51篇博客（全年）</li>
<li>做成自己的 ‘阳明先生’</li>
<li>读完豆瓣的书，听完喜马拉雅的书</li>
<li>克制自己不再进入别人的世界，一如既往地别浪费时间去爱别人，好好爱自己爱家人。</li>
</ul>
<p>that’s all</p>
<h2 id="远方的期许">远方的期许</h2>
<blockquote>
<p>道通著行迹，期无负初心。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017过去三周了，看着自己2016年1月1日的新年计划，完成度最终定格在了70%。按照60分是及格分的话，算是及格了。hehe&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="在路上" scheme="http://zrdsj.cc/tags/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    
      <category term="辞旧迎新" scheme="http://zrdsj.cc/tags/%E8%BE%9E%E6%97%A7%E8%BF%8E%E6%96%B0/"/>
    
      <category term="杂谈" scheme="http://zrdsj.cc/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="憧憬" scheme="http://zrdsj.cc/tags/%E6%86%A7%E6%86%AC/"/>
    
  </entry>
  
  <entry>
    <title>无虞与无余</title>
    <link href="http://zrdsj.cc/2017/01/16/No-%20fear-or-nothing/"/>
    <id>http://zrdsj.cc/2017/01/16/No- fear-or-nothing/</id>
    <published>2017-01-16T07:57:41.025Z</published>
    <updated>2017-03-10T15:18:07.984Z</updated>
    
    <content type="html"><![CDATA[<p>Ok, 2017的第一篇，写点东西。缅怀下外公。</p>
<a id="more"></a>
<p>在这个月的4日晚，我得知了外公去世。6日办理了丧事，8日（周日）又看了看，算是告一段落。</p>
<p>存在的印象，如果仅仅是这两年的话。。。有五个：<strong>一个青年发呆的模样</strong>，<strong>一条没能弯曲的大长腿</strong>，<strong>入殓日泥泞的小路</strong>，<strong>幼年我火烧过的树根</strong>，<strong>老家窗台的火柴盒子</strong>。</p>
<h3 id="1">1</h3>
<p>这个青年不是我，是舅家的大儿子，外公的长孙。</p>
<p>高中紧张的生活，还有他特殊的家庭生活，不说是折磨的话，也像极了折磨。他的状态看起来，总归不是个好状态。</p>
<p>几年来，我陪他回过几次老家探望老人。年龄也比较相近，我们有些共同的语言和话题。然而大多数时候，总是我在bb我在主导两人间的交流，哈哈我并不是强势的人也无意于主导同世界沟通方面的事情。然而，他压力比较大思维比较不活跃，就如此了。</p>
<p>这几年的生活里，总是纠结交织着这份情感。共同的长辈，不同的后辈身份，“剪不断，理还乱”的关系。。。</p>
<p>喜欢也许是以后的情感，讨厌也永远谈不上，亦庄亦谐过日子吧！</p>
<h3 id="2">2</h3>
<p>外公在我童年的印象中是个停不下来的人，停不下来的木匠。</p>
<p>性格很急，脾气倒不大，外婆总是规劝唠叨，哈哈。在那个村落里，这是我熟悉的场景，我喜欢这个。</p>
<p>最近几年，外公的身体一年不如一年，多种心脑血管的问题纷至沓来。那个硬朗的木匠不见了，他先是不怎么动了，再后来，他动不了了。</p>
<p>每次回家，帮助外婆照顾几个小时的外公，当时的感觉是痛苦的，照顾人的技能很惭愧我实在是做的不好。每次结束离开，过上一段时间，会有那么几分钟我会感到很舒服，很安心。</p>
<p>仅仅是我看望了外公吧，</p>
<p>外公的大长腿，在当年是走来走去，不亦忙乎？！。记忆中最后看见的大长腿，是坐在轮椅上，毫无动静，而老人脸上平静而又哭丧皱眉的表情，酷似幼时淘气顽皮的自己孩童的面庞。</p>
<h3 id="3">3</h3>
<p>开封回来是5日，6日下葬。天气凄冷无比的风和雨，心情所致吧，黑夜凌晨所见的光景，总也好不到哪去。</p>
<p>泥土遇了雨水，就成泥土了。粘的鞋子裤子到处都是，带来带去，似乎是不愿你离开又像是希望你带走它。</p>
<p>真的，泥水有点多。。。恐怕是忘不了那些鞋子最后的模样了</p>
<h3 id="4">4</h3>
<p>在我五六岁的时候，离老家20米的小土岭上有棵老杨树。那是一个秋天，我记得很多玉米杆堆在一旁，还有些麦秸堆。“城里孩子”自然是少见火柴，各种玩啊玩。</p>
<p>最后，终于一根火柴带着火花飞了出去。。。燃着了许多东西，。刚开始，我用石头砖头进行了尝试（灭火），失败了。</p>
<p>边上没人，最后我听见小姨的呼唤离开了。</p>
<p>再后来，附近的人看到了黑烟和一人多高的火苗。。。废了点事，解决了问题。。。</p>
<p>总得说说是谁家孩子干错了事情。。。</p>
<p>我很害怕，最以后事情不算太大不了了之了。但我记得，我被大人询问的时候，我脸很红很辣。</p>
<p>大概4年前吧，我注意到火灾发生的地方，那棵树被砍了。树墩仍可见我造成的伤痕，</p>
<h3 id="5">5</h3>
<p>幼时，父母下乡忙的时候，常常寄宿在老家。</p>
<p>流鼻血，外公拿掉了嘴里的烟斗迅速磕去了烟灰，并与另一只手里的火柴一并放进口袋中。治疗我。。。······</p>
<p>下巴磕破了，外公拿起窗台上的空火柴盒子，撕破了贴在我血流不止的下巴。。。······</p>
<p>好吧，这个小物件儿，不简单吧。</p>
<p>最后是一首那时候一直听的歌，想妈妈时候会听</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=332567&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ok, 2017的第一篇，写点东西。缅怀下外公。&lt;/p&gt;
    
    </summary>
    
      <category term="moon" scheme="http://zrdsj.cc/categories/moon/"/>
    
    
      <category term="生活随笔" scheme="http://zrdsj.cc/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
      <category term="回忆" scheme="http://zrdsj.cc/tags/%E5%9B%9E%E5%BF%86/"/>
    
      <category term="人生" scheme="http://zrdsj.cc/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>2016 Conclusion</title>
    <link href="http://zrdsj.cc/2016/12/31/Conclusion-2016/"/>
    <id>http://zrdsj.cc/2016/12/31/Conclusion-2016/</id>
    <published>2016-12-31T13:34:54.180Z</published>
    <updated>2017-03-10T15:15:00.801Z</updated>
    
    <content type="html"><![CDATA[<p>开始敲下这篇博客第一个字符的时候，离2016的离去还有两个多小时。这篇博客是这个阳历年的最后一篇了，其实之前的18篇有的也仅仅是写了一部分，并没有写完。</p>
<a id="more"></a>
<p>这样的‘匆匆’总能说明，说明我的生活是出了问题的。也诚然，我是认可这个说法的。这一年过得太快，和以往经历过的任何一年都一样，快！我多希望，自己可以不再感叹这些尘埃落定的事情。hhh</p>
<p>我总结了10个，可以称之为<strong>things</strong>的东西吧（顺序无关排名），来缅怀过去的一年，也是安慰自己饱经“沧桑”的内心。</p>
<h4 id="剃须刀">剃须刀</h4>
<p>2016年初的时候，不再用那种便携的小型电动剃须刀了。换成了传统的手动剃须刀，用的是吉列锋速3这个较为通常的入门品牌吧。</p>
<p>没啥好说的，怎么想这个话题都是没啥好说的。提起来我也是些许郁闷呢，哈哈哈哈。在一月的时候，有一次和lc去县城的ty大酒店洗澡，又是开车又是大包小包的衣服，一切比起平日的生活整的很不和谐。一通下来我花了40，他花了80？</p>
<p>总之俩人洗了个痛快。偶然间的谈话中，我谈到了他洗澡篮里的剃须刀，进而引出的聊天内容中我总结2个points：</p>
<ul>
<li>基本上每两天就得刮一次脸</li>
<li>起初都是会觉得不可思议</li>
</ul>
<p>好吧，是这样啊。</p>
<p>有时候走在大街上看到十几岁的青年们，脸上也是淡淡的胡须时候，会联想到几年前的自己。这是一种睹物思人吧，得到了暗示，思维总是停不下来的。</p>
<p>那个时候的自己（几年前），即使胡须有时候也看上去有点显眼了，也没想过什么。大学有很长一段时间，我是蓄了胡须的，我总觉得这样让自己显得毛茸茸的可以不被别人伤害。。。哈哈，我不知道是否算是奇怪的想法。后来，我意识到胡子硬了也长得快了，还是啊，得刮！</p>
<p>基本上两三天我也是得刮次胡子了现在。起初觉得不可思议？我倒没有这先关的记忆和印象了。如今的每次刮胡，都像是在进行一种仪式，为了生活？为了什么？我说不清楚，我有点慌，是 我有点慌！</p>
<p>别说岁月改变了我们模样，是生活造就了我们，就是我们选择的所过的生活，它造就了我们。我们小心翼翼，不免浑浑噩噩，也常常困倦不已却依然一副傲慢的姿态对待世界对待自己。还好，也许刮胡子的时候，会放慢自己的节奏，你不会想刮不好更不会想慌张到刮破了脸皮，，，。。。好吧，下次刮胡子的时候，要拿好剃须刀，好好的刮刮胡子。</p>
<h4 id="红楼梦">红楼梦</h4>
<p>这个好说很多了，就是这一年我正式成为了《红楼梦》的读者，而后迷上了其中的<strong>故事</strong>。详细完整的读了通行本，仅一遍。</p>
<p>喜欢是喜欢，我掩饰不住；认识尚肤浅，我必须承认。所以，我得实事求是陈述一下。喜欢很爱，但是呢尚且初级一点，但又已然是：<strong>一朝入梦 终身不醒</strong></p>
<p>我不是喜欢立flag的人，但是提及《红楼梦》，立flag的事情变得复杂起来了。奇书之奇，也许这就算是一处吧。不做搬运工，什么都不做了，表示一下未来的话，，，肯定，这本中国古典名著与我本人的故事并未结束，未来的日子里我的生命中，肯定是有《红楼梦》的影子的。</p>
<p>而那时候，又是一番：你方唱罢我登场 么？</p>
<h4 id="口语粉碎机">口语粉碎机</h4>
<p>在2015年的12月初始，我报名de一个微信上的英语培训班。英语口语教学为其口号，实则是英语思维的教授与学习监督。</p>
<p>骨子里是DC粉丝（今年4月份才搞清楚DC 漫威），却在“山头”成为了<code>复仇者联盟</code>小组的组长。06301-06310，组长在这里不会说太多的东西，但组长忘不了你们的。</p>
<p>山头的故事告一段落，日后的事情。。。有机会再续前缘吧。</p>
<h4 id="叶隐老师">叶隐老师</h4>
<p>起初这是bigger的副作用。试想你突然间在网络上遇见了一个让你知识认识全方位五体投地的大叔，还是会很吃惊的。bigger的话，其实可以说是附庸风雅也可以说是近朱者赤的想望吧。</p>
<p>不与介绍了，叶老师是个基督徒说来的话我们互相称为弟兄。叶老师的学问，见识，胆量，气质等等虽说我仅是几篇文字几张照片去了解的，，，但是我觉得，堪为此国度少有的清醒之人。</p>
<p>此处写来，我更希望是给自己的一份勉励与期许，希望在不久的将来，我和叶老师之间的距离，可以近一些。</p>
<h4 id="缘分">‘缘分’</h4>
<p>这个是在说，与另外几个人的相遇。十分感激这几段生活，列个列表的话是这样：</p>
<ul>
<li>十月份火车上认识的大姐姐小阿姨（深圳）</li>
<li>二月份山上认识的Susan（温州）</li>
<li>九月份火车上认识的会计小学姐（深圳）</li>
<li>十二月豆瓣上因音乐偶然认识的kiwi姐（上海）</li>
</ul>
<p>差不多就是这几位吧，在往年的生活中，并无这般的际遇！对于我来说新认识一些人，或多或少会有所审视有所察觉，发现更多的Fun。不是几句长短，几声问候，几个祝福，而是说我的心创造我自己的生活，而生活如何，我想不是容易解答的吧。</p>
<p>引用一段塞林格的话语（写<strong>爱</strong>的一段话）结束这个章节吧</p>
<blockquote>
<p>There are some people who think love is sex and marriage and six o’clock-kisses and children, and perhaps it is, Miss Lester. But do you know what I think? <strong>I think love is a touch and yet not a touch</strong>.</p>
<p>有人认为爱是性，是婚姻，是清晨六点的吻，是一堆孩子，也许真是这样的，莱斯特小姐。但妳知道我怎么想吗，我觉得爱是想触碰又收回手。</p>
</blockquote>
<h4 id="网易云音乐">网易云音乐</h4>
<p>自己的品味，让自己说是不合适的。但是呢，客观来看还是有些奇怪或者说是意料之外的事情发生了。</p>
<p>网易云音乐，会在每天根据用户所喜爱所听的音乐<em>口味</em>给出20首推荐。最近的四五天我的推荐全是些外国风情的曲子。。。是的，是曲子。钢琴，胡琴，萨克斯风，口琴，小提琴，吉他…是些轻音乐和英文歌。</p>
<p>我喜欢目前的状态，我喜欢这些推荐，和音乐背后大家的段子、故事。就像是自己也经历了参与，不带着过度的陶醉，淡淡的如清茶如白水，慵懒又像午后的阳光，清净好似雪野的黎明。。。所爱者，该是这样，就是这样。</p>
<h4 id="基督生活">基督生活</h4>
<p>在这十个话题中这个话题是最重要的！这次拿出来说，却是说不了很多，自己根基尚浅学问鄙陋无以为谈。一直以来微信关注的公众号服务号数量是30个（多了总要牺牲几个不去看，不要那么多），每一段时间我都会根据自己的情况有所整理，最新的数据是我关注的基督教相关的有7个（7/31，话说腾讯相关的服务号就有10个），比重也说明了是很重视的。</p>
<p>这一年的前半年，愈发感觉生命的无奈与困倦。于是重新开始了每周日的礼拜并强行拜读圣经，又加上平日自己刻意使生命慢下来平静下来的态度，逐渐好了很多。</p>
<p>在暑假去到深圳之后，有所浮躁也多了写忧愁。在平湖教堂，十一期间，得救了很多，学到了很多。</p>
<p>十一月的灵修生活中，应该是初步认识到骄傲的可怕。在十二月的灵修生活还有读书认识宗教改革这个过程中，更为深刻的认识到骄傲的巨大危害。</p>
<p>每次去教会，去参加活动，而后都会学到更多的思想和属灵的认识，而非是一时的感动。</p>
<p>所有一切的存在，都因天父上帝的恩赐，阿门。如今，2017新的一年也期待会有更好的灵修生活。</p>
<h4 id="素食主义">素食主义</h4>
<p>这一年的11月，在家里生了一场小病，但过的却是格外的难受。不再赘述。</p>
<p>我开始了有过的最深刻的关于健康的思考，夹杂着自我标榜的基督思维以及回忆。我的身体在初一以前是极棒的，小时候同龄的孩子我是见过几个经常生病的，还有一些不那么利索的。大家一起成长，最后呢似乎是河东转河西了。</p>
<p>我在初二得了严重的鼻炎，这一病就是5年。直到后来严重成了<u>鼻息肉</u>做了手术，才算是将这一顽疾去除，现在的我身体已经不再遭受鼻炎的困扰。四年后，我才又得了值得一提的病，就是上个月让我无能为力无所事事的病。11月初刚得病时候我获知这病是病毒对于表皮神经的入侵，是来自肉类的病毒，但病因归根结底是来自免疫力的低下。</p>
<p>那个时候起，我决定了未来逐步规划自己的饮食与作息，讲健康看得更重要一些。</p>
<p><code>饮食</code>上，只是非常简单的一点<strong>不再吃肉</strong>。我不再枚举这个国度关于食品安全的问题和事故了，但我自己想要以后的生活里忍住不再吃肉了，渐渐地改掉吃肉的习惯吧，对血管心脏也是有好处。这个也是双刃剑吧，哈哈自己承受吧。</p>
<p><code>作息</code>上，就一点，有意识的少熬夜。</p>
<h4 id="王阳明">王阳明</h4>
<p>这个仅仅是半个月来新培养的偶像吧，王守仁王阳明！</p>
<p>关于这位仁兄的事情，我是因为听书而感兴趣的。在喜马拉雅fm有档节目《明朝那些事儿》（上下共计350集*23min）,这节目中有那么四五十集是有说到王阳明的，从那个时候起，对于这位“圣人”，产生了浓厚的兴趣。</p>
<p>前几天，专门了解了一些王阳明的介绍事迹生平,在<code>知乎</code> <code>贴吧</code>这些地方也逛了又逛。</p>
<p>“阳明心学”的评价，比较公认的一条是<code>近500年来中国诞生的最伟大的智慧</code>。伟不伟大厉不厉害，中外近代许多名人相关的事迹相信是有说服力的。</p>
<p>最后，笑笑表个态：2016是认识了解王阳明的元年，但此后对于“阳明心学”的学习和感悟，才刚开始吧。</p>
<h4 id="一丢丢花钱的事情">一丢丢花钱的事情</h4>
<p>这个话题，很有的聊。我只是说自己这一年感受最大的一点。这一年，在一些新的领域花了钱。</p>
<p>豆瓣上买电子书，订阅付费的新闻服务，网易云的音乐会员，付费的视频学习和教学。。。相比于传统的文化学习方面的投资，2016在这方面我的心态和行为也都有了变化。</p>
<p>诚然，谁不喜欢有品质有内涵的生活呢？希望这是个契机，借此激励自己在未来的生活中努力加油，去为自己拼下更好的生活。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始敲下这篇博客第一个字符的时候，离2016的离去还有两个多小时。这篇博客是这个阳历年的最后一篇了，其实之前的18篇有的也仅仅是写了一部分，并没有写完。&lt;/p&gt;
    
    </summary>
    
      <category term="moon" scheme="http://zrdsj.cc/categories/moon/"/>
    
    
      <category term="生活随笔" scheme="http://zrdsj.cc/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
      <category term="基督教" scheme="http://zrdsj.cc/tags/%E5%9F%BA%E7%9D%A3%E6%95%99/"/>
    
      <category term="辞旧迎新" scheme="http://zrdsj.cc/tags/%E8%BE%9E%E6%97%A7%E8%BF%8E%E6%96%B0/"/>
    
      <category term="杂谈" scheme="http://zrdsj.cc/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="智障人生" scheme="http://zrdsj.cc/tags/%E6%99%BA%E9%9A%9C%E4%BA%BA%E7%94%9F/"/>
    
      <category term="回忆" scheme="http://zrdsj.cc/tags/%E5%9B%9E%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>圣诞note</title>
    <link href="http://zrdsj.cc/2016/12/25/Christmas-notes/"/>
    <id>http://zrdsj.cc/2016/12/25/Christmas-notes/</id>
    <published>2016-12-25T05:29:47.474Z</published>
    <updated>2017-03-10T15:14:36.329Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2016/12/25，阳历是圣诞节。近几日的生活，是有一些感触的。在此做些分享。</p>
<a id="more"></a>
<h3 id="1223">1223</h3>
<p>这一日是周五，天气是个多云的冷天，天空中的太阳并没有露脸，无风无雨无云，就是这样。这一天的活动是<strong>圣诞崇拜演出</strong>，在上午的08:30演出到了12:00，下午是13:00演出到了17:00吧，晚上的聚会我并没有参与。</p>
<p>演出在我的心里，意义大于形式。不是我马后炮，也不是妄自菲薄，而是说日常的所见所闻之下，但凡内心有波动又不失理智，恐怕都会这么想。</p>
<p>汝阳、开封、深圳三个地方我去过几个教堂，深圳的老年人比较少所以到教堂的人也没什么老年人，但是也是深圳年纪最大的阶层了。汝阳和开封的情况，说句令人唏嘘的话，全是些老头老太太。这样的群体里，凡有聚会演出的话，事实上是有很大限制的。</p>
<p>周五的演出也确实印证了这一点，仅仅上午就有17个表演队二十多个节目，我数了数差不多5、6个是中年人的表演节目其余全是老年人们的。很真实很真诚，得益于主的恩典，演出节目并不失精彩与掌声。阿门！</p>
<h3 id="1224">1224</h3>
<p>这天的19:00有平安夜崇拜聚会，在我写这篇blog时候应该称之为昨晚。我有点大意了这是我自己的失误，我在当天晚上的17:50走着走去教堂基本上是走了50分钟走到了。</p>
<p>我没想到人会有那么多。</p>
<p>多到来了警察维持秩序。我相信这些人都可称得上是弟兄姊妹，但是确确实实人多了许多事情都进行不好。仅仅呆了20分钟，无奈我实在听不到聚会分享的内容只是些嘈杂的声音。</p>
<p>眼所见，耳所闻，心所感。皆不是自己所喜所感，我也很难过也很惭愧，我对不住主的恩赐。最终我离开了西门教堂，走回学校。</p>
<p><strong>作为基督徒，我充满怜悯和悲伤，愿这个民族在基督真理的光照下新生，而不是在暗夜里徒劳的折腾</strong>。我真真的希望，日常的礼拜可以有更多的年轻人和中年人到来。😄</p>
<h3 id="1225">1225</h3>
<p>就是今天。</p>
<p>设想一下，周日礼拜天+圣诞节，真的是人tai多了。情形和昨晚一样，人多到警察维持秩序。</p>
<p>最终无奈，站在外面太冷，只得离开。</p>
<p>······</p>
<h3 id="写在最后">写在最后</h3>
<p>【腓1:27】只要你们行事为人与基督的福音相称，叫我或来见你们，或不在你们那里，可以听见你们的景况，知道你们同有一个心志，站立得稳，为所信的福音齐心努力。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2016/12/25，阳历是圣诞节。近几日的生活，是有一些感触的。在此做些分享。&lt;/p&gt;
    
    </summary>
    
      <category term="moon" scheme="http://zrdsj.cc/categories/moon/"/>
    
    
      <category term="圣诞" scheme="http://zrdsj.cc/tags/%E5%9C%A3%E8%AF%9E/"/>
    
      <category term="生活随笔" scheme="http://zrdsj.cc/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诉苦呻吟" scheme="http://zrdsj.cc/tags/%E8%AF%89%E8%8B%A6%E5%91%BB%E5%90%9F/"/>
    
      <category term="基督教" scheme="http://zrdsj.cc/tags/%E5%9F%BA%E7%9D%A3%E6%95%99/"/>
    
      <category term="情感" scheme="http://zrdsj.cc/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>I am back</title>
    <link href="http://zrdsj.cc/2016/12/21/return/"/>
    <id>http://zrdsj.cc/2016/12/21/return/</id>
    <published>2016-12-21T06:34:11.313Z</published>
    <updated>2017-03-10T15:19:38.990Z</updated>
    
    <content type="html"><![CDATA[<p>这次是来说说，为什么到了12月的下旬，才想起来写点东西，在这孤独的博客中。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1612-1701/shijian.png" alt="hh"></p>
<p>上面看到的这张pic，是2016.12.21下午的14:47分，我的一张截图。十月，十一月，十二月的前二十天，我没有写一些东西，似乎是我的学习中断了停下了脚步。事实上，这是很难让我接受的事实，我不太走运吧也许。</p>
<h3 id="luoyang-shenzhen">luoyang-shenzhen</h3>
<p>我依然记得，十月八日那天晚饭是在哪家饭店吃的什么，炒面吃的炒面！饭后我接到一个电话，是妈妈打来的告诉我奶奶走了。第二天1009我坐了下午的飞机，在17点钟的时候到了郑州新郑国际机场。那时候机场外是下面那个样子。。。</p>
<p>我依然记得，十月八日那天晚饭是在哪家饭店吃的什么，炒面吃的炒面！饭后我接到一个电话，是妈妈打来的告诉我奶奶走了。第二天1009我坐了下午的飞机，在17点钟的时候到了郑州新郑国际机场。那时候机场外是下面那个样子。。。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1612-1701/xzjcc.jpg" alt="jc"></p>
<p>后来的事情：在家停留了四天，奶奶的葬礼是基督教葬礼，并无太多的形式，并没有太嘈杂大家的生活。</p>
<p>有些事情，并不需要它们再次掠过大脑，不需要。that’s all!</p>
<p>我，回到了深圳。</p>
<h3 id="shenzhen-suzhou">shenzhen-suzhou</h3>
<p>之后的时间就是十月中旬了，我回了深圳。四个月的培训其实三个月已经基本完成了，因此这次的回归，似乎更像分别离别的情调。</p>
<p>我还是挺了解自己的，在一些方面。哈哈，果不其然。紧紧回深圳一周之后，我就确定了下一站自己的目的地:苏州。zcy所在的地方。离开深圳的那天，下雨了，胃口很不好，牛肉粉，也有点腻。</p>
<p>1119，到了苏州。缓缓休息，准备面试，不料，意外频出。！</p>
<p>我之前是无神论者，但一直相信因果逻辑轮回报应之类的事情，总会有个说法有个缘由，不然人lei的事情就太简单了。我没有办法解释自己，但是我确实很难受，就像那几天苏州的天气一样，一直下雨，一直刮风，一直阴天。</p>
<h4 id="背疼">背疼</h4>
<p>就在苏州，刚刚调整好了自己，我的右背疼了起来，起初我以为是拉伤，后来发现不是，因为它一直在痛。再后来，右胸下边儿，也就是肋骨外皮肤的位置，也开始痛。我以为是吃了不太干净的食物引起的皮肤过敏发炎，就搞了一些消炎类的涂抹膏药。然而我错了。仅仅过了一天，疼痛没有减轻，而且好像加重了。开始出现红色的带状疹子？（我不确定，但是绝对有颜色了）然后在疼了第三天的下午，我打算出去买点水果。</p>
<p>我不知道为什么找到水果摊之后我没有立即买，而是在手机地图上，找到了几个附近诊所，我可能是想去看看。还是在那个方向，我多走了几步路，找到了两个诊所。</p>
<p>我走进了一个社区卫生院之类的三层楼小医院。在二楼，大夫们似乎都不在。我问了问仅剩的一位牙科大夫，说明了自己的情况，给他看了我的身体“杰作”。牙科医生不耐烦的回复模样我至今记忆犹新，但是他告诉了我两件事情，我得的病是什么？（<code>带状孢疹</code>）我应该怎么办？（<code>hospital</code>）</p>
<h4 id="苏州-洛阳">? 苏州-洛阳</h4>
<p>没了心情，我还是买了水果，苹果和香蕉，回到了住处已经是下午的4点钟了。我没有太犹豫，收拾了几件东西，一边告别出差的zcy，一边安排好了自己的归途。是的，我想回去，回洛阳回家。</p>
<p>事情就不详说了，我回到了家，治好了病，然而，我没想到的是，这一切整整花了我一个月的时间。整个11月，我都在一个休养的状态。这期间的生活很丰富，我也得到了好的休息，无奈的是，我知道和我身份相同的人们，他们并未停下努力的脚步去工作学习。</p>
<p>So，白天我可以嘻嘻哈哈一副正常模样，晚上离开网吧到家，稍微静下来我就如吸烟的马男波杰克那般。。。会哭出来么？</p>
<p><img src="https://pic4.zhimg.com/06438940f6566b1cceba113f9608105b_b.jpg" alt=""></p>
<p>渐渐地，我也缓了过来。</p>
<h3 id="拯救与福音">拯救与福音</h3>
<p>接下来要说的事情是关于自己属灵生命的，关于基督教事宜的。本篇博客有一个新标签：骄傲与道德主义。这次我也不会大谈特谈什么东西，圣经坚持读了也就半年（还差得远呢），谈不了什么的！说一些自己的事情罢了。</p>
<p>九月份十月份的一些时间里，我常常莫名感到激动。是因为<strong>我觉得那段时间的自己到教堂忏悔祷告，日常不行试探不行恶，假以时日天父上帝定会将福音传授与我并救我脱离险恶给我信心是我彰显主的大能在这人间</strong>。</p>
<p>似乎第一眼看上去，我的想法也是没什么大问题。至少我是觉得，我怀着自己的<u>信心</u>信封耶稣侍奉主，是不会有问题的！</p>
<p>苏州回洛阳治病是在1025这天，回家之后很快病情得到了控制（不再严重，疼依然如故），随即来临的几次礼拜我也认真参与了，然后我意识到了我已经出了很大的问题。</p>
<p>上面那段黑体字，彰显的不是神的大能而是我的无知。我的信仰，是怀揣着功利在里面的，为了自己？哈哈哈哈，可笑。基督徒的奉献是为了天上的神父，怎么能是为了天父的恩赐救赎而去信奉基督呢？那样就算是信了一辈子，能得着福音么？答案是显而易见的。下图是我1106在家中古严教会的礼拜日记吧算是，截图</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1612-1701/czbqjt.png" alt=""></p>
<p>至此，我明白了自己属灵生命中，多了几分骄傲，而这是不可取的！</p>
<p>后来的事情，这个链接：<a href="http://mp.weixin.qq.com/s?__biz=MzAxNTE5NzQyNA==&amp;mid=2650623409&amp;idx=1&amp;sn=006f5c8c80b674d07ee846980f2b7022&amp;chksm=838e582eb4f9d138302f31198067e97972a973f683807204552451e71285a801bef19f5821c9&amp;mpshare=1&amp;scene=1&amp;srcid=1221gpvLVAteu7tw3rZeSMA2#rd" target="_blank" rel="external">教会</a>了我更多。</p>
<h3 id="最后">最后</h3>
<p>我回来了，往后的日子，托付与主，托付与自由的心。😄😢</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次是来说说，为什么到了12月的下旬，才想起来写点东西，在这孤独的博客中。&lt;/p&gt;
    
    </summary>
    
      <category term="moon" scheme="http://zrdsj.cc/categories/moon/"/>
    
    
      <category term="生活随笔" scheme="http://zrdsj.cc/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
      <category term="基督教" scheme="http://zrdsj.cc/tags/%E5%9F%BA%E7%9D%A3%E6%95%99/"/>
    
      <category term="杂谈" scheme="http://zrdsj.cc/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="智障人生" scheme="http://zrdsj.cc/tags/%E6%99%BA%E9%9A%9C%E4%BA%BA%E7%94%9F/"/>
    
      <category term="骄傲与道德主义" scheme="http://zrdsj.cc/tags/%E9%AA%84%E5%82%B2%E4%B8%8E%E9%81%93%E5%BE%B7%E4%B8%BB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>一些关于161001平湖教堂的分享</title>
    <link href="http://zrdsj.cc/2016/10/01/Something-in-Pinghu-church/"/>
    <id>http://zrdsj.cc/2016/10/01/Something-in-Pinghu-church/</id>
    <published>2016-10-01T14:52:01.270Z</published>
    <updated>2017-03-10T15:20:03.202Z</updated>
    
    <content type="html"><![CDATA[<p>不知道若干年后，是否存在某个惬意的午后，也许是雨天也许是艳阳。。。我会想起那年的十月一日，那个内心欢欣不已的日子。😄.</p>
<a id="more"></a>
<p>主上赐予的眼界与慈爱!阿门！</p>
<p>上午的早堂，是两位来自美国的老者所分享的。话题是基督世界经典的&quot;希望、信心&quot;话题，值得一提的两点是，1是我第一次看到外国人在做’传教士’之类的工作（两人并不是神学起家）2是通俗世界里两人的工作与宗教的距离实在是相差甚远。。。</p>
<p>不多说了，回顾现在开始。</p>
<h3 id="dr-henry">Dr Henry</h3>
<p>这个名字曾经在我的生命中，是另一份含义。几乎是时间和青春的代名词。伴随着那些年的风，散尽了只剩回忆。。。Thierry·Henry。。。</p>
<p>这次的Henry博士，是位近80岁的退休工程师，之前平湖堂张牧师的介绍说是喷气式动力发动机方面的科学家，后来我又问了翻译得知Henry博士还为谷歌发射卫星时做了技术顾问之类的工作。以一个旁观者，我来回顾下。</p>
<h4 id="生平">生平</h4>
<p>老人的童年没有被提及，学习方面说了一点，可以知道的是当年的Henry是个不折不扣的聪明孩子。也就是上个世纪的5060年代的那个时间段，老人轻松解决了在自己学业上的问题。在大学顺利拿到了博士学位。</p>
<p>按照老人自己的感慨：‘<code>我一度觉得我自己足够厉害，我可以通过自己的方式改变自己的生活。年纪轻轻成为工程师，成为人们眼中羡慕的人！</code>’。</p>
<p>老人在1967年，加入美国阿波罗登月计划。当时是不到30岁的年轻人，却以工程师的身份，去参与可以说是至今为止都是最重要的几个人类事件之一的’<code>阿波罗登月计划</code>’，赞叹之余我也更好奇这样的牛人后来的故事。</p>
<p>继续讲。</p>
<p>在计划成功的1969年，许多科学家工程师退出了，仅仅一部分还在执行其中的收尾工作。Henry当时退出了，并且在大学成为了教授。Henry说自己大学教授时期都在研究火箭，喷气式发动机之类的。。。</p>
<p>再后来的故事是关于老Henry的生活。。。</p>
<h4 id="生活">生活</h4>
<p>老Henry很感激上帝给予他生命中的两个爱人！两个Susan，2333</p>
<p>第一个Susan，是老Henry的大学女友。毕业后没多久，老Henry就同Susan结婚了。老Henry直言当年他喜欢男孩子，然而Susan第一次生了个女孩。</p>
<p>我难以描述台上老Henry诉说这些故事时候的表情和态度，但一切都让我觉得：踏实，愿意倾听，又不感觉空洞乏味。</p>
<p>生活仍在继续。老Henry和Susan的第二个孩子也来到了世上，还是个女孩。但这个时候，已经过去了几年了，老Henry表示这个时候他已经没有很多想法了，他表示这都是自己的爱自己的亲人。所以，当时还年轻的Henry其实生活都很快乐都很充实。</p>
<p>接下来老人的一番话以及后来老人的遭遇，着实让我陷入深思。</p>
<p>老Henry说：按照平常的看法，他的人生着实完美。对他来说，爱情和生活都是如此的完美，，，所做的工作在今天来说可以说是顶级技术流是不会失业的那种。也因此，老Henry坦言那个时候的他，觉得什么事情都可以凭借自己的能力去解决去变得不再是问题。（月球都上的去，还有什么办不了？2333，私人吐槽毫无恶意，，，just for fun）</p>
<p>这样，生活仍再继续！！！到了某一年，是在老Henry与Susan结婚30多年后，Susan患上了脑癌。这一年的话，Henry已经60多岁了。</p>
<p>我们不再探讨这种事情对一个家庭的影响，也不说各种无意义的骚话段子了。结果是，在经历了两年的治疗与痛苦之后，这位Susan，离开的深深相爱的Henry和他们的两个女儿。</p>
<p>此时的Henry，不再年轻的Henry，独身一人的Henry。。。几次寻死未成，并因此患上了严重的心理疾病。。。当年的他曾经认为，自己的世界可以自己去改变自己去使之美好。。然而毫无疑问，妻子的患病离世让Henry过往的骄傲和自豪也变得支离破碎。我很同情那时候的Henry，本该携手走向黄昏的美丽人生，却是天人永隔的悲痛。</p>
<p>这个时候，最大的事情莫过于先帮助痛苦的老者振作起来。在亲朋好友以及两个女儿的帮助下，减少了工作的Henry开始去向往日他并不熟悉的教堂。</p>
<p>这个过程持续了5年，在神父与牧师的帮助下。老Henry成为了一名忠实的信徒，内心的创伤得到解脱，支离破碎的心再度愈合。Henry博士坦言，在那几年里，重新学会笑容让他意识到生命中诸多美好的事情其实如此简单，对，微笑就行了！</p>
<p>同样的，在逐渐疗伤的过程中。老Henry逐渐的开始了自己的神职职业工作，跟随着教堂去帮助其他的人（主要是给予相似经历的人以心灵帮助）。</p>
<p>感谢上帝，Henry遇到了第二个Susan。像电影剧情一样，但确是老者身上的真实故事！这第二个Susan，也是一把年纪的中年妇女了，丈夫因为脑癌去世留下了自己和三个男孩。如此这般之后她也在也在教堂工作了。</p>
<p>故事的最终，老Henry和第二个Susan在一起了。他们有两个女儿和三个儿子，孙子辈的都已经有13个了！当时老Henry在讲到这里时候，教堂里面有人都开始鼓掌了。哈哈，谢谢上帝！</p>
<p>2004年，带着妻子的祝福，Henry第一次来到中国，他是来传授福音的，在一些地方的教堂里讲述他受神眷顾重新振作的励志人生并且致力于对因亲人疾病离世引发的心理障碍患者进行帮助与疏导。今天十月一日的聚会，是Henry的第13次中国之行了。</p>
<p>在最后，Henry表示他的妻子Susan同他一样十分喜爱中国。但Henry深知这些年妻子的身体状况并不理想，体重很轻经常睡不了觉。。。为此他为进行了一些健康疗养，Henry表示在不久的将来他会和妻子一同来到中国，为人们带去福音和祝福！</p>
<h3 id="dr-randy">Dr Randy</h3>
<h4 id="生平">生平</h4>
<p>这位白发苍苍的老者，叫兰迪 Randy。是为牧师，同上面那位Henry起初是同样的梦想—工程师。后来，并不像Henry那样顺利成为了科学家。</p>
<p>这位Randy的父亲老Randy是二战的美国空军英雄！从父亲那里，Randy学到了很多，比如说信仰。在Randy还是个年轻青年的时候，就完成了对基督教的绝对信奉和对神的忠贞侍奉。</p>
<p>然而命运无常造化弄人，在Randy20多岁的时候，发生了意外事故。在和自己的师傅一同进行实验时候意外触电，Randy失去了双臂师傅则失去了生命。阿门。</p>
<p>题外话：但凡了解基督教祷告的事情的人都会知道，我们为了自己的身心不受伤害向上帝衷心祷告并且献上赞美与荣耀。在这种情况下却受到命运的这般照顾，即是说是一个充满正能量和信心的人，也不免会感到伤心失意甚至不理解。</p>
<p>话说回来。。当时的Randy才20多岁，用世俗的话说其实就是’空军英雄的儿子是个残废’。。。这样的事情太可怕了，及使对一个已然多年调整心态的的教徒来说这也是困难凶险的事情，何况一个20多岁的年轻人！</p>
<p>Randy老人并没有说太多自己遭受的痛苦，老人平静的演说配合着左臂义肢的铁钩笔画，在空中撩出的画面似乎在表示着。。。都过去了，我现在很好！</p>
<p>Randy表示，在失去了双臂之后，他最终振作了。他之后所做的事情被限制太多了，最终Randy选择了成为神职人员侍奉上帝。他说：<code>我向上帝祈祷，渴望得到一副新的义肢</code>。</p>
<p>听上去，也是可以理解的。失去了手臂的信徒，向他的主祈祷得到应得的义肢。合理不过分！</p>
<p>Randy之后哈哈一笑，继续说：他这一等，没想到竟然是39年。得益于技术的障碍，之前的假肢最多是个装饰并不能很好的使用。而他现在的义肢，则是在失去左臂39年后才获得的，可以根据大脑的信息操控去进行动作。去在我的角度看上去Randy可以夹起水杯喝水可以夹起《BIBLE》。。。</p>
<p>我不知道一个人的一生可以有多少个39年去祈祷一件事情，也不清楚有多少人会为了一件事坚守39年的信心，更理解不了反复祷告祈求天父恩宠30多年无果之时还能调整自我的伟大心态。。。愿主能赐予我坚强、力量。阿门。</p>
<p>Randy还说到了，在高中开始他就希望上帝在他未来的生活中赐予他位美丽善良的妻子。还好，仅仅是9年，也还是在Randy20多岁的时候，Randy遇见了生命中的另一半。至今，约莫是半个世纪的爱情了。:love:</p>
<p>Randy之前和妻子就来过平湖教堂，是在前年，那个时候许多当地的弟兄姊妹得到了他们老夫妻的祝福与祷告。所以在今天Randy再度提起自己的妻子时候，所有人献出了掌声。</p>
<h4 id="生命中的智慧-by_randy分享">生命中的智慧 by_Randy分享</h4>
<p>Randy的故事比起Henry，很不一样。至少一点显得Randy的事情是自己的，所以专门说说Randy的一些智慧的分享。</p>
<p>Randy在几十分钟属于它的时间里侃侃而谈，70多岁的年纪，精神矍铄情绪时而高涨动作时而夸张。。。我的天呢，天堂的人恐怕都是这个模样吧（我告诉自己2333）。</p>
<p>Randy说，终其一生他都觉得上帝在他的身边，在遇到事情的时候，心里总会有个声音在提醒他自己，诸如&quot;<code>嘿，兄弟。淡定点。。</code>&quot;&quot;<code>嘿，远离XXX，不要XXX</code>&quot;&quot;<code>别急着高兴，Randy</code>&quot;。。。这些来自上帝的声音让他受益匪浅，最初的时候他是怀疑自己有妄想症什么的后来也忘了如何不了了之了。但是真真切切的Randy表示，上帝借走了他的胳膊，却也给了他别样精彩的人生，他从来不觉得世界欠他什么反而觉得自己该回馈社会。</p>
<p>也因此，古稀之年的美国神父放弃安闲的退休生活去到遥远的东方宣扬上帝宣扬爱与自由。</p>
<p>救死扶伤与心灵救赎一直以来在我心中，都是人性最伟大的实际行为体现，其他的所谓的正能量不知道高到哪去了。Randy与Henry在这个层面上来讲，称得上真正的伟大。</p>
<h3 id="last">last</h3>
<p>献上两人的一张照片截图：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1610-1611/henryrandy.jpg" alt=""></p>
<p><strong>这不是段子也不是自我安慰的精神读物，但凡有所了解基督教的都知道，这样的事情在基督世界里可以说是司空见惯，却也不缺真实性。</strong></p>
<p>是我的信心不足，还想要强调一遍。2333😂</p>
<p>我信奉天父的阶段，无论如何认证都是浅显的初级阶段。我已经感受到了基督生活带给我的变化，走在路上可以因为一片飘落的树叶驻足而立可以为了一个步履蹒跚老者心酸难过，这些事情在别人看来似乎是不务正业的神经病，我自己的话，，，开心就好吧😄</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道若干年后，是否存在某个惬意的午后，也许是雨天也许是艳阳。。。我会想起那年的十月一日，那个内心欢欣不已的日子。😄.&lt;/p&gt;
    
    </summary>
    
      <category term="moon" scheme="http://zrdsj.cc/categories/moon/"/>
    
    
      <category term="基督教" scheme="http://zrdsj.cc/tags/%E5%9F%BA%E7%9D%A3%E6%95%99/"/>
    
      <category term="情感" scheme="http://zrdsj.cc/tags/%E6%83%85%E6%84%9F/"/>
    
      <category term="圣经" scheme="http://zrdsj.cc/tags/%E5%9C%A3%E7%BB%8F/"/>
    
      <category term="人生" scheme="http://zrdsj.cc/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>一篇关于微信公众号的辣鸡感想</title>
    <link href="http://zrdsj.cc/2016/09/30/Idea-about-WeChat-public-number/"/>
    <id>http://zrdsj.cc/2016/09/30/Idea-about-WeChat-public-number/</id>
    <published>2016-09-30T15:12:30.629Z</published>
    <updated>2017-03-10T15:16:05.454Z</updated>
    
    <content type="html"><![CDATA[<p>在昨晚小区院子里，和zcy喷了会。不禁想起些许往事。。。一些关于一本书的事情。</p>
<a id="more"></a>
<p>这本书：</p>
<p><img src="data:image/jpeg;base64,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" alt="logo"></p>
<p>以往的时候，要想到一些<strong>感想</strong>的话，常常会为了拽文润色去查阅资料看了又看。这次，是关于<u>微信公众号</u> ，这个东西在过去的两三年内，彻彻底底融入了我们的生活。开始时候也许是广而告之，现在的话众多的公众号是个无所不能自动推送服务的<code>浏览器</code>了。</p>
<blockquote>
<p>我到底想说什么？</p>
</blockquote>
<p>不要着急，题目说了诗篇辣鸡感想！我先解释下什么叫做“辣鸡感想”？</p>
<p>我说的辣鸡感想，有两层含义。一个是这种感想不多，<a href="https://www.baidu.com/link?url=rU7DR8XyHBnq8N_UMG88rYhKjGmHdPBqiJdpOu2d68fsRRVUoq8FXeFFtlNScCgG0hqQzJP4GThGzx3INDYWfSPmBp0c4hX-hPssykbt-E3&amp;wd=&amp;eqid=8cf188830001d6c7000000035859313b" target="_blank" rel="external">量</a>层面来说少得可怜甚至只是句感叹词，也许就是：F**K!；另一个含义就有意思了，是我个人的思考和见识吧。233</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1612-1701/xiaochengxu.png" alt="lll"></p>
<p>最近，微信的所谓的<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="external">程序号</a>是红红火火，懂不懂开发的搞不搞微信的反正网上是一片呼声，都觉得这是个新的*^%$&amp;+_<em>-=-。。。。反正是个</em><em>牛逼的东西</em>*。几张<code>微信教父</code>张小龙的微信朋友圈截图也被放出来，一些论坛（专业的IT编程教育类的）也是被相关话题刷屏。说话办事孰优孰劣不是我们讨论的问题，这一哄而起的现象倒是值得深思！</p>
<p>按微信自己的话说，小程序是一种<code>不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用</code>。意思就是说，未来在微信内部也许会有一个小程序但不是你过去朋友圈点开过的H5推广秀，这个程序带来的体验堪比手机app商店下载的app应用。</p>
<p>nb（一个形容词）</p>
<p>好了，跪舔结束开始说正事的内容，也就是感想。</p>
<p>我当时就想到了一句古话和开头提到的那本书。古话是：人无远虑必有近忧。微信发展（改革）自己，相信是一群人远虑的体现吧。书，我其实只是断章取义取了个名字。</p>
<blockquote>
<p>谁动了我的奶酪？？？</p>
</blockquote>
<p>恐怕自己的奶酪，别人谁动了都不好，显而易见的事情。在九月下旬二十几号小程序火热的那几天，我就看到了呼应（似乎是呼应）我感想的一些文章，不再列举但是我说下，意思就是微信（腾讯）此举会不会动了别人的奶酪？</p>
<p><u>往大了说动没动了苹果App Store的奶酪各大安卓市场的奶酪？小了说会不会影响各app的下载量卸载量的微妙变化？</u></p>
<p>我也不是没事扯淡，更不是太监操心，小程序的推出我所在乎的事情只有一个：<strong>创业者门槛的降低</strong>。现在各方面的消息看来，跨平台+降成本+更多的试错机会+技术门槛低等等因素都是让更多创业者收益的，虽然最终的话语权在于腾讯有多开放。</p>
<p>underline的那两个问题，我想除了预测没人能回答。小程序正式推出后，一切才知分晓。。。为时尚早的定论咱不说也不搬运，拭目以待以后的故事吧。</p>
<p>最新的消息大概是，12月中旬马化腾也表示了，会在春节前推出小程序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在昨晚小区院子里，和zcy喷了会。不禁想起些许往事。。。一些关于一本书的事情。&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="情感" scheme="http://zrdsj.cc/tags/%E6%83%85%E6%84%9F/"/>
    
      <category term="杂谈" scheme="http://zrdsj.cc/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="WeChat" scheme="http://zrdsj.cc/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>前端该了解的&#39;http&#39;故事</title>
    <link href="http://zrdsj.cc/2016/09/30/Fe-http/"/>
    <id>http://zrdsj.cc/2016/09/30/Fe-http/</id>
    <published>2016-09-30T15:12:12.242Z</published>
    <updated>2017-03-10T15:15:11.175Z</updated>
    
    <content type="html"><![CDATA[<p>算是聊一聊技术，顺便谈谈一个前端该知道的http故事。。。</p>
<a id="more"></a>
<p>时间已经过了很长了，都没写几个字。。。也是不好意思。。哈哈最初想到写篇这样的博客是因为物联网还不是因为自己是个前端。</p>
<p>在之前的那篇物联网博客里面，有提到物联网的核心是联网，当然了在那个时候才发觉了一些互联网的协议或者说是科学研究的协议等的存在感，比如说<code>http协议</code>。</p>
<p>这次是想说一些一个前端该懂得的http知识，该说多少我也拿捏不好。一度我是这样想的—&gt;找几个知乎链接+博客地址，贴出来over2333</p>
<p>哈哈哈，好吧。。。还是自己写几句吧。</p>
<h3 id="前奏">前奏</h3>
<p>先说说<em>为什么</em>这次会说<code>前端的http故</code>事，直接说http不行么？为什么现在说http？</p>
<p>OK，是这样的。</p>
<blockquote>
<p>如今我自己在实习并且在学习新的技术（想对自己而言2333），不管以后的话是做什么，现在的学习情况表明了就是前端之路。未来前端的趋势我说不太好，但我知道。。。<code>无论web技术再如何发展，理解web程序间通信的基本协议很重要，理解web应用程序的内部工作就必然会有http的事情。</code>关于http前端之外的更多事情，也许以后我会以<code>计算机网络</code>的视角再写一篇http？2333</p>
</blockquote>
<blockquote>
<p>现在说http是因为：在了解了一个web世界的多个角落之后，在某一天总会有些原因驱动着你去做些不同往日的事情，比如联通彼此产生信息的交流。。。so,it’s the Time.</p>
</blockquote>
<p>说完了前奏，接下来就是主要的内容了。讲道理，<code>http基础内容</code>完全可以在百科上、在某个硬盘上的文档里、在某篇博客里、在互联网上的不明奇妙的角落里学习到······我所总结的点并不全面，只是常用到的几个点。😉</p>
<p><strong>顺应博客的标题，仅仅说下前端应该知道的掌握的基本原理，更深层次不再进行探讨。</strong></p>
<p>赛高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这篇博文中的诸如是http或者https或者是HTTP等大小写拼写问题，请理解精神！</div></pre></td></tr></table></figure>
<p>3个部分：</p>
<ol>
<li>初级
<ul>
<li>请求/响应</li>
<li>状态码</li>
<li>post请求发送</li>
</ul>
</li>
<li>中级
<ul>
<li>how?</li>
<li>Session</li>
<li>Ajax与同源策略</li>
</ul>
</li>
</ol>
<ol start="3">
<li>高级
<ul>
<li>https</li>
<li>Web Sockets</li>
<li>http2</li>
</ul>
</li>
</ol>
<h3 id="1111111">1111111</h3>
<h4 id="请求响应">请求/响应</h4>
<h5 id="http是啥">http是啥</h5>
<p>HTTP ，是<strong>超文本传输协议</strong> （Hypertext Transfer Protocol ）的缩写。</p>
<p>网上都有大量的图片，视频，HTML 页面等等这些东西飞来飞去，从服务器上送到我们的浏览器里，这个过程都是实用 HTTP 协议来传输数据的。所以理解 HTTP ，不管是对于做网站，还是做 Web App ，都是开发者非常重要的基本功。</p>
<p>Web 客户端和服务器端</p>
<p>Web 内容都是存储在 Web 服务器上的，Web 服务器都是使用 HTTP 协议的，因此也被称为 HTTP 服务器。HTTP 服务器存储了各种类型的数据，如果 HTTP 的客户端（浏览器）发出<strong>请求</strong>的话，服务器就会返回数据给客户端，叫做<strong>响应</strong>。<strong>请求（ request )和响应（ response ）都是重要的术语。</strong></p>
<p>HTTP 的服务器和客户端是<a href="https://zh.wikipedia.org/zh-cn/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="external">万维网</a>（ World Wide Web ）的基本单元。其实我们每天都在使用 HTTP 的客户端，最常见的客户端就是浏览器。浏览一个页面的时候，浏览器会向服务器发出一个 HTTP 请求。等到服务器响应返回之后，浏览器再去处理响应数据，以美观的形式展示给用户。</p>
<h5 id="请求响应">请求/响应</h5>
<p>HTTP 的开始是浏览器发出请求。但是请求的是什么呢？<strong>是服务器上的资源，英文叫 Resource 。</strong></p>
<p>对应的每一个资源，都有一个 URL ，也就是<strong>统一资源定位地址</strong>，指向这个资源。不过资源分两种：一种是静态 资源，也就是各种文件了，最常见的就是静态 HTML ，但是也可以是 PDF ，json，MP4 文件等等。另外一种，就是动态 资源，也就是 URL 指向的地方不是一个文件，而是一段代码的入口，服务器经过运算后，才返回运算结果给客户端。</p>
<p>所以， 我们有 <a href="http://xxxxx.com/23333.txt" target="_blank" rel="external">http://xxxxx.com/2333.txt</a> (雷同纯属巧合)，这个 URL 就是指向一个静态资源的。如果是 <a href="http://xxxxx.com/username" target="_blank" rel="external">http://xxxxx.com/username</a> 这个可能就是指向动态资源的，后台对应的可能就是一个 API 。</p>
<p>发起一个 HTTP 请求很容易。比如你说你想用浏览器访问 <a href="http://zrdsj.cc">zrdsj.cc</a> 。你所需要做的仅仅是启动浏览器然后在地址栏输入 <a href="http://zrdsj.cc/">http://zrdsj.cc/</a> ，然后你就可以在页面中看到本站的首页了。</p>
<p>那么底层发生了什么呢？首先，浏览器作为 <strong>HTTP Client</strong> ，发出了一个<strong>请求</strong>给服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET http://zdsj.cc/</div></pre></td></tr></table></figure>
<p>上面的 GET 是 HTTP 方法，这个后面还会介绍。</p>
<p><a href="http://zrdsj.cc">zrdsj.cc</a> 的服务器收到请求后，给出<strong>响应</strong>。响应中带有各种数据，html/css/图片 等等，返回到浏览器。 浏览器是理解这些文件格式的，所以可以最终展示一个美观的网页给用户。</p>
<p>用一些工具，可以清楚看出这些变化。有浏览器的插件，也有专门的软件，还有命令行工具。这里我们简便起见，达到目的即可，使用Chrome的开发者工具就可以。</p>
<p>我们访问这个网站 <a href="https://office.qq.com/" target="_blank" rel="external">https://office.qq.com/</a> 作为举例。</p>
<p>在控制器中我们看到了下列的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Request URL:https://office.qq.com/</div><div class="line">Request Method:GET</div><div class="line">Status Code:200 </div><div class="line">Remote Address:127.0.0.1:8888</div></pre></td></tr></table></figure>
<p>这都是极为重要的信息，先不做陈述。我们看下<code>请求部分</code>和<code>响应部分</code>的截图。</p>
<p>请求部分的截图：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/http_Get.png" alt="请求信息"></p>
<p>下面是响应信息：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/http_Get-resp.png" alt="响应信息"></p>
<ol>
<li>
<p>我们这次的请求实际上，是一个<u>GET</u><strong>请求</strong>，就是想要从服务器上 GET （拿到）一些内容，而不是想去修改服务器数据。到底要 GET 哪些资源，就是后面的 URL 这一项来指定了。也可以说我们的<strong>HTTP 方法</strong>（ <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="external">HTTP Method</a> ）是 GET 方法，当然还有其他种类的方法。</p>
<p>我们可见看出在Request Headers（请求头）中，有许多项，可以参考的列表在<a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8#.E5.B8.B8.E8.A7.81.E7.9A.84.E9.9D.9E.E6.A0.87.E5.87.86.E8.AF.B7.E6.B1.82.E5.AD.97.E6.AE.B5" target="_blank" rel="external">这里</a>。</p>
</li>
<li>
<p>响应也有对应的信息，<strong>响应头部</strong>、<strong>状态行</strong>、<strong>响应主体</strong>（response body/payload）等。基本的格式在上面的截图也有了：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ header 名]: [ header 值]</div></pre></td></tr></table></figure>
<p>​	在一些专门的工具中（除Chrome控制台之外），一般可以直接显示出<strong>状态行</strong> （ status line ）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP[版本号] [状态码] [状态信息]</div><div class="line"></div><div class="line">比如</div><div class="line">HTTP/1.1 200 ok</div></pre></td></tr></table></figure>
<p>​	其中含有的数据有一项为状态码，在稍后我们会讲道。</p>
<p>​	<strong>响应主体</strong>很好理解了，就是代码文件了，在浏览器会显示成相应的页面。</p>
<h5 id="无状态协议">无状态协议</h5>
<p>前面 HTTP 的基本格式介绍完了，再补充一个小点：</p>
<blockquote>
<p>HTTP 是一个无状态的协议</p>
</blockquote>
<p>所谓**无状态（ stateless ）**意思就是：对于之前的交互没有记录。每次交互能用的信息就只有这次交互所携带的信息。</p>
<p>换句话说，HTTP 协议是没有办法记住之前的一次请求的，所以也没有办法根据前一次请求来辅助后一次请求。当一个 Web 应用 看起来似乎可以记住之前的交互，例如，可以记住你的用户名，其实它采用的技巧已经超出了 HTTP 本身。HTTP 的信息就好像 是可以自销毁的，每次读取完毕，立刻就消失了。总之，HTTP 就是无状态的，也就是不能记录或者维持某种状态的。</p>
<h4 id="状态码">状态码</h4>
<p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#3xx.E9.87.8D.E5.AE.9A.E5.90.91" target="_blank" rel="external">维基百科</a>的内容，<a href="http://www.w3school.com.cn/tags/html_ref_httpmessages.asp" target="_blank" rel="external">w3</a>的内容。</p>
<p>简单介绍：</p>
<ul>
<li>20x 的状态码都代表某种成功状态。最常见的 200 ，它的意义，就正如它后面跟的 状态信息 一样，代表一切 OK 。</li>
<li>30x 的状态码，意味着资源已经被移动到其他地方了，但是响应中给出了应该跳转到哪里去找到这个资源。这个行为的 术语就叫做 <strong>redirect</strong> （重定向）。</li>
<li>40x 的代码也都是代表一种<strong>客户端请求错误</strong> 。一个最常见的状态码 404 ，它的意 义也跟它后面紧跟的状态信息所说的 一样：Page Not Found （页面未找到）。</li>
<li>50x 的状态吗也很常见。返回的如果是这一系列的状态码，就意味着 服务器端在处理请求的时候出错 。50x 出现，对于开发者，一般意味着服务器端代码出了错误。</li>
</ul>
<h4 id="post请求发送">post请求发送</h4>
<p>GET 请求是只读的，意思就是只能用来从服务器上获取信息。而相对的 POST 请求<code>就是用来修改服务器的，例如修改数据库记录，上传一个文件等等。</code></p>
<p>GET 请求中，我们一般通过对 url 添加参数的形式传递额外的参数给服务器端，但是 POST 请求的情况下，通常我们都会把要传递的数据放到 request body （请求体）中。</p>
<p>使用 POST 请求通过 request body 携带数据到服务器端，有四种方式:</p>
<ul>
<li>普通 html 表单 form 提交方式：application/x-www-form-urlencoded</li>
<li>上传文件惯用方式：multipart/form-data</li>
<li>通过 fetch/axios 等客户端提交 JSON 数据：application/json</li>
<li>还有一种方式是 text/xml ，不常用了</li>
</ul>
<p>前三种是比较重要的。</p>
<h5 id="applicationx-www-form-urlencoded">application/x-www-form-urlencoded</h5>
<p>这是最常见的 POST 提交数据的方式了。浏览器的原生 <code>&lt;form&gt;</code> 表单，如果不设置 <code>enctype</code> 属性，那么最终就会以 <strong>application/x-www-form-urlencoded</strong> 方式提交数据。</p>
<p>请求类似于下面这样（无关的请求头在本文中都省略掉了）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BASHPOST http://www.example.com HTTP/1.1</div><div class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</div><div class="line"></div><div class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</div></pre></td></tr></table></figure>
<ul>
<li>首先，Content-Type 被指定为 application/x-www-form-urlencoded；</li>
<li>其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</li>
</ul>
<p>很多时候，用 Ajax 提交数据时，也是使用这种方式。例如 <a href="http://jquery.com/" target="_blank" rel="external">JQuery</a> 和 <a href="http://www.qwrap.com/" target="_blank" rel="external">QWrap</a> 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。</p>
<h5 id="multipartform-data">multipart/form-data</h5>
<p>又一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <code>&lt;form&gt;</code>表单的 <code>enctype</code> 等于 <code>multipart/form-data</code>。</p>
<p>一个请求示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">BASHPOST http://www.example.com HTTP/1.1</div><div class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</div><div class="line"></div><div class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</div><div class="line">Content-Disposition: form-data; name=&quot;text&quot;</div><div class="line"></div><div class="line">title</div><div class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</div><div class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</div><div class="line">Content-Type: image/png</div><div class="line"></div><div class="line">PNG ... content of chrome.png ...</div><div class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</div></pre></td></tr></table></figure>
<p>这个例子稍微复杂点。</p>
<ul>
<li>首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。</li>
<li>然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，以及请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 <code>--boundary</code> （------WebKitFormBoundaryrGKCBY7qhFd3Trw）开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。</li>
<li>如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 <code>--boundary--</code> 标示结束。关于 multipart/form-data 的详细定义，请前往 <a href="http://www.ietf.org/rfc/rfc1867.txt" target="_blank" rel="external">rfc1867</a> 查看。</li>
</ul>
<p>这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p>
<p>上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <form> 表单也<a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4" target="_blank" rel="external">只支持这两种方式</a>（通过 <code>&lt;form&gt;</code> 元素的 <code>enctype</code> 属性指定，默认为 application/x-www-form-urlencoded。其实 <code>enctype</code> 还支持 <code>text/plain</code>，不过用得非常少）。</form></p>
<p>随着越来越多的 Web 站点（尤其是 WebApp），全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。</p>
<h5 id="applicationjson">application/json</h5>
<p>application/json 这个 Content-Type 作为响应头并不新鲜，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。</p>
<p>由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p>
<p>JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。</p>
<p>Google 的 <a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JSvar data = &#123;&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]&#125;;</div><div class="line">$http.post(url, data).success(function(result) &#123;</div><div class="line">    ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最终发送的请求是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BASHPOST http://www.example.com HTTP/1.1 </div><div class="line">Content-Type: application/json;charset=utf-8</div><div class="line"></div><div class="line">&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</div></pre></td></tr></table></figure>
<p>这种方案，可以方便的提交复杂的结构化数据，特别适合 <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful 的接口</a>。</p>
<p>各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。一些服务端语言还没有支持这种方式，但一些相应的框架已经开始做出改变了。</p>
<h5 id="textxml">text/xml</h5>
<p><a href="https://imququ.com/post/pingback-and-xmlrpc.html" target="_blank" rel="external">XML-RPC</a>，它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTMLPOST http://www.example.com HTTP/1.1 </div><div class="line">Content-Type: text/xml</div><div class="line"></div><div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;methodCall&gt;</div><div class="line">  &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</div><div class="line">  &lt;params&gt;</div><div class="line">    &lt;param&gt;</div><div class="line">      &lt;value&gt;&lt;i4&gt;233&lt;/i4&gt;&lt;/value&gt;</div><div class="line">    &lt;/param&gt;</div><div class="line">  &lt;/params&gt;</div><div class="line">&lt;/methodCall&gt;</div></pre></td></tr></table></figure>
<p>XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 <a href="http://codex.wordpress.org/XML-RPC_WordPress_API" target="_blank" rel="external">XML-RPC Api</a>，搜索引擎的 <a href="http://help.baidu.com/question?prod_en=master&amp;class=476&amp;id=1000423" target="_blank" rel="external">ping 服务</a>等等。JavaScript 中，也有<a href="http://plugins.jquery.com/xmlrpc/" target="_blank" rel="external">现成的库</a>支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。可能一些人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。</p>
<h3 id="2222222">2222222</h3>
<h4 id="how">how?</h4>
<p>我这里想表达的是一个技术是如何实现的？</p>
<p><a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="external">Cookie</a></p>
<p>前面我们已经说了：HTTP 的一个特点就是它是<strong>无状态</strong>协议（easy come, easy go）。</p>
<p>但是有时候为了实现类似电商网站购物车这样的应用，必须要求网络应用保持一种状态，所以 cookie 就被发明出来了。</p>
<h5 id="general">general</h5>
<p>通常来讲：：：：</p>
<p>比如我们现在访问 <a href="https://atom.io/" target="_blank" rel="external">atom.io</a> ，在 Chrome Devtools 的 Network 标签下可以看到，仅仅是打开首页， 就发出了很多个请求。其实具体的过程是这样，浏览器首先发出的是一个请求，也就是请求 <a href="http://atom.io" target="_blank" rel="external">atom.io</a> 的首页， 但是问题的是首页的 html 中有指向图片，css ，js 的一些链接，这样，浏览器就会自动发出后续的请求，以保证 最终页面是显示完整的。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/atomio.png" alt="atom"></p>
<p>上面所说的这些请求，都是 stateless 无状态的，也就是服务器收到后续请求后，根本不记得之前也收到过相关的请求。 也就是服务器根本不记得我的浏览器。 无状态就是<strong>随时忘记</strong>，也就是服务器没有办法去始终跟踪同一个浏览器。但是这样 比如说我们想用浏览器添加多个商品进购物车，那么服务器是没有办法记录，后添加的商品是不是跟前面添加的商品是同一个 浏览器请求的。</p>
<h5 id="then">then</h5>
<p>后来：：：：</p>
<p>也就真是为了解决购物车的这种需求，为了达成浏览器跟服务器之间的一种<strong>持续连接状态</strong>，让服务器知道到底用户是谁， 在1993年的时候，网景公司发明了 cookie 这个技术。</p>
<p>Cookie 就是平时所说的曲奇饼干，浏览器的 Cookie 可以翻译成<strong>浏览器的一个小文件</strong>。文件中的信息，会被设置成 http 请求 的一个 header ，header 的名字就叫 <strong>Cookie</strong> ，让浏览器对这个 header 做特殊对待，每次发出请求的时候都会携带着 cookie 信息给服务器。</p>
<p><em>那么浏览器的 cookie 小文件的信息是从哪里来的呢？</em></p>
<blockquote>
<p>Cookie 一般都是在服务器端设置的，通过 http 响应的头部返回给浏览器，浏览器拿到这些信息就可以保存到自己的 cookie 文件中</p>
</blockquote>
<p><em>cookie的作用？</em></p>
<blockquote>
<p>一旦客户端有了服务器发来的特殊信息，例如 <code>id=xxx</code> ，那么就等于服务器已经认定这个客户端了。客户端每次发请求都带着这些信息， 就可以到服务器上认领属于本浏览器的各种资源了。这样客户端和服务器端就建立起了一种连接状态，HTTP 的<strong>无状态</strong>的问题就被解决了。</p>
</blockquote>
<h4 id="session">Session</h4>
<p>先来普及下概念。</p>
<blockquote>
<p>什么是Session？—是会话！</p>
</blockquote>
<p><strong>会话</strong>这个词也本身意思就比较宽泛，容易被外行泛用。维基百科是<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="external">这么说的</a>。通俗点讲，从效果切入应该更合适。那么：</p>
<blockquote>
<p>会话开始和结束，就意味着服务器从认识一个浏览器到不再认识这个浏览器（url效用失效）。</p>
</blockquote>
<h5 id="实现会话的技术机制">实现会话的技术机制</h5>
<p>方法不唯一，最常见的一个方式是这样：</p>
<ul>
<li>第一步，准备建立会话的时候，服务器会在自己的内存里创建一个新的变量，例如这个变量叫做 session-3333 ，</li>
<li>第二步，服务器把这个会话的 id 也就是 3333 发送到我的浏览器，浏览器会把这个 id 保存到 cookie 中</li>
<li>之后，每次我的浏览器再去访问服务器的时候，都会携带 cookie 中存放的 3333 这个会话 id 值，这样服务器就认识 这个浏览器了</li>
<li>服务器端的 session-3333 变量中可以存放任意的会话数据，例如：我的用户名，我购物车里有哪几件商品等等</li>
<li>每次浏览器访问服务器，都可以凭借自己的会话 id 去服务器的 session-3333 变量中去认领属于我的信息</li>
</ul>
<p>每一个请求都会包含这个会话 id ，这样服务器就能唯一确认你这个客户端浏览器。 这样，直到会话过期，客户端和服务器都是互相认识的，都保持有效的链接。</p>
<h5 id="会话的意义">会话的意义</h5>
<p>说的抽象点：<strong>会话可以让无状态的 HTTP 协议保持特定的状态</strong>。</p>
<p>这种在客户端与服务器之间传递<strong>会话 id</strong>的机制，能让服务器创建一种各次请求之间的持续连接状态。Web 开发人员利用这种人造的状态，来构建一些”有状态“的应用场景：例如用户处于一直登陆的状态，购物车里面之前添加的商品，后续访问中还有等等。</p>
<p>不过即使这样，每一个 HTTP 请求本质上来说还是无状态的，各次请求之间并不知道彼此的存在。</p>
<h5 id="会话数据存在哪里">会话数据存在哪里？</h5>
<p>一句话来讲：是服务器上的某个地方。</p>
<p>之前所讲的cookie是在内存里，但其实有时候，可能会存在某个持久化存储介质上，比如数据库或者键 / 值存储。会话数据存在哪里不是我们需要关心的。现在重要的是要理解会话 id 存储在客户端，它是访问存储在服务器上的会话数据的 “钥匙”。</p>
<h5 id="会话过期">会话过期</h5>
<p>服务器上有多少个浏览器在访问，就会在自己内存中创建多少了类似 session-3333 这样的变量。但是，还有一点非常重要，在一个会话里发出的会话 id 是唯一的，而且有一个很短的过期时间。那什么情况下会话就会过期呢？</p>
<ul>
<li>手动删掉 cookie 中的会话 id （在 chrome devtools 里，右键 cookies 然后删除它）</li>
<li>点一个网站的退出登录按钮</li>
<li>关闭网站有时候也通常能结束会话</li>
</ul>
<p>当然，讨论到这里，会话过期的本质我们其实是知道的：<strong>用客户端 cookie 中的 id 找到服务器端对应的 session 了。</strong></p>
<h5 id="会话劫持">会话劫持</h5>
<p>会话 id 作为一个唯一的令牌来唯一标识一个会话。通常，会话 id 是作为 cookie 存储在计算机上的一个随机字符串.。很多 Web 应用的用户认证系统所在做的事情，当用户的用户名和密码匹配之后，会话 id 会存储在用户的浏览器里，这样我的下一个请求就不用重新认证了。</p>
<p>不幸的是，如果一个攻击者拿到了我的这个会话 id ，他就会跟我共享这一个会话，那服务器就会把他当成我，我的所有权限， 他都不需要知道我的用户名密码，都可以获得了。</p>
<p>防止会话劫持是安全问题，总之就是用各种方法让当前会话 id 作废，然后重新创建新会话。</p>
<h4 id="ajax与同源策略">Ajax与同源策略</h4>
<h5 id="ajax">Ajax</h5>
<p>AJAX 是 ”异步 javascript 和 XML “ 的简称（ Asynchronous JavaScript and XML ）。它的主要特点就是允许浏览器发送请求和处理响应的时候</p>
<blockquote>
<p>不用刷新整个页面</p>
</blockquote>
<p>举个例子，如果你访问一个网站，服务器会给你一个响应生成你看到的主页。正常情况下，每当用户点一个连接，或者提交一个表单，页面都会整个去刷新，这样有两个明显的弊端：</p>
<ul>
<li>用户体验不好，因为页面会闪烁</li>
<li>新页面很多时候跟老页面相似度很高，整个页面刷新其实很多工作量是没必要的（浪费网络资源）</li>
</ul>
<p>当使用 Ajax的时候，页面就不会刷新。</p>
<p>Why？</p>
<blockquote>
<p>Ajax 请求本质上也就是一个普通的请求，服务器也会给出响应。跟普通的请求的区别也就是页面不会刷新了。</p>
</blockquote>
<p>但是页面要是不刷新，那么响应数据如何加载呢？</p>
<blockquote>
<p>这些请求的响应会通过一些<strong>回调函数</strong>来处理。就是把一些逻辑存放在mou个函数里，当某个条件被触发之后再回来执行你前面存放的逻辑。当响应返回的时候，<strong>回调函数</strong>就会被触发。<strong>回调函数</strong>里面写一些可以用来更新页面的 JS 语法，配合上刚刚返回的服务器端的数据，就可以实现替换页面局部的效果了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">当代 Web 应用，无刷新几乎已经成为标配。尤其是单页面概念盛行之后，这个趋势就更明显了。另外，传递数据的格式原来用 XML ，现在大家也都用 JSON 了。</div><div class="line"></div><div class="line">AJAX 请求就像是普通请求，发送到服务器的请求依然跟普通请求一样有着一个 HTTP 请求该有的所有组成部分，并且服务器处理 AJAX 请求的方法跟处理普通请求也是一样的。</div><div class="line"></div><div class="line">唯一不同就是，不是通过浏览器刷新来处理响应，而通常由客户端的一些 javascript 代码来处理。</div></pre></td></tr></table></figure>
<h5 id="同源策略">同源策略</h5>
<p>同源策略（ Same-origin policy ）是一个重要的概念，它<strong>允许来自同一站点的资源进行互相访问而不受限制，但是会阻止其他不同站点对文档/资源的访问。</strong></p>
<p>同源策略涉及的是访问文件内容，而不是链接，你可以随意链接到任何 URL。 同源策略是防范会话劫持的重要手段，是 web 应用安全的基石。</p>
<p>参考：<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">1111</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">2222</a></p>
<h3 id="3333333">3333333</h3>
<h4 id="https">https</h4>
<p><a href="https://zh.wikipedia.org/zh-cn/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">超文本传输安全协议</a></p>
<p>通过 HTTPS 访问资源的时候，通常以 <code>https://</code> 开头而不是 <code>http://</code> ，而且通常在边上都会有个小锁子的图标。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/douban.png" alt="douban"></p>
<h5 id="干嘛要用">干嘛要用？</h5>
<p>HTTP 是明文传输的，所以如果有人在网上截获了你的数据流，那么用户的密码等各种信息就会暴露。这样你就知道为啥大家都拼命上 HTTPS 了吧。。。</p>
<p>如果有用户登上你的网站买东西，需要输入信用卡的一些信息，然后他看到你的网站没有用 HTTPS ，也就是说是不安全的，那他就很有可能放弃这次购买。</p>
<p>HTTP 请求可以包含会话 id ，它唯一地标识你的浏览器和服务器之间的联系，所以如果别人复制了这个会话 id ，他们可以手动创建到服务器的请求，进行伪装，甚至都不需要你的用户名和密码就可以自动登陆。</p>
<p>这种情况就需要安全的 HTTP 也就是 HTTPS 来帮忙。通过 HTTPS 发送的请求和响应在发送前都会被加密。这意味着如果一个恶意的黑客监听 HTTPS 通信，他得到的信息都是加密的，就是截获了也难看懂。</p>
<h5 id="how">how?</h5>
<p>HTTPS 通过 <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">TLS</a> 的加密协议来加密消息。在 TLS 开发完成前，早期 HTTPS 使用 <code>SSL</code> （ Secure Sockets Layer ）。这些加密协议在加密数据之前，需要先使用证书来与远程服务器进行通信来交换安全密钥。</p>
<p>你的浏览器有了服务器颁发的证书，这样就可以按照一种跟服务器约定好的方式把要传输的信息进行加密，然后传输给服务器。 这样有了约定好的加密方式，安全的信息通道也就建立起来了。</p>
<h4 id="web-sockets">Web Sockets</h4>
<p>Web Sockets 是 HTML5 的新增功能之一。换句话说，Web Sockets 是浏览器提供给我们的一种通讯机制。</p>
<p>Web Sockets 技术到底算不算 HTTP 协议的一部分？</p>
<blockquote>
<p>不算！可以认为他们就是两套协议。但是毕竟二者紧密相关，所以聊 HTTP 就不能不聊 Web Sockets 。可以把 Web Socket 看成浏览器为了弥补 HTTP 协议的不足而打的一个大补丁。</p>
</blockquote>
<h5 id="web-sockets-要解决">Web Sockets 要解决？</h5>
<p>相对于 HTTP 这种非持久的协议，Web Sockets 是一个持久化的协议。</p>
<p>HTTP 协议特点就是简单直接：<code>客户端发请求，服务器给一个响应，然后就各找各妈，谁也不认识谁了。</code>这种关系不但健忘，而且是单向的，客户端必须主动发请求，服务器端不能给客户端主动推送信息的。</p>
<p>如果只是基于基本的 HTTP 协议，来做个网络聊天室是很难的。比如，我跟你在聊天，你那边发了新信息，我的浏览器怎么能知道呢？服务器不能给我主动推送信息的弊端就暴露出来了！</p>
<p>Web Socket 出现之前，往往是通过一些瘸腿的技术例如 <a href="http://www.cnblogs.com/hoojo/p/longPolling_comet_jquery_iframe_ajax.html" target="_blank" rel="external"><strong>long poll</strong></a> 和 <strong><a href="https://segmentfault.com/a/1190000005032921" target="_blank" rel="external">ajax 轮询</a></strong> 来实现，每次查询都是开启一次连接，然后再断开，耗费资源，效果差。</p>
<h5 id="web-sockets-带来的是两个改进">Web Sockets 带来的是两个改进：</h5>
<ul>
<li>客户端只要先发起一次 HTTP 请求，那么客户端和服务器这对朋友就算交上了，也就是建立了持久连接。</li>
<li>以前都只能是客户端主动问，服务器端只有回答的份儿，现在不是了，服务器如果想主动说话，客户端也听在监听着。</li>
</ul>
<h5 id="实际方案">实际方案</h5>
<p>Web Sockets 的确很棒，但是毕竟是新特性，总有些幺蛾子出现。</p>
<p>所以实际项目中可以通过 <a href="http://socket.io" target="_blank" rel="external">socket.io</a> 来更好的使用 Web Socket 技术。<a href="http://haoduoshipin.com/v/99.html" target="_blank" rel="external">http://haoduoshipin.com/v/99.html</a> 用 <a href="http://socket.io" target="_blank" rel="external">socket.io</a> 搭建一个项目，演示了效果。</p>
<h4 id="http2">http2</h4>
<p>维基百科<a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="external">这样说</a>。</p>
<p>通俗上讲，1999年的http1.1版本后的首个更新在2015年5月开启了正式版的发布—http2。在保留与http1.1的完全语义兼容情况下，http2的目标包括异步连接复用，头压缩和请求反馈管线化。</p>
<p>基本上，这篇 <a href="https://imququ.com/post/http2-resource.html" target="_blank" rel="external">https://imququ.com/post/http2-resource.html</a> 包含了详细的http2内容，入门进阶都可以在其中找到路线。</p>
<h3 id="bye">bye</h3>
<p>其实内容上讲，这篇博客算是入了门，入了http世界的大门。要学的还有很多。</p>
<p>推荐网络课程 <a href="https://haoqicat.com/http-with-peter" target="_blank" rel="external">https://haoqicat.com/http-with-peter</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算是聊一聊技术，顺便谈谈一个前端该知道的http故事。。。&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="http" scheme="http://zrdsj.cc/tags/http/"/>
    
      <category term="前端" scheme="http://zrdsj.cc/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="https" scheme="http://zrdsj.cc/tags/https/"/>
    
      <category term="Ajax" scheme="http://zrdsj.cc/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>JS-面向对象编程sth</title>
    <link href="http://zrdsj.cc/2016/09/27/Js-Object-oriented/"/>
    <id>http://zrdsj.cc/2016/09/27/Js-Object-oriented/</id>
    <published>2016-09-27T10:58:31.215Z</published>
    <updated>2017-03-10T15:17:19.150Z</updated>
    
    <content type="html"><![CDATA[<p>这次实实在在做了一次搬运工，内容是从大神阮一峰的网站上搬来的。手打成博客，希望可以增加一些自己的理解，😄.</p>
<a id="more"></a>
<h3 id="关于阮一峰">关于阮一峰</h3>
<p>一般来讲，在这个领域里不知道阮老师的，不应该很多。老师在编程学习上的造诣贡献很高，在我看来是很有价值的，对我帮助也很大。</p>
<p>2014的双11，在天猫买了《<a href="https://book.douban.com/subject/6021440/" target="_blank" rel="external">黑客与画家</a>》，其译者就是阮老师。从那个时候开始，我知道了这个领域的大神中，是有个阮老师的2333。</p>
<p>老师的个人网站是这个：<a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="external">http://www.ruanyifeng.com/home.html</a></p>
<p>从这里你可以很容易了解到许许多多有趣的知识。</p>
<h3 id="js面向对象-封装">js面向对象-封装</h3>
<p>面向对象的编程语言，第一反应我想到了Java，然后是C++，两者都是真正的<a href="http://baike.baidu.com/link?url=47orC6D5BkCpRxfI5hwgXRwd9qDoEpWGDyZPiyCDVUHepRenjasljzat3gNprFVT-N0OxcxonhpTUlYT_BeY3q" target="_blank" rel="external">OOP</a>编程语言。</p>
<p>js中并没有class（类），所以即使其中所有的东西都是对象，所以也不是真正的OOP。</p>
<h4 id="生成实例对象的原始模式">生成实例对象的原始模式</h4>
<p>我们将创建一个对象：猫。它有两个属性：“颜色”，“名字”。（<code>一瞬间我的思绪回到了一年半前学java是朱老师的ppt例子</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var Cat = &#123;</div><div class="line">　　name : &apos;&apos;,</div><div class="line">　　color : &apos;&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据这个原型的规格（schema），生成两个实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var cat1 = &#123;&#125;;  //创建一个空对象</div><div class="line">　cat1.name = &quot;大毛&quot;;  //按照原型对象的属性赋值</div><div class="line">　cat1.color = &quot;黄色&quot;;</div><div class="line">var cat2 = &#123;&#125;;</div><div class="line">　cat2.name = &quot;二毛&quot;;</div><div class="line">　cat2.color = &quot;黑色&quot;;</div></pre></td></tr></table></figure>
<p>最简单的封装了，把两个属性封装在一个对象里面。</p>
<p>但是，这样的写法有两个缺点</p>
<ul>
<li>一是如果多生成几个实例，写起来就非常麻烦</li>
<li>二是实例与原型之间，没有任何办法可以看出有什么联系</li>
</ul>
<h4 id="原始模式的改进">原始模式的改进</h4>
<p>写个函数改进一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color) &#123;</div><div class="line">  return &#123;</div><div class="line">　ame:name,</div><div class="line">　color:color</div><div class="line">　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后生成实例对象，其实就是调用函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var cat1 = Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div></pre></td></tr></table></figure>
<p>好了一些？</p>
<p>这种方法的问题存在，<code>cat1</code>和<code>cat2</code>之间没有内在的联系，不能反映出它们是同一个原型对象的实例。。。</p>
<h4 id="构造函数模式">构造函数模式</h4>
<p>接下来我们继续努力搞已存在的问题。。。</p>
<p>为了解决从原型对象生成实例的问题，JavaScript提供了一个构造函数（Constructor）模式。</p>
<p>所谓&quot;构造函数&quot;，其实就是一个普通函数，但是内部使用了<code>this</code>变量。对构造函数使用new运算符，就能生成实例，并且<code>this</code>变量会绑定在实例对象上。</p>
<p>下面我们再写下猫的原型对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">　this.name=name;</div><div class="line">　this.color=color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在就可以生成实例对象了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">alert(cat1.name); // 大毛</div><div class="line">alert(cat1.color); // 黄色</div></pre></td></tr></table></figure>
<p>这时<code>cat1</code>和<code>cat2</code>会自动含有一个<code>constructor</code>属性，指向它们的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1.constructor == Cat); //true</div><div class="line">alert(cat2.constructor == Cat); //true</div></pre></td></tr></table></figure>
<p>JavaScript还提供了一个<code>instanceof</code>运算符，验证原型对象与实例对象之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1 instanceof Cat); //true</div><div class="line">alert(cat2 instanceof Cat); //true</div></pre></td></tr></table></figure>
<h4 id="构造函数模式的问题">构造函数模式的问题</h4>
<p>构造函数方法好用，但是会存在浪费内存的问题。</p>
<p>如下。我们现在为<code>Cat</code>对象添加一个不变的属性<code>type</code>（种类），再添加一个方法<code>eat</code>（吃）。那么，原型对象<code>Cat</code>就变成了下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color) &#123;</div><div class="line">　this.name = name;</div><div class="line">　this.color = color;</div><div class="line">　this.type = &quot;猫科动物&quot;;</div><div class="line">　this.eat = function() &#123;</div><div class="line">　  alert(&quot;吃老鼠&quot;);</div><div class="line">　&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的方法生成实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = new Cat (&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">alert(cat1.type); // 猫科动物</div><div class="line">cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>
<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。</p>
<p>那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。</p>
<p>既不环保，也缺乏效率。</p>
<pre><code>alert(cat1.eat == cat2.eat); //false
</code></pre>
<p>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？</p>
<p>回答是可以的</p>
<h4 id="prototype模式">Prototype模式</h4>
<p>JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">　this.name = name;</div><div class="line">　this.color = color;</div><div class="line">&#125;</div><div class="line">Cat.prototype.type = &quot;猫科动物&quot;;</div><div class="line">Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</div></pre></td></tr></table></figure>
<p>生成实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">alert(cat1.type);  // 猫科动物</div><div class="line">cat1.eat();  // 吃老鼠</div></pre></td></tr></table></figure>
<p>这时所有实例的<code>type</code>属性和<code>eat()</code>方法，其实都是同一个内存地址，指向<code>prototype</code>对象，因此就提高了运行效率。</p>
<h4 id="prototype模式的验证方式">Prototype模式的验证方式</h4>
<p>为了配合<code>prototype</code>属性，js定义了一些辅助方法，助我们使用它。。。</p>
<ol>
<li><strong>isPrototypeOf()</strong></li>
</ol>
<p>这个方法用来判断，某个<code>prototype</code>对象和某个实例之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Cat.prototype.isPrototypeOf(cat1)); //true</div><div class="line">alert(Cat.prototype.isPrototypeOf(cat2)); //true</div></pre></td></tr></table></figure>
<ol start="2">
<li><strong>hasOwnProperty()</strong></li>
</ol>
<p>每个实例对象都有一个<code>hasOwnProperty()</code>方法，用来判断某一个属性到底是本地属性，还是继承自<code>prototype</code>对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</div><div class="line">alert(cat1.hasOwnProperty(&quot;type&quot;)); // true</div></pre></td></tr></table></figure>
<ol start="3">
<li><strong>in</strong></li>
</ol>
<p><code>in</code>运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(&quot;name&quot; in cat1); // true</div><div class="line">alert(&quot;type&quot; in cat1); // true</div></pre></td></tr></table></figure>
<p><code>in</code>运算符还可以用来遍历某个对象的所有属性。</p>
<pre><code>for(var prop in cat1) { alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }
</code></pre>
<h3 id="构造函数的继承">构造函数的继承</h3>
<p>继承间的几种方法。</p>
<p>现在，我们又有了一个“动物”对象的构造函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fuction Animal()&#123;</div><div class="line">  this.species = &quot;动物&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有个“猫”对象的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来思考个问题：<code>如何让猫继承动物</code>呢？</p>
<h4 id="构造函数绑定">构造函数绑定</h4>
<p>应该是最简单的办法。。。使用call或apply方法，<code>将父对象的构造方法绑定在子对象身上</code>，，，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">  Animal.apply(this,arguments);</div><div class="line">  this.name = name;</div><div class="line">  this.color = color;</div><div class="line">&#125;</div><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">alert(cat1.species);    // 动物</div></pre></td></tr></table></figure>
<h4 id="prototype模式">prototype模式</h4>
<p>使用prototype模式。</p>
<p>如果“猫”的<code>prototype</code>对象，指向一个<code>Animal</code>的实例。那么所有“猫”的实例，就可以继承Animal了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cat.prototype = new Animal();</div><div class="line">Cat.prototype.constructor = Cat;</div><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">alert(cat1.species);    // 动物</div></pre></td></tr></table></figure>
<p>第一行，将Cat的prototype对象指向一个Animal的实例，相当于完全删除了prototype对象原先的值，然后赋予了一个新值。</p>
<p>那么第二行呢？任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有&quot;Cat.prototype = new Animal();&quot;（第一行）这一行，<code>Cat.prototype.constructor</code>是指向Cat的；加了这一行以后，<code>Cat.prototype.constructor</code>指向Animal。
即此时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Cat.prototype.constructor == Animal);     // true</div></pre></td></tr></table></figure>
<p>更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。
即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(cat1.constructor == Cat.prototype.constructor);   // true</div></pre></td></tr></table></figure>
<p>然后cat1.constructor也指向Animal了。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(cat1.constructor == Animal); // true</div></pre></td></tr></table></figure>
<p>这会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。</p>
<p>这是很重要的一点：<strong>如果替换了prototype对象，那么下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">o.prototype = &#123;&#125;;</div><div class="line">o.prototype.constructor = 0;</div></pre></td></tr></table></figure>
<h4 id="直接继承prototype">直接继承prototype</h4>
<p>其实是对第二种方法的改进。在本例中，Animal对象不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>
<p>先来改写Animal对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function Animal()&#123; &#125;</div><div class="line">Animal.prototype.species = &quot;动物&quot;;</div></pre></td></tr></table></figure>
<p>然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cat.prototype = Animal.prototype;</div><div class="line">Cat.prototype.constructor = Cat;</div><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">alert(cat1.species); // 动物</div></pre></td></tr></table></figure>
<p>与前一种方法相比，这样做:</p>
<ul>
<li>
<p>优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。</p>
</li>
<li>
<p>缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。</p>
</li>
</ul>
<p>所以其实上面的代码是不合理的！因为在第二行，Animal.prototype对象的constructor属性被改掉了！
此时的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Animal.prototype.constructor); // Cat</div></pre></td></tr></table></figure>
<h4 id="利用空对象作为中介">利用空对象作为中介</h4>
<p>由于&quot;直接继承prototype&quot;存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var F = function()&#123;&#125;;</div><div class="line">F.prototype = Animal.prototype;</div><div class="line">Cat.prototype = new F();</div><div class="line">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>
<p>F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Animal.prototype.constructor); // Animal</div></pre></td></tr></table></figure>
<p>将上面的方法，封装成一个函数，便于使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function extend(Child, Parent) &#123;</div><div class="line">　var F = function()&#123;&#125;;</div><div class="line">　F.prototype = Parent.prototype;</div><div class="line">　Child.prototype = new F();</div><div class="line">　Child.prototype.constructor = Child;</div><div class="line">　Child.uber = Parent.prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extend(Cat,Animal);</div><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">alert(cat1.species); // 动物</div></pre></td></tr></table></figure>
<p>这个extend函数，就是YUI库如何实现继承的方法。</p>
<p>函数体最后一行：<code>Child.uber = Parent.prototype;</code>…意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是&quot;向上&quot;、“上一层”。）</p>
<p>这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>
<h4 id="拷贝继承">拷贝继承</h4>
<p>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用&quot;拷贝&quot;方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function Animal()&#123;&#125;</div><div class="line">Animal.prototype.species = &quot;动物&quot;;</div></pre></td></tr></table></figure>
<p>然后再写一个函数，实现属性拷贝的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function extend2(Child, Parent) &#123;</div><div class="line">　var p = Parent.prototype;</div><div class="line">　var c = Child.prototype;</div><div class="line">　for (var i in p) &#123;</div><div class="line">　　c[i] = p[i];</div><div class="line">　&#125;</div><div class="line">　c.uber = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。</p>
<p>使用的时候，这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extend2(Cat, Animal);</div><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">alert(cat1.species); // 动物</div></pre></td></tr></table></figure>
<h3 id="不使用构造函数实现quot继承quot">不使用构造函数实现&quot;继承&quot;</h3>
<h4 id="什么是quot非构造函数quot的继承">什么是&quot;非构造函数&quot;的继承？</h4>
<p>现在有一个对象，叫做&quot;中国人&quot;。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Chinese = &#123;</div><div class="line">  nation:&quot;中国&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>再来个对象，叫做&quot;医生&quot;。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Doctor = &#123;</div><div class="line">  career:&quot;医生&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>请问怎样才能让&quot;医生&quot;去继承&quot;中国人&quot;，也就是说，我怎样才能生成一个&quot;中国医生&quot;的对象？</p>
<p>值得注意：这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现&quot;继承&quot;。</p>
<h4 id="object方法">object()方法</h4>
<p>json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">　function F() &#123;&#125;</div><div class="line">　F.prototype = o;</div><div class="line">　return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。</p>
<p>使用的时候，第一步先在父对象的基础上，生成子对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = object(Chinese);</div></pre></td></tr></table></figure>
<p>then,再加上对象本身的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Doctor.career = &apos;医生&apos;;</div></pre></td></tr></table></figure>
<p>试试看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.nation);  //中国</div></pre></td></tr></table></figure>
<h4 id="浅拷贝">浅拷贝</h4>
<p>除了使用&quot;prototype链&quot;以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p>
<p>下面这个函数，就是在做拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function extendCopy(p) &#123;</div><div class="line">　var c = &#123;&#125;;</div><div class="line">　for (var i in p) &#123; </div><div class="line">　　c[i] = p[i];</div><div class="line">　&#125;</div><div class="line">　c.uber = p;</div><div class="line">　return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候，这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Doctor = extendCopy(Chinese);</div><div class="line">Doctor.career = &apos;医生&apos;;</div><div class="line">alert(Doctor.nation); // 中国</div></pre></td></tr></table></figure>
<p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>请看，现在给Chinese添加一个&quot;出生地&quot;属性，它的值是一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div></pre></td></tr></table></figure>
<p>通过extendCopy()函数，Doctor继承了Chinese。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = extendCopy(Chinese);</div></pre></td></tr></table></figure>
<p>然后，为Doctor的&quot;出生地&quot;添加一个城市：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure>
<p>好像发生了些事情。。。Chinese的&quot;出生地&quot;也被改掉了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门</div></pre></td></tr></table></figure>
<p>so，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做&quot;浅拷贝&quot;。这是早期jQuery实现继承的方式。</p>
<h4 id="深拷贝">深拷贝</h4>
<p>所谓&quot;深拷贝&quot;，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用&quot;浅拷贝&quot;就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function deepCopy(p, c) &#123;</div><div class="line">　var c = c || &#123;&#125;;</div><div class="line">　for (var i in p) &#123;</div><div class="line">　　if (typeof p[i] === &apos;object&apos;) &#123;</div><div class="line">　　　c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</div><div class="line">　　　deepCopy(p[i], c[i]);</div><div class="line">　　&#125; else &#123;</div><div class="line">　　　c[i] = p[i];</div><div class="line">　  &#125;</div><div class="line">　&#125;</div><div class="line">　　return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = deepCopy(Chinese);</div></pre></td></tr></table></figure>
<p>现在，给父对象加上一个属性，值为数组。然后再子对象上修改这个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div><div class="line">Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure>
<p>这时候，父对象就不会受到影响了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">alert(Chinese.birthPlaces); //北京, 上海, 香港</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次实实在在做了一次搬运工，内容是从大神阮一峰的网站上搬来的。手打成博客，希望可以增加一些自己的理解，😄.&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="在路上" scheme="http://zrdsj.cc/tags/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    
      <category term="JavaScript" scheme="http://zrdsj.cc/tags/JavaScript/"/>
    
      <category term="阮一峰" scheme="http://zrdsj.cc/tags/%E9%98%AE%E4%B8%80%E5%B3%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于node.js的几句话</title>
    <link href="http://zrdsj.cc/2016/09/26/nodejs-talk/"/>
    <id>http://zrdsj.cc/2016/09/26/nodejs-talk/</id>
    <published>2016-09-26T08:35:43.250Z</published>
    <updated>2017-03-10T15:18:41.854Z</updated>
    
    <content type="html"><![CDATA[<p>接下来用’nj’来表示’Node.Js’.全都是。。。参考了网上几个地方的文档总结快速教程之类的，总的来说我就说自己是转载参考了<a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">这个</a>吧！向原作者致敬，thx。</p>
<a id="more"></a>
<h3 id="基础">基础</h3>
<h4 id="nodejs是啥">node.js是啥</h4>
<p><code>是一个解析器</code></p>
<p>前展思考：</p>
<ul>
<li>脚本语言的运行需要什么？</li>
<li>独立运行的js又是怎么样？</li>
</ul>
<h4 id="nodejs干啥用的">node.js干啥用的</h4>
<p><code>实现高性能Web服务器</code></p>
<p>不是我说的，是nj作者说的。</p>
<p>值得关注的两个点：</p>
<ul>
<li>事件机制</li>
<li>异步IO模型的优越性？</li>
</ul>
<p>哪种编程语言不自带IO功能，又可以良好支持事件机制？2333</p>
<p>sth else:</p>
<blockquote>
<p>对于前端而言，虽然不是人人都要拿NodeJS写一个服务器程序，但简单可至使用命令交互模式调试JS代码片段，复杂可至编写工具提升工作效率。</p>
</blockquote>
<h4 id="安装">安装</h4>
<p><a href="http://nodejs.cn/download/" target="_blank" rel="external">http://nodejs.cn/download/</a></p>
<h4 id="使用">使用</h4>
<p>法1：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo1.png" alt=""></p>
<p>法2：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo2.png" alt=""></p>
<p>then</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo3.png" alt=""></p>
<blockquote>
<p>你用的Linux？</p>
</blockquote>
<blockquote>
<p>哦，那我不会。。。😒</p>
</blockquote>
<h4 id="模块">模块</h4>
<p>（这是很jb大的一个话题其实）</p>
<p><strong>将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名</strong>。在编写每个模块时，都有<a href="http://www.cnblogs.com/pigtail/archive/2013/01/14/2859929.html" target="_blank" rel="external">require</a>、<a href="https://liuzhichao.com/p/1669.html" target="_blank" rel="external">exports</a>、<a href="http://www.cnblogs.com/dolphinX/p/3485260.html" target="_blank" rel="external">module</a>三个预先定义好的变量可供使用。</p>
<p>还应该注意的点：</p>
<ul>
<li>模块初始化</li>
<li>主模块</li>
</ul>
<h4 id="二进制模块">二进制模块</h4>
<p>一般使用js编写模块就可以了，但nj也支持使用C/C++编写二进制模块。</p>
<p>编译好的二进制模块除了文件扩展名是.node外，和js模块的使用方式相同。</p>
<blockquote>
<p><code>二进制模块能使用操作系统提供的所有功能，拥有无限的潜能.</code></p>
<p><code>对于前端而言并不容易，并且难以跨平台使用。</code></p>
</blockquote>
<p>so不再多说。</p>
<h3 id="代码组织部署">代码组织部署</h3>
<p>先来说说，这第二部分是干什么的。在我自己十分有限的学识当中，我的看法是这样：</p>
<blockquote>
<p>你写的程序通常不会仅仅是一个文件一个界面这类的，那么这些东西多起来的话就得对代码（藏在文件文件夹中的代码）按着某种合理高效的方式做一些处理。比如说<code>目录结构</code>和<code>部署方式</code>，这些事情就像盖房子时搭的脚手架一样。</p>
</blockquote>
<p>####模块路径解析规则</p>
<p>在第一部分提到的<code>require</code>，是一个函数，是nj中的一个模块了。它支持一定规则的路径写法，<a href="http://nqdeng.github.io/7-days-nodejs/#1.5.1" target="_blank" rel="external">详情</a>点击即可。但这两种路径在模块之间建立了<code>耦合关系</code>，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。</p>
<p>因此，require函数支持第三种形式的路径，写法类似于<code>foo/bar</code>，并依次按照以下规则解析路径，直到找到模块位置。</p>
<ul>
<li>
<p>内置模块</p>
<p>传递给require函数的是nj内置模块名称，不做路径解析直接返回内部模块的导出对象。例如<code>require('fs')</code>。</p>
</li>
<li>
<p>node_modules目录</p>
<p>nj定义了一个特殊的<code>node_modules</code>目录用于存放模块。例如某个模块的绝对路径是<code>/home/user/hello.js</code>，在该模块中使用<code>require('foo/bar')</code>方式加载模块时，则nj依次尝试使用以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/home/user/node_modules/foo/bar</div><div class="line">/home/node_modules/foo/bar</div><div class="line">/node_modules/foo/bar</div></pre></td></tr></table></figure>
</li>
<li>
<p>NODE_PATH环境变量</p>
<p>与PATH环境变量类似，nj允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用<code>:</code>分隔，在Windows下使用<code>;</code>分隔。例如定义了以下NODE_PATH环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NODE_PATH=/home/user/lib:/home/lib</div></pre></td></tr></table></figure>
<p>当使用<code>require('foo/bar')</code>的方式加载模块时，则NodeJS依次尝试以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/home/user/lib/foo/bar</div><div class="line">/home/lib/foo/bar</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="包package">包（package）</h4>
<p>nj中一个js模块，最小也得是一个js文件，大了呢我们的描述就会变成：<strong>多个子模块组成的复杂模块</strong>。为了便于使用与管理，我们将<u>许多由子模块组成的大模块成为<strong><em>包</em></strong></u>。并把所有子模块放在同一个目录里。</p>
<p>在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- /home/user/lib/</div><div class="line">  - cat/</div><div class="line">    head.js</div><div class="line">    body.js</div><div class="line">    main.js</div></pre></td></tr></table></figure>
<p>其中<code>cat</code>目录定义了一个包，其中包含了3个子模块。<code>main.js</code>作为入口模块，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var head = require(&apos;./head&apos;);</div><div class="line">var body = require(&apos;./body&apos;);</div><div class="line"></div><div class="line">exports.create = function (name) &#123;</div><div class="line">  return &#123;</div><div class="line">    name: name,</div><div class="line">    head: head.create(),</div><div class="line">    body: body.create()</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在其它模块里使用此包的时候，需要加载包的入口模块。接着上例，使用<code>require('/home/user/lib/cat/main')</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。</p>
<h5 id="indexjs">index.js</h5>
<p>当模块的文件名是<code>index.js</code>，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var cat = require(&apos;/home/user/lib/cat&apos;);</div><div class="line">var cat = require(&apos;/home/user/lib/cat/index&apos;);</div></pre></td></tr></table></figure>
<p>这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。</p>
<h5 id="pactagejson">pactage.json</h5>
<p>如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个<code>package.json</code>文件，并在其中指定入口模块的路径。上例中的<code>cat</code>模块可以重构如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- /home/user/lib/</div><div class="line">  - cat/</div><div class="line">    + doc/</div><div class="line">      - lib/</div><div class="line">        head.js</div><div class="line">        body.js</div><div class="line">        main.js</div><div class="line">      + tests/</div><div class="line">        package.json</div></pre></td></tr></table></figure>
<p>其中package.json内容如下。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;cat&quot;,</div><div class="line">  &quot;main&quot;: &quot;./lib/main.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此一来，就同样可以使用<code>require('/home/user/lib/cat')</code>的方式加载模块。NodeJS会根据包目录下的<code>package.json</code>找到入口模块所在位置。</p>
<h4 id="命令行程序">命令行程序</h4>
<p>使用nj编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。</p>
<p>例如我们用nj写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，我们把该程序部署在<code>/home/user/bin/node-echo.js</code>这个位置。为了在任何目录下都能运行该程序，我们需要使用以下终端命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node /home/user/bin/node-echo.js Hello World</div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>这种使用方式看起来不怎么像是一个命令行程序，下边的才是我们期望的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node-echo Hello World</div></pre></td></tr></table></figure>
<p>在Windows系统(这是个不太友好的开发环境，鄙人当前依然在使用)下的做法完全不同，我们得靠<code>.cmd</code>文件来解决问题。假设<code>node-echo.js</code>存放在<code>C:\Users\user\bin</code>目录，并且该目录已经添加到PATH环境变量里了。接下来需要在该目录下新建一个名为<code>node-echo.cmd</code>的文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@node &quot;C:\User\user\bin\node-echo.js&quot; %*</div></pre></td></tr></table></figure>
<p>这样处理后，我们就可以在任何目录下使用<code>node-echo</code>命令了。</p>
<p>最后再说一下这个Windows下的做法，我没试过也压根没去想。一般情况下我要执行node去运行某个js之类的操作时，我都是用相关bash工具去执行的，并不用cmd。。。</p>
<h4 id="工程目录">工程目录</h4>
<p>了解了以上知识后，现在我们来完整地规划一个工程目录（试试看）。</p>
<p>以编写一个<code>命令行程序</code>为例，一般我们会同时提供<code>命令行模式</code>和<code>API模式</code>两种使用方式，并且我们会借助三方包来编写代码。</p>
<p>除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- /home/user/workspace/node-echo/   # 工程目录</div><div class="line">- /home/user/workspace/node-echo/   # 工程目录</div><div class="line">  - bin/                          # 存放命令行相关代码</div><div class="line">    node-echo</div><div class="line">  + doc/                          # 存放文档</div><div class="line">  - lib/                          # 存放API相关代码</div><div class="line">    echo.js</div><div class="line">  - node_modules/                 # 存放三方包</div><div class="line">    + argv/</div><div class="line">  + tests/                        # 存放测试用例</div><div class="line">  package.json                    # 元数据文件</div><div class="line">  README.md                       # 说明文件</div></pre></td></tr></table></figure>
<p>其中部分文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* bin/node-echo */</div><div class="line">var argv = require(&apos;argv&apos;),</div><div class="line">echo = require(&apos;../lib/echo&apos;);</div><div class="line">console.log(echo(argv.join(&apos; &apos;)));</div><div class="line"></div><div class="line">/* lib/echo.js */</div><div class="line">module.exports = function (message) &#123;</div><div class="line">  return message;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* package.json */</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;node-echo&quot;,</div><div class="line">  &quot;main&quot;: &quot;./lib/echo.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上例子中分类存放了不同类型的文件，并通过<code>node_moudles</code>目录直接使用三方包名加载模块。此外，定义了<code>package.json</code>之后，<code>node-echo</code>目录也可被当作一个包来使用。</p>
<h4 id="npm">npm</h4>
<p>NPM是随同nj一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>可以看到，NPM建立了一个nj生态圈，nj开发者和用户可以在里边互通有无。以下分别介绍这三种场景下怎样使用NPM。</p>
<h5 id="下载三方包">下载三方包</h5>
<p>需要使用三方包时，首先得知道有哪些包可用。虽然官方–&gt;<a href="https://npmjs.org/" target="_blank" rel="external">npmjs.org</a>提供了个搜索框可以根据包名来搜索，但如果连想使用的三方包的名字都不确定的话，就请自行百度。知道了包名后，比如上边例子中的<code>argv</code>，就可以在工程目录下打开终端，使用以下命令来下载三方包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install argv</div><div class="line">...</div><div class="line">argv@0.0.2 node_modules\argv</div></pre></td></tr></table></figure>
<p>下载好之后，<strong><code>argv</code>包就放在了工程目录下的<code>node_modules</code>目录中</strong>，因此在<strong>代码中只需要通过<code>require('argv')</code>的方式就好，无需指定三方包路径</strong>。</p>
<p>以上命令默认下载最新版三方包，如果想要下载指定版本的话，可以在包名后边加上<code>@</code>，例如通过以下命令可下载0.0.x版的<code>argv</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install argv@0.0.1</div><div class="line">...</div><div class="line">argv@0.0.1 node_modules\argv</div></pre></td></tr></table></figure>
<p>如果使用到的三方包比较多，在终端下一个包一条命令地安装未免太人肉了。因此NPM对<code>package.json</code>的字段做了扩展，允许在其中申明三方包依赖。因此，上边例子中的<code>package.json</code>可以改写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;node-echo&quot;,</div><div class="line">  &quot;main&quot;: &quot;./lib/echo.js&quot;,</div><div class="line">  &quot;dependencies&quot;: &#123;  </div><div class="line">    &quot;argv&quot;: &quot;0.0.2&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样处理后，在工程目录下就可以使用<code>npm install</code>命令批量安装三方包了。更重要的是，当以后<code>node-echo</code>也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用<code>npm install node-echo</code>命令时，NPM会自动创建以下目录结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- project/</div><div class="line">  - node_modules/</div><div class="line">    - node-echo</div><div class="line">      - node_modules/</div><div class="line">        + argv/</div><div class="line">        ...</div><div class="line">...</div></pre></td></tr></table></figure>
<p>如此一来，用户只需关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系。</p>
<h5 id="安装命令行程序">安装命令行程序</h5>
<p>从NPM服务上下载安装一个命令行程序的方法与三方包类似。例如上例中的<code>node-echo</code>提供了命令行使用方式，只要<code>node-echo</code>自己配置好了相关的<code>package.json</code>字段，对于用户而言，只需要使用以下命令安装程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install node-echo -g</div></pre></td></tr></table></figure>
<p>参数中的<code>-g</code>表示全局安装，因此<code>node-echo</code>会默认安装到以下位置，并且NPM会自动创建好Windows系统下需要的<code>.cmd</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- /usr/local/               # Linux系统下</div><div class="line">  - lib/node_modules/</div><div class="line">    + node-echo/</div><div class="line">        ...</div><div class="line">    - bin/</div><div class="line">      node-echo</div><div class="line">        ...</div><div class="line">    ...</div><div class="line"></div><div class="line">- %APPDATA%\npm\            # Windows系统下</div><div class="line">  - node_modules\</div><div class="line">    + node-echo\</div><div class="line">        ...</div><div class="line">    node-echo.cmd</div><div class="line"> ...</div></pre></td></tr></table></figure>
<h5 id="发布代码">发布代码</h5>
<p>先给一个<a href="http://www.jianshu.com/p/26029206ad3e" target="_blank" rel="external">链接</a>。</p>
<p>第一次使用NPM发布代码前需要注册一个账号。终端下运行<code>npm adduser</code>，之后按照提示做即可。账号搞定后，接着我们需要编辑<code>package.json</code>文件，加入NPM必需的字段。接着上边<code>node-echo</code>的例子，<code>package.json</code>里必要的字段如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;node-echo&quot;,           # 包名，在NPM服务器上须要保持唯一</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,            # 当前版本号</div><div class="line">  &quot;dependencies&quot;: &#123;              # 三方包依赖，需要指定包名和版本号</div><div class="line">    &quot;argv&quot;: &quot;0.0.2&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;main&quot;: &quot;./lib/echo.js&quot;,       # 入口模块位置</div><div class="line">  &quot;bin&quot; : &#123;</div><div class="line">    &quot;node-echo&quot;: &quot;./bin/node-echo&quot;      # 命令行程序名和主模块位置</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后，我们就可以在<code>package.json</code>所在目录下运行<code>npm publish</code>发布代码了。</p>
<h5 id="版本号">版本号</h5>
<p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>
<p>语义版本号分为<code>X.Y.Z</code>三位，分别代表主版本号x、次版本号y和补丁版本号z。当代码变更时，版本号按以下原则更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ 如果只是修复bug，需要更新Z位。</div><div class="line"></div><div class="line">+ 如果是新增了功能，但是向下兼容，需要更新Y位。</div><div class="line"></div><div class="line">+ 如果有大变动，向下不兼容，需要更新X位。</div></pre></td></tr></table></figure>
<p>版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如<code>&quot;argv&quot;: &quot;0.0.x&quot;</code>表示依赖于<code>0.0.x</code>系列的最新版<code>argv</code>。NPM支持的所有版本号范围指定方式可以查看<a href="https://npmjs.org/doc/files/package.json.html#dependencies" target="_blank" rel="external">官方文档</a>。</p>
<h5 id="else">else</h5>
<p>除了本jie介绍的部分外，NPM还提供了很多功能，<code>package.json</code>里也有很多其它有用的字段。除了可以在<a href="https://npmjs.org/doc/" target="_blank" rel="external">npmjs.org/doc/</a>查看官方文档外，这里再介绍一些NPM常用命令。</p>
<ul>
<li>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</li>
<li>使用<code>npm help</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</li>
<li>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用<code>npm update</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</li>
<li>使用<code>npm update -g</code>可以把全局安装的对应命令行程序更新至最新版。</li>
<li>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</li>
<li>使用<code>npm unpublish @</code>可以撤销发布自己发布过的某个版本代码。</li>
</ul>
<h3 id="文件操作">文件操作</h3>
<p>让前端觉得如获神器的可能不是nj能做网络编程，而是nj能够操作文件。从<em>文件查找</em>到<em>代码编译</em>，几乎没有一个前端工具不操作文件。换个角度讲，几乎也只需要一些数据处理逻辑，再加上一些文件操作，就能够编写出大多数前端工具。本章将介绍与之相关的nj内置模块。</p>
<h4 id="开门红">开门红</h4>
<p>nj提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。与<code>copy</code>命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。</p>
<h5 id="小文件拷贝">小文件拷贝</h5>
<p>使用nj内置的<code>fs</code>模块简单实现这个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">function copy(src, dst) &#123;</div><div class="line">  fs.writeFileSync(dst, fs.readFileSync(src));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">  copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p>以上程序使用<code>fs.readFileSync</code>从源路径读取文件内容，并使用<code>fs.writeFileSync</code>将文件内容写入目标路径。</p>
<p>其中<code>process</code>是一个全局变量，可通过<code>process.argv</code>获得命令行参数。由于<code>argv[0]</code>固定等于nj执行程序的绝对路径，<code>argv[1]</code>固定等于主模块的绝对路径，因此第一个命令行参数从<code>argv[2]</code>这个位置开始。</p>
<h5 id="大文件拷贝">大文件拷贝</h5>
<p>上边的程序拷贝一些小文件没有问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。（试想你的服务器有一个数g的iso文件，如果想要将这个文件进行操作的话，，hh显然不可能一下进行操作，那样会弄炸你的服务器）对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">function copy(src, dst) &#123;</div><div class="line">  fs.createReadStream(src).pipe(fs.createWriteStream(dst));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">  copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p>以上程序使用<code>fs.createReadStream</code>创建了一个源文件的只读数据流，并使用<code>fs.createWriteStream</code>创建了一个目标文件的只写数据流，并且用<code>pipe</code>方法把两个数据流连接了起来。连接起来后发生的事情，说得抽象点的话，水顺着水管从一个桶流到了另一个桶。</p>
<h4 id="api">API</h4>
<p>我们大致看看nj提供了哪些和文件操作有关的API。并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h5 id="buffer数据块">Buffer（数据块）</h5>
<p><a href="https://nodejs.org/api/buffer.html" target="_blank" rel="external">官方文档</a></p>
<p>JavaScript语言自身只有字符串数据类型，没有二进制数据类型，因此nj提供了一个与<code>String</code>对等的全局构造函数<code>Buffer</code>来提供对二进制数据的操作。除了可以读取文件得到<code>Buffer</code>的实例外，还能够直接构造，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串类似，除了可以用<code>.length</code>属性得到字节长度外，还可以用<code>[index]</code>方式读取指定位置的字节，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin[0]; // =&gt; 0x68;</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串能够互相转化，例如可以使用指定编码将二进制数据转化为字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var str = bin.toString(&apos;utf-8&apos;); // =&gt; &quot;hello&quot;</div></pre></td></tr></table></figure>
<p>或者反过来，将字符串转换为指定编码下的二进制数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer(&apos;hello&apos;, &apos;utf-8&apos;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于<code>Buffer</code>，更像是可以做指针操作的C语言数组。例如，可以用<code>[index]</code>方式直接修改某个位置的字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin[0] = 0x48;</div></pre></td></tr></table></figure>
<p>而<code>.slice</code>方法也不是返回一个新的<code>Buffer</code>，而更像是返回了指向原<code>Buffer</code>中间的某个位置的指针，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]</div><div class="line">    ^           ^</div><div class="line">    |           |</div><div class="line">   bin     bin.slice(2)</div></pre></td></tr></table></figure>
<p>因此对<code>.slice</code>方法返回的<code>Buffer</code>的修改会作用于原<code>Buffer</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div><div class="line">var sub = bin.slice(2);</div><div class="line"></div><div class="line">sub[0] = 0x65;</div><div class="line">console.log(bin); // =&gt; &lt;Buffer 68 65 65 6c 6f&gt;</div></pre></td></tr></table></figure>
<p>也因此，如果想要拷贝一份<code>Buffer</code>，得首先创建一个新的<code>Buffer</code>，并通过<code>.copy</code>方法把原<code>Buffer</code>中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div><div class="line">var dup = new Buffer(bin.length);</div><div class="line"></div><div class="line">bin.copy(dup);</div><div class="line">dup[0] = 0x48;</div><div class="line">console.log(bin); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</div><div class="line">console.log(dup); // =&gt; &lt;Buffer 48 65 65 6c 6f&gt;</div></pre></td></tr></table></figure>
<p>总之，<code>Buffer</code>将JS的数据处理能力从字符串扩展到了任意二进制数据。</p>
<h5 id="stream数据流">Stream（数据流）</h5>
<p><a href="http://nodejs.org/api/buffer.html" target="_blank" rel="external">官方文档</a></p>
<p>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种<code>Stream</code>来提供对数据流的操作。</p>
<p>以上边的大文件拷贝程序为例，现在为数据来源创建一个只读数据流，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(pathname);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  doSomething(chunk);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  cleanUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Stream</code>基于事件机制工作，所有<code>Stream</code>的实例都继承于NodeJS提供的<a href="http://nodejs.org/api/events.html" target="_blank" rel="external">EventEmitter</a>。</p>
<p>上边的代码中<code>data</code>事件会源源不断地被触发，不管<code>doSomething</code>函数是否处理得过来。代码可以继续做如下改造，以解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  rs.pause();</div><div class="line">  doSomething(chunk, function () &#123;</div><div class="line">    rs.resume();</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  cleanUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上代码给<code>doSomething</code>函数加上了回调，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。</p>
<p>此外，我们也可以为数据目标创建一个只写数据流，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line">var ws = fs.createWriteStream(dst);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  ws.write(chunk);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  ws.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>把<code>doSomething</code>换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据<code>.write</code>方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据<code>drain</code>事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。因此代码可以继续改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line">var ws = fs.createWriteStream(dst);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  if (ws.write(chunk) === false) &#123;</div><div class="line">    rs.pause();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  ws.end();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ws.on(&apos;drain&apos;, function () &#123;</div><div class="line">    rs.resume();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上代码实现了数据从只读数据流到只写数据流的搬运，并包括了防爆仓控制。因为这种使用场景很多，例如上边的大文件拷贝程序，NodeJS直接提供了<code>.pipe</code>方法来做这件事情，其内部实现方式与上边的代码类似。</p>
<h5 id="file-system文件系统">File System（文件系统）</h5>
<p><a href="http://nodejs.org/api/fs.html" target="_blank" rel="external">官方文档</a></p>
<p>NodeJS通过<code>fs</code>内置模块提供对文件的操作。<code>fs</code>模块提供的API基本上可以分为以下三类：</p>
<ul>
<li>
<p>文件属性读写。</p>
<p>其中常用的有<code>fs.stat</code>、<code>fs.chmod</code>、<code>fs.chown</code>等等。</p>
</li>
<li>
<p>文件内容读写。</p>
<p>其中常用的有<code>fs.readFile</code>、<code>fs.readdir</code>、<code>fs.writeFile</code>、<code>fs.mkdir</code>等等。</p>
</li>
<li>
<p>底层文件操作。</p>
<p>其中常用的有<code>fs.open</code>、<code>fs.read</code>、<code>fs.write</code>、<code>fs.close</code>等等。</p>
</li>
</ul>
<p>NodeJS最精华的异步IO模型在<code>fs</code>模块里有着充分的体现，例如上边提到的这些API都通过回调函数传递结果。以<code>fs.readFile</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.readFile(pathname, function (err, data) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">      // Deal with error.</div><div class="line">  &#125; else &#123;</div><div class="line">      // Deal with data.</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如上边代码所示，基本上所有<code>fs</code>模块API的回调参数都有两个。第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果。</p>
<p>此外，<code>fs</code>模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况。同步API除了方法名的末尾多了一个<code>Sync</code>之外，异常对象与执行结果的传递方式也有相应变化。同样以<code>fs.readFileSync</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  var data = fs.readFileSync(pathname);</div><div class="line">  // Deal with data.</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  // Deal with error.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>fs</code>模块提供的API很多，这里不一一介绍，需要时请自行查阅官方文档。</p>
<p><a href="http://nodejs.org/api/path.html" target="_blank" rel="external">官方文档</a></p>
<p>操作文件时难免与文件路径打交道。NodeJS提供了<code>path</code>内置模块来简化路径相关操作，并提升代码可读性。以下是几个常用的API简介。</p>
<ul>
<li>
<p>path.normalize</p>
<p>将传入的路径转换为标准路径，具体讲的话，除了解析路径中的<code>.</code>与<code>..</code>外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var cache = &#123;&#125;;</div><div class="line"></div><div class="line">function store(key, value) &#123;</div><div class="line">  cache[path.normalize(key)] = value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store(&apos;foo/bar&apos;, 1);</div><div class="line">store(&apos;foo//baz//../bar&apos;, 2);</div><div class="line">console.log(cache);  // =&gt; &#123; &quot;foo/bar&quot;: 2 &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>**坑出没注意： **标准化之后的路径里的斜杠在Windows系统下是<code>\</code>，而在Linux系统下是<code>/</code>。如果想保证任何系统下都使用<code>/</code>作为路径分隔符的话，需要用<code>.replace(/\\/g, '/')</code>再替换一下标准路径。</p>
</blockquote>
<ul>
<li>
<p>path.join</p>
<p>将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot;</div></pre></td></tr></table></figure>
</li>
<li>
<p>path.extname</p>
<p>当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>path</code>模块提供的其余方法也不多，稍微看一下官方文档就能全部掌握。</p>
<h4 id="遍历目录">遍历目录</h4>
<p>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。</p>
<h5 id="递归算法">递归算法</h5>
<p>遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(n) &#123;</div><div class="line">  if(n === 1) &#123;</div><div class="line">    return 1;</div><div class="line">  &#125; else &#123;</div><div class="line">    return n * factorial(n - 1);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1。</p>
<blockquote>
<p><strong>陷阱</strong>： 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数！</p>
</blockquote>
<h5 id="遍历算法">遍历算法</h5>
<p>目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是<code>A &gt; B &gt; D &gt; E &gt; C &gt; F</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    A</div><div class="line">   / \</div><div class="line">  B   C</div><div class="line"> / \   \</div><div class="line">D   E   F</div></pre></td></tr></table></figure>
<h5 id="同步遍历">同步遍历</h5>
<p>了解了必要的算法后，我们可以简单地实现以下目录遍历函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function travel(dir, callback) &#123;</div><div class="line">  fs.readdirSync(dir).forEach(function (file) &#123;</div><div class="line">    var pathname = path.join(dir, file);</div><div class="line"></div><div class="line">    if(fs.statSync(pathname).isDirectory()) &#123;</div><div class="line">      travel(pathname, callback);</div><div class="line">    &#125; else &#123;</div><div class="line">      callback(pathname);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- /home/user/</div><div class="line">  - foo/</div><div class="line">    x.js</div><div class="line">  - bar/</div><div class="line">    y.js</div><div class="line">    z.css</div></pre></td></tr></table></figure>
<p>使用以下代码遍历该目录时，得到的输入如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">travel(&apos;/home/user&apos;, function (pathname) &#123;</div><div class="line">  console.log(pathname);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">------------------------</div><div class="line">/home/user/foo/x.js</div><div class="line">/home/user/bar/y.js</div><div class="line">/home/user/z.css</div></pre></td></tr></table></figure>
<h5 id="异步遍历">异步遍历</h5>
<p>如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。<code>travel</code>函数的异步版本如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function travel(dir, callback, finish) &#123;</div><div class="line">  fs.readdir(dir, function (err, files) &#123;</div><div class="line">    (function next(i) &#123;</div><div class="line">       if(i &lt; files.length) &#123;</div><div class="line">         var pathname = path.join(dir, files[i]);</div><div class="line"></div><div class="line">         fs.stat(pathname, function (err, stats) &#123;</div><div class="line">           if(stats.isDirectory()) &#123;</div><div class="line">             travel(pathname, callback, function () &#123;</div><div class="line">               next(i + 1);</div><div class="line">             &#125;);</div><div class="line">           &#125; else &#123;</div><div class="line">             callback(pathname, function () &#123;</div><div class="line">               next(i + 1);</div><div class="line">             &#125;);</div><div class="line">           &#125;</div><div class="line">         &#125;);</div><div class="line">       &#125; else &#123;</div><div class="line">         finish &amp;&amp; finish();</div><div class="line">         &#125;</div><div class="line">       &#125;(0));</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里不详细介绍异步遍历函数的编写技巧，在后续章节中会详细介绍这个。总之我们可以看到异步编程还是蛮复杂的。</p>
<h4 id="文本编码">文本编码</h4>
<p>使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有<code>UTF8</code>和<code>GBK</code>两种，并且<code>UTF8</code>文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的<code>UTF8</code>编码字符串后才能正常处理。</p>
<h5 id="bom的移除">BOM的移除</h5>
<p>BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（&quot;\uFEFF&quot;），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    Bytes      Encoding</div><div class="line">----------------------------</div><div class="line">    FE FF       UTF16BE</div><div class="line">    FF FE       UTF16LE</div><div class="line">    EF BB BF    UTF8</div></pre></td></tr></table></figure>
<p>因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。</p>
<p>例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM。例如，以下代码实现了识别和去除UTF8 BOM的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function readText(pathname) &#123;</div><div class="line">  var bin = fs.readFileSync(pathname);</div><div class="line"></div><div class="line">  if(bin[0] === 0xEF &amp;&amp; bin[1] === 0xBB &amp;&amp; bin[2] === 0xBF) </div><div class="line">    bin = bin.slice(3);</div><div class="line">  &#125;</div><div class="line">  return bin.toString(&apos;utf-8&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="gbk转utf8">GBK转UTF8</h5>
<p>NodeJS支持在读取文本文件时，或者在<code>Buffer</code>转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助<code>iconv-lite</code>这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var iconv = require(&apos;iconv-lite&apos;);</div><div class="line"></div><div class="line">function readGBKText(pathname) &#123;</div><div class="line">  var bin = fs.readFileSync(pathname);</div><div class="line">  return iconv.decode(bin, &apos;gbk&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="单字节编码">单字节编码</h5>
<p>有时候，我们无法预知需要读取的文件采用哪种编码，因此也就无法指定正确的编码。比如我们要处理的某些CSS文件中，有的用GBK编码，有的用UTF8编码。虽然可以一定程度可以根据文件的字节内容猜测出文本编码，但这里要介绍的是有些局限，但是要简单得多的一种技术。</p>
<p>首先我们知道，如果一个文本文件只包含英文字符，比如<code>Hello World</code>，那无论用GBK编码或是UTF8编码读取这个文件都是没问题的。这是因为在这些编码下，ASCII0~128范围内字符都使用相同的单字节编码。</p>
<p>反过来讲，即使一个文本文件中有中文等字符，如果我们需要处理的字符仅在ASCII0~128范围内，比如除了注释和字符串以外的JS代码，我们就可以统一使用单字节编码来读取文件，不用关心文件的实际编码是GBK还是UTF8。以下示例说明了这种方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1. GBK编码源文件内容：</div><div class="line">    var foo = &apos;中文&apos;;</div><div class="line">2. 对应字节：</div><div class="line">    76 61 72 20 66 6F 6F 20 3D 20 27 D6 D0 CE C4 27 3B</div><div class="line">3. 使用单字节编码读取后得到的内容：</div><div class="line">    var foo = &apos;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&apos;;</div><div class="line">4. 替换内容：</div><div class="line">    var bar = &apos;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&apos;;</div><div class="line">5. 使用单字节编码保存后对应字节：</div><div class="line">    76 61 72 20 62 61 72 20 3D 20 27 D6 D0 CE C4 27 3B</div><div class="line">6. 使用GBK编码读取后得到内容：</div><div class="line">    var bar = &apos;中文&apos;;</div></pre></td></tr></table></figure>
<h4 id="小结">小结</h4>
<p>本章介绍了使用NodeJS操作文件时需要的API以及一些技巧，总结起来有以下几点：</p>
<ul>
<li>学好文件操作，编写各种程序都不怕。</li>
<li>如果不是很在意性能，<code>fs</code>模块的同步API能让生活更加美好。</li>
<li>需要对文件读写做到字节级别的精细控制时，请使用<code>fs</code>模块的文件底层操作API。</li>
<li>不要使用拼接字符串的方式来处理路径，使用<code>path</code>模块。</li>
<li>掌握好目录遍历和文件编码处理技巧，很实用。</li>
</ul>
<h3 id="网络操作">网络操作</h3>
<p>一个合格的FE不能是不了解网络的，而NodeJS提供了一扇了解网络编程的窗口。通过NodeJS，除了可以编写一些服务端程序来协助前端开发和测试外，还能够学习一些HTTP协议与Socket协议的相关知识，这些知识在优化前端性能和排查前端故障时说不定能派上用场。本章将介绍与之相关的<em>NodeJS内置模块</em>。</p>
<h4 id="引入">引入</h4>
<p>NodeJS本来的用途是编写高性能Web服务器。我们首先在这里重复一下官方文档里的例子，使用NodeJS内置的<code>http</code>模块简单实现一个HTTP服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text-plain&apos; &#125;);</div><div class="line">  response.end(&apos;Hello World\n&apos;);</div><div class="line">&#125;).listen(8124);</div></pre></td></tr></table></figure>
<p>以上程序创建了一个HTTP服务器并监听<code>8124</code>端口，打开浏览器访问该端口<code>http://127.0.0.1:8124/</code>就能够看到效果。</p>
<blockquote>
<p><strong>xiao知识：</strong> 在Linux系统下，监听1024以下端口需要root权限。因此，如果想监听80或443端口的话，需要使用<code>sudo</code>命令启动程序。</p>
</blockquote>
<h4 id="api-watching">API watching</h4>
<p>先大致看看NodeJS提供了哪些和网络操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h5 id="http">HTTP</h5>
<p><a href="http://nodejs.org/api/http.html" target="_blank" rel="external">官方文档</a></p>
<p>'http’模块提供两种使用方式：</p>
<ul>
<li>作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。</li>
<li>作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。</li>
</ul>
<p>先来看看<strong>服务端模式</strong>下如何工作。如前文的例子所示，首先需要使用<code>.createServer</code>方法创建一个服务器，然后调用<code>.listen</code>方法监听端口。之后，每当来了一个客户端请求，创建服务器时传入的回调函数就被调用一次。可以看出，这是一种事件机制。</p>
<p>http请求本质上是一个数据流，由请求头（headers）和请求体（body）组成。例如以下是一个完整的HTTP请求数据内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST / HTTP/1.1</div><div class="line">User-Agent: curl/7.26.0</div><div class="line">Host: localhost</div><div class="line">Accept: */*</div><div class="line">Content-Length: 11</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>可以看到，空行之上是请求头，之下是请求体。http请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而<code>http</code>模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。在回调函数中，除了可以使用<code>request</code>对象访问请求头数据外，还能把<code>request</code>对象当作一个只读数据流来访问请求体数据。</p>
<p>以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var body = [];</div><div class="line"></div><div class="line">  console.log(request.method);</div><div class="line">  console.log(request.headers);</div><div class="line"></div><div class="line">  request.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  request.on(&apos;end&apos;, function () &#123;</div><div class="line">    body = Buffer.concat(body);</div><div class="line">    console.log(body.toString());</div><div class="line">  &#125;);</div><div class="line">&#125;).listen(80);</div><div class="line"></div><div class="line">------------------------------------</div><div class="line">POST</div><div class="line">&#123; &apos;user-agent&apos;: &apos;curl/7.26.0&apos;,</div><div class="line">  host: &apos;localhost&apos;,</div><div class="line">  accept: &apos;*/*&apos;,</div><div class="line">  &apos;content-length&apos;: &apos;11&apos;,</div><div class="line">  &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;</div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>http响应本质上也是一个数据流，同样由响应头（headers）和响应体（body）组成。例如以下是一个完整的 http请求数据内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: text/plain</div><div class="line">Content-Length: 11</div><div class="line">Date: Tue, 05 Nov 2013 05:31:38 GMT</div><div class="line">Connection: keep-alive</div><div class="line"></div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>在回调函数中，除了可以使用<code>response</code>对象来写入响应头数据外，还能把<code>response</code>对象当作一个只写数据流来写入响应体数据。例如在以下例子中，服务端原样将客户端请求的请求体数据返回给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">    response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</div><div class="line"></div><div class="line">    request.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">        response.write(chunk);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    request.on(&apos;end&apos;, function () &#123;</div><div class="line">        response.end();</div><div class="line">    &#125;);</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接下来看客户端模式下如何工作。为了发起一个客户端http请求，我们需要指定目标服务器的位置并发送请求头和请求体，以下示例演示了具体做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  hostname: &apos;www.example.com&apos;,</div><div class="line">  port: 80,</div><div class="line">  path: &apos;/upload&apos;,</div><div class="line">  method: &apos;POST&apos;,</div><div class="line">  headers: &#123;</div><div class="line">    &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var request = http.request(options, function (response) &#123;&#125;);</div><div class="line"></div><div class="line">request.write(&apos;Hello World&apos;);</div><div class="line">request.end();</div></pre></td></tr></table></figure>
<p>可以看到，<code>.request</code>方法创建了一个客户端，并指定请求目标和请求头数据。之后，就可以把<code>request</code>对象当作一个只写数据流来写入请求体数据和结束请求。另外，由于HTTP请求中<code>GET</code>请求是最常见的一种，并且不需要请求体，因此<code>http</code>模块也提供了以下便捷API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http.get(&apos;http://www.example.com/&apos;, function (response) &#123;&#125;);</div></pre></td></tr></table></figure>
<p>当客户端发送请求并接收到完整的服务端响应头时，就会调用回调函数。在回调函数中，除了可以使用<code>response</code>对象访问响应头数据外，还能把<code>response</code>对象当作一个只读数据流来访问响应体数据。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">http.get(&apos;http://www.example.com/&apos;, function (response) &#123;</div><div class="line">  var body = [];</div><div class="line"></div><div class="line">  console.log(response.statusCode);</div><div class="line">  console.log(response.headers);</div><div class="line"></div><div class="line">  response.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  response.on(&apos;end&apos;, function () &#123;</div><div class="line">    body = Buffer.concat(body);</div><div class="line">    console.log(body.toString());</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">------------------------------------</div><div class="line">200</div><div class="line">&#123; &apos;content-type&apos;: &apos;text/html&apos;,</div><div class="line">  server: &apos;Apache&apos;,</div><div class="line">  &apos;content-length&apos;: &apos;801&apos;,</div><div class="line">  date: &apos;Tue, 05 Nov 2013 06:08:41 GMT&apos;,</div><div class="line">  connection: &apos;keep-alive&apos; &#125;</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">...</div></pre></td></tr></table></figure>
<h5 id="https">HTTPS</h5>
<p><a href="http://nodejs.org/api/https.html" target="_blank" rel="external">官方文档</a></p>
<p><code>https</code>模块与<code>http</code>模块极为类似，区别在于<code>https</code>模块需要额外处理SSL证书。</p>
<p>在服务端模式下，创建一个HTTPS服务器的示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  key: fs.readFileSync(&apos;./ssl/default.key&apos;),</div><div class="line">  cert: fs.readFileSync(&apos;./ssl/default.cer&apos;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var server = https.createServer(options, function (request, response) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>可以看到，与创建HTTP服务器相比，多了一个<code>options</code>对象，通过<code>key</code>和<code>cert</code>字段指定了HTTPS服务器使用的私钥和公钥。</p>
<p>另外，NodeJS支持<a href="https://shansing.com/read/355/" target="_blank" rel="external">SNI技术</a> ，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。接着上例，可以使用以下方法为HTTPS服务器添加多组证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server.addContext(&apos;foo.com&apos;, &#123;</div><div class="line">  key: fs.readFileSync(&apos;./ssl/foo.com.key&apos;),</div><div class="line">  cert: fs.readFileSync(&apos;./ssl/foo.com.cer&apos;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.addContext(&apos;bar.com&apos;, &#123;</div><div class="line">  key: fs.readFileSync(&apos;./ssl/bar.com.key&apos;),</div><div class="line">  cert: fs.readFileSync(&apos;./ssl/bar.com.cer&apos;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在客户端模式下，发起一个HTTPS客户端请求与<code>http</code>模块几乎相同，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  hostname: &apos;www.example.com&apos;,</div><div class="line">  port: 443,</div><div class="line">  path: &apos;/&apos;,</div><div class="line">  method: &apos;GET&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var request = https.request(options, function (response) &#123;&#125;);</div><div class="line"></div><div class="line">request.end();</div></pre></td></tr></table></figure>
<p>但如果目标服务器使用的SSL证书是自制的，不是从颁发机构购买的，默认情况下<code>https</code>模块会拒绝连接，提示说有证书安全问题。在<code>options</code>里加入<code>rejectUnauthorized: false</code>字段可以禁用对证书有效性的检查，从而允许<code>https</code>模块请求开发环境下使用自制证书的HTTPS服务器。</p>
<h5 id="url">URL</h5>
<p><a href="http://nodejs.org/api/url.html" target="_blank" rel="external">官方文档</a></p>
<p>处理HTTP请求时<code>url</code>模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。首先我们来看看一个完整的URL的各组成部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                           href</div><div class="line"> -----------------------------------------------------------------</div><div class="line">                            host              path</div><div class="line">                      --------------- ----------------------------</div><div class="line"> http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash</div><div class="line"> -----    ---------   --------   ---- -------- ------------- -----</div><div class="line">protocol     auth     hostname   port pathname     search     hash</div><div class="line">                                                ------------</div><div class="line">                                                   query</div></pre></td></tr></table></figure>
<p>我们可以使用<code>.parse</code>方法来将一个URL字符串转换为URL对象，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">url.parse(&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;);</div><div class="line">/* =&gt;</div><div class="line">&#123; protocol: &apos;http:&apos;,</div><div class="line">  auth: &apos;user:pass&apos;,</div><div class="line">  host: &apos;host.com:8080&apos;,</div><div class="line">  port: &apos;8080&apos;,</div><div class="line">  hostname: &apos;host.com&apos;,</div><div class="line">  hash: &apos;#hash&apos;,</div><div class="line">  search: &apos;?query=string&apos;,</div><div class="line">  query: &apos;query=string&apos;,</div><div class="line">  pathname: &apos;/p/a/t/h&apos;,</div><div class="line">  path: &apos;/p/a/t/h?query=string&apos;,</div><div class="line">  href: &apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos; &#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>传给<code>.parse</code>方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，<code>request.url</code>不包含协议头和域名，但同样可以用<code>.parse</code>方法解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var tmp = request.url; // =&gt; &quot;/foo/bar?a=b&quot;</div><div class="line">  url.parse(tmp);</div><div class="line">  /* =&gt;</div><div class="line">  &#123; protocol: null,</div><div class="line">    slashes: null,</div><div class="line">    auth: null,</div><div class="line">    host: null,</div><div class="line">    port: null,</div><div class="line">    hostname: null,</div><div class="line">    hash: null,</div><div class="line">    search: &apos;?a=b&apos;,</div><div class="line">    query: &apos;a=b&apos;,</div><div class="line">    pathname: &apos;/foo/bar&apos;,</div><div class="line">    path: &apos;/foo/bar?a=b&apos;,</div><div class="line">    href: &apos;/foo/bar?a=b&apos; </div><div class="line">  &#125;</div><div class="line">  */</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p><code>.parse</code>方法还支持第二个和第三个布尔类型可选参数。第二个参数等于<code>true</code>时，该方法返回的URL对象中，<code>query</code>字段不再是一个字符串，而是一个经过<code>querystring</code>模块转换后的参数对象。第三个参数等于<code>true</code>时，该方法可以正确解析不带协议头的URL，例如<code>//www.example.com/foo/bar</code>。</p>
<p>反过来，<code>format</code>方法允许将一个URL对象转换为URL字符串，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">url.format(&#123;</div><div class="line">  protocol: &apos;http:&apos;,</div><div class="line">  host: &apos;www.example.com&apos;,</div><div class="line">  pathname: &apos;/p/a/t/h&apos;,</div><div class="line">  search: &apos;query=string&apos;</div><div class="line">&#125;);</div><div class="line">/* =&gt;</div><div class="line">&apos;http://www.example.com/p/a/t/h?query=string&apos;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>另外，<code>.resolve</code>方法可以用于拼接URL，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">url.resolve(&apos;http://www.example.com/foo/bar&apos;, &apos;../baz&apos;);</div><div class="line">/* =&gt;</div><div class="line">http://www.example.com/baz</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="query-string">Query String</h5>
<p><a href="http://nodejs.org/api/querystring.html" target="_blank" rel="external">官方文档</a></p>
<p><code>querystring</code>模块用于实现URL参数字符串与参数对象的互相转换，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;);</div><div class="line">/* =&gt;</div><div class="line">&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;</div><div class="line">*/</div><div class="line"></div><div class="line">querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;);</div><div class="line">/* =&gt;</div><div class="line">&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="zlib">Zlib</h5>
<p><a href="http://nodejs.org/api/zlib.html" target="_blank" rel="external">官方文档</a></p>
<p><code>zlib</code>模块提供了数据压缩和解压的功能。当处理HTTP请求和响应时，可能需要用到这个模块。</p>
<p>首先看一个使用<code>zlib</code>模块压缩HTTP响应体数据的例子。这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用<code>zlib</code>模块返回gzip之后的响应体数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var i = 1024,</div><div class="line">      data = &apos;&apos;;</div><div class="line"></div><div class="line">  while (i--) &#123;</div><div class="line">    data += &apos;.&apos;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if((request.headers[&apos;accept-encoding&apos;] || &apos;&apos;).indexOf(&apos;gzip&apos;) !== -1) &#123;</div><div class="line">    zlib.gzip(data, function (err, data) &#123;</div><div class="line">      response.writeHead(200, &#123;</div><div class="line">        &apos;Content-Type&apos;: &apos;text/plain&apos;,</div><div class="line">        &apos;Content-Encoding&apos;: &apos;gzip&apos;</div><div class="line">      &#125;);</div><div class="line">      response.end(data);</div><div class="line">    &#125;);</div><div class="line">  &#125; else &#123;</div><div class="line">    response.writeHead(200, &#123;</div><div class="line">      &apos;Content-Type&apos;: &apos;text/plain&apos;</div><div class="line">    &#125;);</div><div class="line">    response.end(data);</div><div class="line">  &#125;</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接着我们看一个使用<code>zlib</code>模块解压HTTP响应体数据的例子。这个例子中，判断了服务端响应是否使用gzip压缩，并在压缩的情况下使用<code>zlib</code>模块解压响应体数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  hostname: &apos;www.example.com&apos;,</div><div class="line">  port: 80,</div><div class="line">  path: &apos;/&apos;,</div><div class="line">  method: &apos;GET&apos;,</div><div class="line">  headers: &#123;</div><div class="line">    &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">http.request(options, function (response) &#123;</div><div class="line">  var body = [];</div><div class="line"></div><div class="line">  response.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  response.on(&apos;end&apos;, function () &#123;</div><div class="line">    body = Buffer.concat(body);</div><div class="line"></div><div class="line">  if(response.headers[&apos;content-encoding&apos;] === &apos;gzip&apos;) &#123;</div><div class="line">    zlib.gunzip(body, function (err, data) &#123;</div><div class="line">      console.log(data.toString());</div><div class="line">    &#125;);</div><div class="line">  &#125; else &#123;</div><div class="line">    console.log(data.toString());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;).end();</div></pre></td></tr></table></figure>
<h5 id="net">Net</h5>
<p><a href="http://nodejs.org/api/net.html" target="_blank" rel="external">官方文档</a></p>
<p><code>net</code>模块可用于创建Socket服务器或Socket客户端。由于Socket在前端领域的使用范围还不是很广，这里先不涉及到WebSocket的介绍，仅仅简单演示一下如何从Socket层面来实现HTTP请求和响应。</p>
<p>首先我们来看一个使用Socket搭建一个很不严谨的HTTP服务器的例子。这个HTTP服务器不管收到啥请求，都固定返回相同的响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">net.createServer(function (conn) &#123;</div><div class="line">  conn.on(&apos;data&apos;, function (data) &#123;</div><div class="line">    conn.write([</div><div class="line">      &apos;HTTP/1.1 200 OK&apos;,</div><div class="line">      &apos;Content-Type: text/plain&apos;,</div><div class="line">      &apos;Content-Length: 11&apos;,</div><div class="line">      &apos;&apos;,</div><div class="line">      &apos;Hello World&apos;</div><div class="line">    ].join(&apos;\n&apos;));</div><div class="line">  &#125;);</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接着来看一个使用Socket发起HTTP客户端请求的例子。这个例子中，Socket客户端在建立连接后发送了一个HTTP GET请求，并通过<code>data</code>事件监听函数来获取服务器响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  port: 80,</div><div class="line">  host: &apos;www.example.com&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var client = net.connect(options, function () &#123;</div><div class="line">  client.write([</div><div class="line">    &apos;GET / HTTP/1.1&apos;,</div><div class="line">    &apos;User-Agent: curl/7.26.0&apos;,</div><div class="line">    &apos;Host: www.baidu.com&apos;,</div><div class="line">    &apos;Accept: */*&apos;,</div><div class="line">    &apos;&apos;,</div><div class="line">    &apos;&apos;</div><div class="line">  ].join(&apos;\n&apos;));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">client.on(&apos;data&apos;, function (data) &#123;</div><div class="line">  console.log(data.toString());</div><div class="line">  client.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="灵机一点">灵机一点</h4>
<p>使用NodeJS操作网络，特别是操作HTTP请求和响应时会遇到一些惊喜，这里对一些常见问题做解答。</p>
<ul>
<li>
<p>问： 为什么通过<code>headers</code>对象访问到的HTTP请求头或响应头字段不是驼峰的？</p>
<p>答： 从规范上讲，HTTP请求头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个HTTP服务端或客户端程序都严格遵循规范，所以NodeJS在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如<code>headers['content-length']</code>。</p>
</li>
<li>
<p>问： 为什么<code>http</code>模块创建的HTTP服务器返回的响应是<code>chunked</code>传输方式的？</p>
<p>答： 因为默认情况下，使用<code>.writeHead</code>方法写入响应头后，允许使用<code>.write</code>方法写入任意长度的响应体数据，并使用<code>.end</code>方法结束一个响应。由于响应体数据长度不确定，因此NodeJS自动在响应头里添加了<code>Transfer-Encoding: chunked</code>字段，并采用<code>chunked</code>传输方式。但是当响应体数据长度确定时，可使用<code>.writeHead</code>方法在响应头里加上<code>Content-Length</code>字段，这样做之后NodeJS就不会自动添加<code>Transfer-Encoding</code>字段和使用<code>chunked</code>传输方式。</p>
</li>
<li>
<p>问： 为什么使用<code>http</code>模块发起HTTP客户端请求时，有时候会发生<code>socket hang up</code>错误？</p>
<p>答： 发起客户端HTTP请求前需要先创建一个客户端。<code>http</code>模块提供了一个全局客户端<code>http.globalAgent</code>，可以让我们使用<code>.request</code>或<code>.get</code>方法时不用手动创建客户端。但是全局客户端默认只允许5个并发Socket连接，当某一个时刻HTTP客户端请求创建过多，超过这个数字时，就会发生<code>socket hang up</code>错误。解决方法也很简单，通过<code>http.globalAgent.maxSockets</code>属性把这个数字改大些即可。另外，<code>https</code>模块遇到这个问题时也一样通过<code>https.globalAgent.maxSockets</code>属性来处理。</p>
</li>
</ul>
<h4 id="小结">小结</h4>
<p>本章介绍了使用NodeJS操作网络时需要的API以及一些坑回避技巧，总结起来有以下几点：</p>
<ul>
<li><code>http</code>和<code>https</code>模块支持服务端模式和客户端模式两种使用方式。</li>
<li><code>request</code>和<code>response</code>对象除了用于读写头数据外，都可以当作数据流来操作。</li>
<li><code>url.parse</code>方法加上<code>request.url</code>属性是处理HTTP请求时的固定搭配。</li>
<li>使用<code>zlib</code>模块可以减少使用HTTP协议时的数据传输量。</li>
<li>通过<code>net</code>模块的Socket服务器与客户端可对HTTP协议做底层操作。</li>
<li>小心踩坑。</li>
</ul>
<h3 id="进程管理">进程管理</h3>
<p>NodeJS可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。本章除了介绍与之相关的NodeJS内置模块外，还会重点介绍典型的使用场景。</p>
<h4 id="开门红">开门红</h4>
<p>我们已经知道了NodeJS自带的<code>fs</code>模块比较基础，把一个目录里的所有文件和子目录都拷贝到另一个目录里需要写不少代码。另外我们也知道，终端下的<code>cp</code>命令比较好用，一条<code>cp -r source/* target</code>命令就能搞定目录拷贝。那我们首先看看如何使用NodeJS调用终端命令来简化目录拷贝，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var child_process = require(&apos;child_process&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line"></div><div class="line">function copy(source, target, callback) &#123;</div><div class="line">  child_process.exec(</div><div class="line">    util.format(&apos;cp -r %s/* %s&apos;, source, target), callback);</div><div class="line">&#125;</div><div class="line"></div><div class="line">copy(&apos;a&apos;, &apos;b&apos;, function (err) &#123;</div><div class="line">    // ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>从以上代码中可以看到，子进程是异步运行的，通过回调函数返回执行结果。</p>
<h4 id="api">API</h4>
<p>先大致看看NodeJS提供了哪些和进程管理有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h5 id="process">Process</h5>
<p><a href="http://nodejs.org/api/process.html" target="_blank" rel="external">官方文档</a></p>
<p>任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。在NodeJS中，可以通过<code>process</code>对象感知和控制NodeJS自身进程的方方面面。另外需要注意的是，<code>process</code>不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。</p>
<h5 id="child-process">Child Process</h5>
<p><a href="http://nodejs.org/api/child_process.html" target="_blank" rel="external">官方文档</a></p>
<p>使用<code>child_process</code>模块可以创建和控制子进程。该模块提供的API中最核心的是<code>.spawn</code>，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。</p>
<h5 id="cluster">Cluster</h5>
<p><a href="http://nodejs.org/api/cluster.html" target="_blank" rel="external">官方文档</a></p>
<p><code>cluster</code>模块是对<code>child_process</code>模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。</p>
<h4 id="应用场景">应用场景</h4>
<p>和进程管理相关的API单独介绍起来比较枯燥，因此这里从一些典型的应用场景出发，分别介绍一些重要API的使用方法。</p>
<h5 id="如何获取命令行参数">如何获取命令行参数</h5>
<p>在NodeJS中可以通过<code>process.argv</code>获取命令行参数。但是比较意外的是，<code>node</code>执行程序路径和主模块文件路径固定占据了<code>argv[0]</code>和<code>argv[1]</code>两个位置，而第一个命令行参数从<code>argv[2]</code>开始。为了让<code>argv</code>使用起来更加自然，可以按照以下方式处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function main(argv) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<h5 id="如何退出程序">如何退出程序</h5>
<p>通常一个程序做完所有事情后就正常退出了，这时程序的退出状态码为<code>0</code>。或者一个程序运行时发生了异常后就挂了，这时程序的退出状态码不等于<code>0</code>。如果我们在代码中捕获了某个异常，但是觉得程序不应该继续运行下去，需要立即退出，并且需要把退出状态码设置为指定数字，比如<code>1</code>，就可以按照以下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    // ...</div><div class="line">&#125; catch (err) &#123;</div><div class="line">    // ...</div><div class="line">    process.exit(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="如何控制输入输出">如何控制输入输出</h5>
<p>NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应<code>process.stdin</code>、<code>process.stdout</code>和<code>process.stderr</code>，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。例如，<code>console.log</code>可以按照以下方式实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function log() &#123;</div><div class="line">  process.stdout.write(</div><div class="line">    util.format.apply(util, arguments) + &apos;\n&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="如何降权">如何降权</h5>
<p>在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。以下是这样一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">http.createServer(callback).listen(80, function () &#123;</div><div class="line">  var env = process.env,</div><div class="line">  uid = parseInt(env[&apos;SUDO_UID&apos;] || process.getuid(), 10),</div><div class="line">  gid = parseInt(env[&apos;SUDO_GID&apos;] || process.getgid(), 10);</div><div class="line"></div><div class="line">  process.setgid(gid);</div><div class="line">  process.setuid(uid);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上例中有几点需要注意：</p>
<ol>
<li>如果是通过<code>sudo</code>获取root权限的，运行程序的用户的UID和GID保存在环境变量<code>SUDO_UID</code>和<code>SUDO_GID</code>里边。如果是通过<code>chmod +s</code>方式获取root权限的，运行程序的用户的UID和GID可直接通过<code>process.getuid</code>和<code>process.getgid</code>方法获取。</li>
<li><code>process.setuid</code>和<code>process.setgid</code>方法只接受<code>number</code>类型的参数。</li>
<li>降权时必须先降GID再降UID，否则顺序反过来的话就没权限更改程序的GID了。</li>
</ol>
<h5 id="如何创建子进程">如何创建子进程</h5>
<p>以下是一个创建NodeJS子进程的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;xxx.js&apos; ]);</div><div class="line"></div><div class="line">child.stdout.on(&apos;data&apos;, function (data) &#123;</div><div class="line">  console.log(&apos;stdout: &apos; + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.stderr.on(&apos;data&apos;, function (data) &#123;</div><div class="line">  console.log(&apos;stderr: &apos; + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.on(&apos;close&apos;, function (code) &#123;</div><div class="line">  console.log(&apos;child process exited with code &apos; + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上例中使用了<code>.spawn(exec, args, options)</code>方法，该方法支持三个参数。第一个参数是执行文件路径，可以是执行文件的相对或绝对路径，也可以是根据PATH环境变量能找到的执行文件名。第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。</p>
<p>另外，上例中虽然通过子进程对象的<code>.stdout</code>和<code>.stderr</code>访问子进程的输出，但通过<code>options.stdio</code>字段的不同配置，可以将子进程的输入输出重定向到任何数据流上，或者让子进程共享父进程的标准输入输出流，或者直接忽略子进程的输入输出。</p>
<h5 id="进程间如何通讯">进程间如何通讯</h5>
<p>在Linux系统下，进程之间可以通过信号互相通信。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ]);</div><div class="line"></div><div class="line">child.kill(&apos;SIGTERM&apos;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;SIGTERM&apos;, function () &#123;</div><div class="line">  cleanUp();</div><div class="line">  process.exit(0);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上例中，父进程通过<code>.kill</code>方法向子进程发送<code>SIGTERM</code>信号，子进程监听<code>process</code>对象的<code>SIGTERM</code>事件响应信号。不要被<code>.kill</code>方法的名称迷惑了，该方法本质上是用来给进程发送信号的，进程收到信号后具体要做啥，完全取决于信号的种类和进程自身的代码。</p>
<p>另外，如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ], &#123;</div><div class="line">  stdio: [ 0, 1, 2, &apos;ipc&apos; ]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">  console.log(msg);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.send(&#123; hello: &apos;hello&apos; &#125;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">  msg.hello = msg.hello.toUpperCase();</div><div class="line">  process.send(msg);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，父进程在创建子进程时，在<code>options.stdio</code>字段中通过<code>ipc</code>开启了一条IPC通道，之后就可以监听子进程对象的<code>message</code>事件接收来自子进程的消息，并通过<code>.send</code>方法给子进程发送消息。在子进程这边，可以在<code>process</code>对象上监听<code>message</code>事件接收来自父进程的消息，并通过<code>.send</code>方法向父进程发送消息。数据在传递过程中，会先在发送端使用<code>JSON.stringify</code>方法序列化，再在接收端使用<code>JSON.parse</code>方法反序列化。</p>
<h5 id="如何守护子进程">如何守护子进程</h5>
<p>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。以下是一种实现方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* daemon.js */</div><div class="line">function spawn(mainModule) &#123;</div><div class="line">  var worker = child_process.spawn(&apos;node&apos;, [ mainModule ]);</div><div class="line"></div><div class="line">  worker.on(&apos;exit&apos;, function (code) &#123;</div><div class="line">    if(code !== 0) &#123;</div><div class="line">      spawn(mainModule);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn(&apos;worker.js&apos;);</div></pre></td></tr></table></figure>
<p>可以看到，工作进程非正常退出时，守护进程立即重启工作进程。</p>
<h4 id="小结">小结</h4>
<p>本章介绍了使用NodeJS管理进程时需要的API以及主要的应用场景，总结起来有以下几点：</p>
<ul>
<li>使用<code>process</code>对象管理自身。</li>
<li>使用<code>child_process</code>模块创建和管理子进程。</li>
</ul>
<h3 id="异步编程">异步编程</h3>
<p>NodeJS最大的卖点——事件机制和异步IO，对开发者并不是透明的。开发者需要按异步方式编写代码才用得上这个卖点，而这一点也遭到了一些NodeJS反对者的抨击。但不管怎样，异步编程确实是NodeJS最大的特点，没有掌握异步编程就不能说是真正学会了NodeJS。本章将介绍与异步编程相关的各种知识。</p>
<h4 id="回调">回调</h4>
<p>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。我们首先可以看看以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function heavyCompute(n, callback) &#123;</div><div class="line">  var count = 0,</div><div class="line">       i, j;</div><div class="line"></div><div class="line">  for(i = n; i &gt; 0; --i) &#123;</div><div class="line">    for(j = n; j &gt; 0; --j) &#123;</div><div class="line">      count += 1;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  callback(count);</div><div class="line">&#125;</div><div class="line"></div><div class="line">heavyCompute(10000, function (count) &#123;</div><div class="line">  console.log(count);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;hello&apos;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">100000000</div><div class="line">hello</div></pre></td></tr></table></figure>
<p>可以看到，以上代码中的回调函数仍然先于后续代码执行。JS本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念。</p>
<p>但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。我们接着看看以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">setTimeout(function () &#123;</div><div class="line">  console.log(&apos;world&apos;);</div><div class="line">&#125;, 1000);</div><div class="line"></div><div class="line">console.log(&apos;hello&apos;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">hello</div><div class="line">world</div></pre></td></tr></table></figure>
<p>这次可以看到，回调函数后于后续代码执行了。如同上边所说，JS本身是单线程的，无法异步执行，因此我们可以认为<code>setTimeout</code>这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了<code>setTimeout</code>、<code>setInterval</code>这些常见的，这类函数还包括NodeJS提供的诸如<code>fs.readFile</code>之类的异步API。</p>
<p>另外，我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。以下就是这么一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function heavyCompute(n) &#123;</div><div class="line">  var count = 0,</div><div class="line">      i, j;</div><div class="line"></div><div class="line">  for (i = n; i &gt; 0; --i) &#123;</div><div class="line">    for (j = n; j &gt; 0; --j) &#123;</div><div class="line">      count += 1;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var t = new Date();</div><div class="line"></div><div class="line">setTimeout(function () &#123;</div><div class="line">  console.log(new Date() - t);</div><div class="line">&#125;, 1000);</div><div class="line"></div><div class="line">heavyCompute(50000);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">8520</div></pre></td></tr></table></figure>
<p>可以看到，本来应该在1秒后被调用的回调函数因为JS主线程忙于运行其它代码，实际执行时间被大幅延迟。</p>
<h4 id="代码设计模式">代码设计模式</h4>
<p>异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下分别介绍一些常见的模式。</p>
<h5 id="函数返回值">函数返回值</h5>
<p>使用一个函数的输出作为另一个函数的输入是很常见的需求，在同步方式下一般按以下方式编写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var output = fn1(fn2(&apos;input&apos;));</div><div class="line">// Do something.</div></pre></td></tr></table></figure>
<p>而在异步方式下，由于函数执行结果不是通过返回值，而是通过回调函数传递，因此一般按以下方式编写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fn2(&apos;input&apos;, function (output2) &#123;</div><div class="line">  fn1(output2, function (output1) &#123;</div><div class="line">    // Do something.</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，这种方式就是一个回调函数套一个回调函多，套得太多了很容易写出<code>&gt;</code>形状的代码。</p>
<h5 id="遍历数组">遍历数组</h5>
<p>在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。如果函数是同步执行的，一般就会写出以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var len = arr.length,</div><div class="line">    i = 0;</div><div class="line"></div><div class="line">for(; i &lt; len; ++i) &#123;</div><div class="line">  arr[i] = sync(arr[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// All array items have processed.</div></pre></td></tr></table></figure>
<p>如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(function next(i, len, callback) &#123;</div><div class="line">  if(i &lt; len) &#123;</div><div class="line">    async(arr[i], function (value) &#123;</div><div class="line">      arr[i] = value;</div><div class="line">      next(i + 1, len, callback);</div><div class="line">    &#125;);</div><div class="line">  &#125; else &#123;</div><div class="line">    callback();</div><div class="line">  &#125;</div><div class="line">&#125;(0, arr.length, function () &#123;</div><div class="line">    // All array items have processed.</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>可以看到，以上代码在异步函数执行一次并返回执行结果后才传入下一个数组成员并开始下一轮执行，直到所有数组成员处理完毕后，通过回调的方式触发后续代码的执行。</p>
<p>如果数组成员可以并行处理，但后续代码仍然需要所有数组成员处理完毕后才能执行的话，则异步代码会调整成以下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(function (i, len, count, callback) &#123;</div><div class="line">  for(; i &lt; len; ++i) &#123;</div><div class="line">    (function (i) &#123;</div><div class="line">      async(arr[i], function (value) &#123;</div><div class="line">        arr[i] = value;</div><div class="line">        if(++count === len) &#123;</div><div class="line">          callback();</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;(i));</div><div class="line">  &#125;</div><div class="line">&#125;(0, arr.length, 0, function () &#123;</div><div class="line">    // All array items have processed.</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员，并通过计数器变量来判断什么时候所有数组成员都处理完毕了。</p>
<h5 id="异常处理">异常处理</h5>
<p>JS自身提供的异常捕获和处理机制——<code>try..catch..</code>，只能用于同步执行的代码。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function sync(fn) &#123;</div><div class="line">  return fn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  sync(null);</div><div class="line">    // Do something.</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">Error: object is not a function</div></pre></td></tr></table></figure>
<p>可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个<code>try</code>语句时被捕获住。但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到<code>try</code>语句，就作为一个全局异常抛出。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function async(fn, callback) &#123;</div><div class="line">    // Code execution path breaks here.</div><div class="line">  setTimeout(function ()　&#123;</div><div class="line">    callback(fn());</div><div class="line">  &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  async(null, function (data) &#123;</div><div class="line">        // Do something.</div><div class="line">&#125;);</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">/home/user/test.js:4</div><div class="line">        callback(fn());</div><div class="line">                 ^</div><div class="line">TypeError: object is not a function</div><div class="line">  at null._onTimeout (/home/user/test.js:4:13)</div><div class="line">  at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)</div></pre></td></tr></table></figure>
<p>因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用<code>try</code>语句把异常捕获住，并通过回调函数传递被捕获的异常。于是我们可以像下边这样改造上边的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function async(fn, callback) &#123;</div><div class="line">    // Code execution path breaks here.</div><div class="line">  setTimeout(function ()　&#123;</div><div class="line">    try &#123;</div><div class="line">      callback(null, fn());</div><div class="line">    &#125; catch (err) &#123;</div><div class="line">    callback(err);</div><div class="line">    &#125;</div><div class="line">  &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">async(null, function (err, data) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">    console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">  &#125; else &#123;</div><div class="line">    // Do something.</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">Error: object is not a function</div></pre></td></tr></table></figure>
<p>可以看到，异常再次被捕获住了。在NodeJS中，几乎所有异步API都按照以上方式设计，回调函数中第一个参数都是<code>err</code>。因此我们在编写自己的异步函数时，也可以按照这种方式来处理异常，与NodeJS的设计风格保持一致。</p>
<p>有了异常处理方式后，我们接着可以想一想一般我们是怎么写代码的。基本上，我们的代码都是做一些事情，然后调用一个函数，然后再做一些事情，然后再调用一个函数，如此循环。如果我们写的是同步代码，只需要在代码入口点写一个<code>try</code>语句就能捕获所有冒泡上来的异常，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function main() &#123;</div><div class="line">    // Do something.</div><div class="line">  syncA();</div><div class="line">    // Do something.</div><div class="line">  syncB();</div><div class="line">    // Do something.</div><div class="line">  syncC();</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  main();</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  // Deal with exception.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，如果我们写的是异步代码，就只有呵呵了。由于每次异步函数调用都会打断代码执行路径，只能通过回调函数来传递异常，于是我们就需要在每个回调函数里判断是否有异常发生，于是只用三次异步函数调用，就会产生下边这种代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function main(callback) &#123;</div><div class="line">    // Do something.</div><div class="line">  asyncA(function (err, data) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">    callback(err);</div><div class="line">  &#125; else &#123;</div><div class="line">    // Do something</div><div class="line">    asyncB(function (err, data) &#123;</div><div class="line">      if(err) &#123;</div><div class="line">        callback(err);</div><div class="line">      &#125; else &#123;</div><div class="line">        // Do something</div><div class="line">        asyncC(function (err, data) &#123;</div><div class="line">          if(err) &#123;</div><div class="line">            callback(err);</div><div class="line">          &#125; else &#123;</div><div class="line">            // Do something</div><div class="line">            callback(null);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(function (err) &#123;</div><div class="line">  if(err) &#123;</div><div class="line">    // Deal with exception.</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，回调函数已经让代码变得复杂了，而异步方式下对异常的处理更加剧了代码的复杂度。如果NodeJS的最大卖点最后变成这个样子，那就没人愿意用NodeJS了，因此接下来会介绍NodeJS提供的一些解决方案。</p>
<h4 id="域domain">域（Domain）</h4>
<p><a href="http://nodejs.org/api/domain.html" target="_blank" rel="external">官方文档</a></p>
<p>NodeJS提供了<code>domain</code>模块，可以简化异步代码的异常处理。在介绍该模块之前，我们需要首先理解“域”的概念。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过<code>process</code>对象提供了捕获全局异常的方法，示例代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</div><div class="line">  console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(function (fn) &#123;</div><div class="line">  fn();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">Error: undefined is not a function</div></pre></td></tr></table></figure>
<p>虽然全局异常有个地方可以捕获了，但是对于大多数异常，我们希望尽早捕获，并根据结果决定代码的执行路径。我们用以下HTTP服务器代码作为例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function async(request, callback) &#123;</div><div class="line">    // Do something.</div><div class="line">  asyncA(request, function (err, data) &#123;</div><div class="line">    if(err) &#123;</div><div class="line">      callback(err);</div><div class="line">    &#125; else &#123;</div><div class="line">      // Do something</div><div class="line">      asyncB(request, function (err, data) &#123;</div><div class="line">        if(err) &#123;</div><div class="line">          callback(err);</div><div class="line">        &#125; else &#123;</div><div class="line">          // Do something</div><div class="line">          asyncC(request, function (err, data) &#123;</div><div class="line">            if(err) &#123;</div><div class="line">              callback(err);</div><div class="line">            &#125; else &#123;</div><div class="line">              // Do something</div><div class="line">              callback(null, data);</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  async(request, function (err, data) &#123;</div><div class="line">    if(err) &#123;</div><div class="line">      response.writeHead(500);</div><div class="line">      response.end();</div><div class="line">    &#125; else &#123;</div><div class="line">      response.writeHead(200);</div><div class="line">      response.end(data);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上代码将请求对象交给异步函数处理后，再根据处理结果返回响应。这里采用了使用回调函数传递异常的方案，因此<code>async</code>函数内部如果再多几个异步函数调用的话，代码就变成上边这副鬼样子了。为了让代码好看点，我们可以在每处理一个请求时，使用<code>domain</code>模块创建一个子域（JS子运行环境）。在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的<code>error</code>事件统一捕获。于是以上代码可以做如下改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function async(request, callback) &#123;</div><div class="line">    // Do something.</div><div class="line">  asyncA(request, function (data) &#123;</div><div class="line">      // Do something</div><div class="line">    asyncB(request, function (data) &#123;</div><div class="line">        // Do something</div><div class="line">      asyncC(request, function (data) &#123;</div><div class="line">          // Do something</div><div class="line">        callback(data);</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var d = domain.create();</div><div class="line"></div><div class="line">  d.on(&apos;error&apos;, function () &#123;</div><div class="line">    response.writeHead(500);</div><div class="line">    response.end();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  d.run(function () &#123;</div><div class="line">    async(request, function (data) &#123;</div><div class="line">      response.writeHead(200);</div><div class="line">      response.end(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，我们使用<code>.create</code>方法创建了一个子域对象，并通过<code>.run</code>方法进入需要在子域中运行的代码的入口点。而位于子域中的异步函数回调函数由于不再需要捕获异常，代码一下子瘦身很多。</p>
<h5 id="陷阱">陷阱</h5>
<p>无论是通过<code>process</code>对象的<code>uncaughtException</code>事件捕获到全局异常，还是通过子域对象的<code>error</code>事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。按照官方文档的说法，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。</p>
<p>但这里需要澄清一些事实。JS本身的<code>throw..try..catch</code>异常处理机制并不会导致内存泄漏，也不会让程序的执行结果出乎意料，但NodeJS并不是存粹的JS。NodeJS里大量的API内部是用C/C++实现的，因此NodeJS程序的运行过程中，代码执行路径穿梭于JS引擎内部和外部，而JS的异常抛出机制可能会打断正常的代码执行流程，导致C/C++部分的代码表现异常，进而导致内存泄漏等问题。</p>
<p>因此，使用<code>uncaughtException</code>或<code>domain</code>捕获异常，代码执行路径里涉及到了C/C++部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用<code>try</code>语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上诉问题。</p>
<h4 id="小结">小结</h4>
<p>本章介绍了JS异步编程相关的知识，总结起来有以下几点：</p>
<ul>
<li>不掌握异步编程就不算学会NodeJS。</li>
<li>异步编程依托于回调来实现，而使用回调不一定就是异步编程。</li>
<li>异步编程下的函数间数据传递、数组遍历和异常处理与同步编程有很大差别。</li>
<li>使用<code>domain</code>模块简化异步代码的异常处理，并小心陷阱</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接下来用’nj’来表示’Node.Js’.全都是。。。参考了网上几个地方的文档总结快速教程之类的，总的来说我就说自己是转载参考了&lt;a href=&quot;http://nqdeng.github.io/7-days-nodejs/&quot;&gt;这个&lt;/a&gt;吧！向原作者致敬，thx。&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="经验之谈" scheme="http://zrdsj.cc/tags/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/"/>
    
      <category term="在路上" scheme="http://zrdsj.cc/tags/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    
      <category term="node" scheme="http://zrdsj.cc/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>圣经几个读经方法</title>
    <link href="http://zrdsj.cc/2016/09/23/Bible-reading/"/>
    <id>http://zrdsj.cc/2016/09/23/Bible-reading/</id>
    <published>2016-09-23T12:47:57.657Z</published>
    <updated>2017-03-10T15:13:36.457Z</updated>
    
    <content type="html"><![CDATA[<p>几种读圣经的办法。准确点应该说是计划。圣经的通读，对基督徒来说其意义不言而喻。</p>
<a id="more"></a>
<p>最近使用了手机app—<a href="https://itunes.apple.com/cn/app/jing-du-sheng-jing/id969776780?mt=8" target="_blank" rel="external">精读圣经</a>。其中的设计与内容在我看来均为上乘，作者无偿满足了几乎全部的圣经学习需求，其平日运营的费用并不是向用户收费的。详情页面见👉 <a href="http://www.christapp.net/pay.html" target="_blank" rel="external">Love_GOD</a></p>
<p>言归正传，在app中我知道了几种不同的读经计划，也让自己平时零碎的读经变得更系统更合理了。令人十分欣慰。</p>
<h3 id="顺序读经计划">顺序读经计划</h3>
<p>这是最简单的方法了，按照对总量的计算和计划，将一年360多天的量都分出来。大概就是<code>每天3-4章的经文，一年可以读完新旧约一遍</code>。</p>
<p>此种方法也是有小细节可以优化的</p>
<ul>
<li>读的顺序可以不按照旧约新约中的排序，适量合理的编排方式也是可取的。（可以在网上进行搜寻）</li>
<li>读经贵在坚持，然天有不测风云，若因为偶然而来的事情耽误了每日读经，可在随后的周末休假找回时间来补上。相较于第二天读双倍的量，前一种方式更合理一些。</li>
</ul>
<h3 id="得胜读经计划">得胜读经计划</h3>
<p>听上去就让人舒服，我们为主祈福期盼美好得胜人间，主题一旦相通则尤显亲切​❤️​</p>
<p>这个计划在网上有比较详细的说明，我们接下来会搬运一些优质内容供学习借鉴。也会提供链接去往原文：<a href="http://blog.sina.com.cn/s/blog_a28834cb0101ce6n.html" target="_blank" rel="external">点这里</a></p>
<p>得胜读经计划有三个显著特点：</p>
<ol>
<li>每天读一篇诗篇或箴（zhen）言</li>
<li>一年读两遍福音书</li>
<li>按年代次序通读旧约</li>
</ol>
<p>每天都会读到诗篇或箴言，会让读经的过程显得新意满满。</p>
<p>几点使用建议：</p>
<ol>
<li>任何时候都可以开始：
你可以在一年中的任何时候开始使用你的《得胜读经计划》。现在就从今天的日期开始，只要你在以下的十二个月中很忠心地使用这个计划，就可以读完一遍《圣经》了。</li>
<li>假如你漏读了一天：
有时候因为一些紧急事件或意外事情使你这天不能按计划读经，我们强烈建议你：第二天不要试图一次读两天的计划，这样做只能使进度减慢。撒旦 会借机打击你的信心，使你很容易放弃整个读经计划。我们的建议是：如果你错过了一天，就越过那一天的读经计划，然后，到了周末，或你有了额外的时间，就回 过头来，补上你所漏读的那些读经计划。</li>
<li>写下特别关键的经文：
你可以记下在那一天的读经计划中神特别感动你的关键经文。若这节经文是神要你背下来的，那么你可以在这节经文的边上做一些特别记号，每周至少背一节这样的经文。</li>
<li>记下神对你所讲的话语：
神对他的儿女讲话主要通过《圣经》。假如你没有天天花时间读《圣经》的话，那么你就切断了神引导你的主要渠道。记下在这个月中神对你说话的主要内容，包括与这些话语相关的经文的出处。</li>
</ol>
<blockquote>
<p>最后，具体的计划表是什么呢？</p>
</blockquote>
<p>在我本小姐提供的链接里就有，可以打印出来加以使用效果更好。</p>
<h3 id="罗伯茨读经计划">罗伯茨读经计划</h3>
<p>此法可以帮你系统而又完整地读完一遍旧约圣经和两遍新约圣经。</p>
<p>在网上并没有找到可靠的相关资料，因此此处不再多说。大家可以下载推荐的app，并选择相应的读经计划（包括次法）。</p>
<h3 id="每日与主同行">每日与主同行</h3>
<p>全球销量突破十万本的《每日与主同行》读经计划，是一本深入经文又能引发思想的灵修书。</p>
<p>每一天在此计划中都有一个主题，有一段默想，以及与主同行的指引。可以帮助读者在一年内系统的将圣经读完。帮你对真理有深度全面的概览，扎稳一生信仰的根基。</p>
<p>提供一个在线链接：<a href="http://www.jonahome.net/files02/PI_DailyWalk/gb/index.htm" target="_blank" rel="external">BIBLE</a></p>
<h3 id="麦琴读经计划">麦琴读经计划</h3>
<p>这也是我所选择的读经计划。由十九世纪的一位英格兰牧师名叫麦琴（Robert Murray M’Chenyne）的所制定的。1842年发表，不仅影响了很多人，后来也深深影响了近代的清教徒钟马田牧师和改革宗福音派的斯托德博士。</p>
<p>他的方法是每天读四章经文，早上读一章旧约和一章新约，晚上也读一章旧约和一章新约，而晚上和早上不是连读，他把圣经分为四个开始：</p>
<ol>
<li>
<p>从创世记第一章开始——创世的开始</p>
</li>
<li>
<p>从以斯拉第一章开始——民族的更新</p>
</li>
<li>
<p>从马太福音一章开始——基督的降生</p>
</li>
<li>
<p>从使徒行传一章开始——教会的复兴</p>
</li>
</ol>
<h4 id="家庭敬拜">家庭敬拜：</h4>
<p>第一组即在早上的读经，可作为一个家庭敬拜，从创世记和马太福音开始，即上面的第①和第③项。旧约从创世记到历代志下共有403章，遇到篇章短的要读两章，在365天内读完；新约从马太福音到启示录，再加诗篇共有410章，也在一年内读完。</p>
<h4 id="个人灵修">个人灵修：</h4>
<p>第二组即在晚上的读经，可作为个人单独灵修，从以斯拉记和使徒行传开始，即上面的第②和第④项。旧约从以斯拉记到玛拉基书，（除了诗篇）共有376章，每天一章，一年读完；新约从使徒行传到启示录，再加诗篇和四福音共410章，也在一年内读完。</p>
<p>这样在一年内即可读完一遍旧约、两遍新约和两遍诗篇，并且将新旧约不停的交叉融会在一起，使我们的新生命每天都可以沉浸在新旧两约的恩典中渐渐成长。</p>
<p><a href="http://www.wellsofgrace.com/bible/resources/dujin-intro.htm" target="_blank" rel="external">点开看看</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种读圣经的办法。准确点应该说是计划。圣经的通读，对基督徒来说其意义不言而喻。&lt;/p&gt;
    
    </summary>
    
      <category term="moon" scheme="http://zrdsj.cc/categories/moon/"/>
    
    
      <category term="圣经" scheme="http://zrdsj.cc/tags/%E5%9C%A3%E7%BB%8F/"/>
    
      <category term="读经" scheme="http://zrdsj.cc/tags/%E8%AF%BB%E7%BB%8F/"/>
    
      <category term="生命" scheme="http://zrdsj.cc/tags/%E7%94%9F%E5%91%BD/"/>
    
  </entry>
  
  <entry>
    <title>《用户故事与敏捷方法》读后感1</title>
    <link href="http://zrdsj.cc/2016/09/23/book-review1/"/>
    <id>http://zrdsj.cc/2016/09/23/book-review1/</id>
    <published>2016-09-23T12:44:06.374Z</published>
    <updated>2017-03-10T15:14:12.689Z</updated>
    
    <content type="html"><![CDATA[<p>跟这本书的渊源，可以追溯大三的上半学期。当时在接触github的时候也得知了一位大神:<a href="https://www.phodal.com/" target="_blank" rel="external">phodal</a>。</p>
<a id="more"></a>
<p>一位芬达君2333，这位芬达君的技术很厉害，年纪轻轻却拥有令人惊叹的IT技能树。而且芬达君除了自己的工作以外，似乎在开源文化方面格外有所向往。</p>
<p>不再多说大神的事情，说说我和大神的故事。微博私信过大神几次，都得到了鼓励与帮助。。。后来大神搬家在微信上搞了个送书活动，你付邮费大神给你送书。。。我当时本想得一本《<a href="https://book.douban.com/subject/3224524/" target="_blank" rel="external">代码之美</a>》，因缘差错最后是得了这本《<a href="https://book.douban.com/subject/4743056/" target="_blank" rel="external">用户故事与敏捷方法</a>》。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1610-1611/yhgsymjff.jpg" alt="用户故事与敏捷方法"></p>
<p>由此，开始将今天第一阶段的读后感。。。</p>
<h3 id="这么点动静">这么点动静？</h3>
<p>自己拿到这本书蛮久了，却一直没怎么碰过其实。。。没什么动静确实是。。。</p>
<p>接下来打算写七篇类似的读后感，分别对应了这本书的21个章节（四大部分）</p>
<ul>
<li>第一部分 <strong>起步</strong> 1-7章</li>
<li>第二部分 <strong>估算和计划</strong> 8-11章</li>
<li>第三部分 <strong>经常讨论的话题</strong> 12-16章</li>
<li>第四部分 <strong>一个完整的实例</strong> 17-21章</li>
</ul>
<p>是第一部分2篇，第二部分1篇，第三部分2篇，第四部分2篇。计划大概就是这样。然后说说我到底想谈些什么？</p>
<h3 id="我到底想谈些什么">我到底想谈些什么？</h3>
<p>博客的标题是读后感，实际上这本书我并不是看完了才写的博客，而是看了第一部分才写的博客。说读后感的话，其实说是读书笔记或心得更合适点。</p>
<p>内容上来说，这本书并不是纯粹的技术类书籍，也许不会让你xx天精通xxx也不会让你深入浅出XXXX更不是XxXx权威指南给你指引道路。。。</p>
<p><code>这本书从一个独特的角度，对于开发人员测试人员产品分析人员管理人员等等，总之就是一个软件开发团队的所有人员，都有独特的启发和建议。</code></p>
<p>软件开发的知识，在我的大学后来专业课上是有专门的课程去讲些十年前二十年前几十年前的理论知识。且不说&quot;纸上得来终觉浅&quot;，也不说大的环境下的国内外的差异，单是时代的变换与发展，就决定了这个行业的故事，并不传统！</p>
<p>这样的技术或者说是能力，在我看来是硬技能的拓展并具有相当规模的软技能的影子。《用户故事与敏捷方法》就这样一本书—&gt;<code>为软件行业提供了一种节省时间和消除重复工作的需求管理方法，对开发更优秀的软件起着积极高效的作用</code>。</p>
<p>谈些什么？</p>
<p>不会是书里面的详细内容搬运，因为那样不如我提供一个在线的阅读或是一个电子版的下载。。。会是什么？<strong>是对于其中重点的概括介绍和名词释义。</strong></p>
<h3 id="扯不下去写出的读后感1">扯不下去写出的读后感1</h3>
<p>😂</p>
<p>1-3章：</p>
<ol>
<li><strong>概览</strong>：讲述’用户故事’的由来，并且介绍’用户故事’的过程与细节。</li>
<li><strong>编写故事</strong>：对故事更深的理解和举例讲述。</li>
<li><strong>用户角色建模</strong>：'用户角色’的一些故事</li>
</ol>
<h4 id="1111111111">1111111111</h4>
<p>软件需求是一个沟通问题。（不是我zhuangbi，在初三的那个暑假，在家看&lt;超人&gt;电视剧时候就为剧中的异国风情深深感动。当时跟一位好兄弟cgg说过的，自己觉得家庭和生活中的几乎所有不幸福，都是来源于沟通。2333）</p>
<p>软件的使用人员（包括有需求的所有角色，即使是销售人员）必须与开发者进行交流。一个项目的成功，依赖于很多不同的信息，这些信息来自于不同的人员：一方是<code>客户用户（有时还有分析人员领域专家及组织视角来观察审视软件的人）</code>另一方则是<code>开发技术团队</code>。</p>
<p>Balance是十分必要的，倘若上述的两者任何一方在沟通中把持绝对地位，项目都会遭受损失。不再列举哪一方xx的具体所示。</p>
<p>因此我们需要一种协同工作的办法，让双方都不占绝对主导地位，共同面对感情用事和办公室政治化的资源分配问题。。。</p>
<p>此外还有个问题是客观存在的，当用户看到早期版本的软件，也许新的点子就会出现，导致他们会改变自己的观点。由于这种不可控性再加上其他的因素，导致在软件开发的世界里无法勾勒出一幅完美的<a href="http://baike.baidu.com/link?url=U6arOehD5i9imDLqwvabV-Aabwpe7aNk_xuaiFRQ5xMdNFcTfRg2MLjLV7zn0N9tBf3kezc21fnLEaEtqEgGm_" target="_blank" rel="external">PERT图</a>来展示项目中所必须完成的事情。</p>
<p>So，我们该怎么办？答案是：<code>确保有一个&quot;尽量完美的&quot;获取信息过程，越早越好越频繁越好。。。</code>为此，<a href="http://baike.baidu.com/link?url=3dpOTVo3BjrHM6rUfurw77TWbdV471D9JYHRK-migWaO3spNdBwxRmuQcQUGiv3cGlvFNai-Ktgc0cRdF8-2_TCOWijkuO9SeOWNB4uDuy4StN6338M1JDnhb1ykT3_v" target="_blank" rel="external">用户故事</a>应运而生。</p>
<p>用户故事，描述了对用户、系统、软件购买者有价值的功能。由以下三部分组成：</p>
<ul>
<li>一份书面的故事描述，作为计划和提示。<strong>卡片</strong></li>
<li>有关故事的对话，用来具体化故事细节。<strong>交流（对话）</strong></li>
<li>测试，用于表达和编档故事细节且可用于确定故事完成时间。<strong>确认</strong></li>
</ul>
<p>六个问题，书中留下的目录级别问题。。。</p>
<ul>
<li>用户故事谁来编写？</li>
<li>注意哪些细节？</li>
<li>多长时间完成？</li>
<li>故事如何使用？</li>
<li><a href="http://baike.baidu.com/link?url=0SIXceVkMD-HPw0nv1T6NqNKlHGmdRSZQWX2se8eBYhEroSjXVsk9Pewv-ATmp109LGIA47kFr8k3uwrHeJsFT3a4tpoCX-kjJxkKCxPjMnXgJhJaL48oimGZPoUbClz" target="_blank" rel="external">验收测试</a>如何进行？</li>
<li>用户故事迭代过程变化如何理解？</li>
</ul>
<p>希望可以帮助去思考理解真正的&quot;用户故事&quot;！</p>
<h4 id="2222222222">2222222222</h4>
<p>这一章是讲的如何&quot;编写故事&quot;。应该说实际上是在第一章就出现过了，因为书中的第一章确确实实是出现了卡片（用户故事）的编写demo。</p>
<p>'编写故事’有六个特征，一般来说是如下那样：</p>
<ol>
<li>独立的（<strong>I</strong>ndependent）</li>
<li>可讨论的（<strong>N</strong>egotiable）</li>
<li>对用户或客户有价值的（<strong>V</strong>aluable to Purchasers or Users）</li>
<li>可估计的（<strong>E</strong>stimatable）</li>
<li>小的（<strong>S</strong>mall）</li>
<li>可测试的（<strong>T</strong>estable）</li>
</ol>
<p>总结下就是<strong>INVEST</strong>。接下来是不是要逐一的说说呢？</p>
<p>233，我懒就不说具体的每个特征是什么了。但是我总结下我的感想:</p>
<blockquote>
<p>充分考虑了问题的解决之道得来的<code>用户故事编写方法</code>，绝对是饱含了细节、人性化、管理科学、开发经验等重要内容。</p>
</blockquote>
<p>最后再来一点的补充，其实书上的总结。</p>
<ul>
<li>客户团队职责：
<ul>
<li>编写用户故事，这些故事提醒你同开发人员交谈，而不是记录详细的需求定义，它们对用户或你们自己是有价值的，它们是独立的、可测试的、大小合适的。</li>
</ul>
</li>
<li>开发人员负责：
<ul>
<li>帮助编写用户故事。这故事要能提醒你同客户交谈，而不是记录详细的记录定义，故事应该对用户或者客户有价值，它们是独立的，可测得，大小合适的。</li>
<li>如果被询问及实现用户故事所用的技术或者基础架构信息，应该使用对用户或客户有价值的术语来描述。</li>
</ul>
</li>
</ul>
<h4 id="3333333333">3333333333</h4>
<p>在许多的项目中，需求分析人员只是从一个角度分析用户故事，往往容易忽略掉一些需求（故事），因为很多时候有些故事并不针对系统的一般用户。<code>以用户为中心的设计规则会使我们懂得，在编写故事前识别用户角色和虚构人物（person）有很多好处</code>。</p>
<p>你是不是会看不懂上面那段话在bb什么？</p>
<p>通俗的讲就是说，我们为一个人群团体开发一款软件一个项目。我们可以在编写故事的时候去虚拟恰当的用户（实际并不存在，雷同另说），这样的好处在于<code>当你试图去创造有个用户的时候，本身该考虑的事情几乎都会被你考虑。因为你是在工作而不是毫无根据的吹牛逼！</code>这个好处不是在哪看的，书上我也没找着。。。是我自己写的。（书上仅仅是说这样做总是有好处的P34）</p>
<p>还是不明白看看:<a href="http://www.jianshu.com/p/9222a2baebeb" target="_blank" rel="external">这篇简书</a>。希望你会学到更多。。。</p>
<p>角色建模的步骤，这里po出来：</p>
<ul>
<li>通过<a href="http://zhidao.baidu.com/link?url=F3RVrCDWyKxb1qsPZw0U7kOk7p2WZdTkaTvbhnKdr7mSAQphNZpvcJvvSbnY9QHl2aDCeMc_hTm3prn-_1kGIa" target="_blank" rel="external">头脑风暴</a>，列出初始的用户角色集合</li>
<li>整理最初的角色集合</li>
<li>整合角色</li>
<li>提炼角色</li>
</ul>
<p>上面的四个步骤，一般情况下是耗时很短的，2333毕竟是头脑风暴。此外书中也给出了两个值得探讨的’技术’—:<em>虚拟人物</em>与<em>极端人物</em>。留给自己做备注了。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟这本书的渊源，可以追溯大三的上半学期。当时在接触github的时候也得知了一位大神:&lt;a href=&quot;https://www.phodal.com/&quot;&gt;phodal&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="sixpence" scheme="http://zrdsj.cc/categories/sixpence/"/>
    
    
      <category term="经验之谈" scheme="http://zrdsj.cc/tags/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/"/>
    
      <category term="用户故事" scheme="http://zrdsj.cc/tags/%E7%94%A8%E6%88%B7%E6%95%85%E4%BA%8B/"/>
    
      <category term="敏捷方法" scheme="http://zrdsj.cc/tags/%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
</feed>
