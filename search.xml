<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[看不见的美]]></title>
      <url>http://zrdsj.cc/2017/03/15/beauty/</url>
      <content type="html"><![CDATA[<p>本来不存希望 / 心事化作春泥 / 谁人巧言令色 / 使我意马难收</p>
<p>谁说时光最能疗伤 / 谁说旧仇转眼遗忘 / 旧时笑声泪影 / 历历在我心上</p>
<a id="more"></a>
<p>昨日开封晴朗，在学校漂亮的角落里待了一会。</p>
<p>nothing</p>
<p>什么都没感觉到</p>
<p>望着午后轻风阳光安抚的春枝，我似乎意识到了什么。:look:</p>
<h4 id="1">1</h4>
<p>过年的时候，卢总和雪碧谈论到了一些话题。<strong>签证</strong>、<strong>旅游</strong>、<strong>毕业旅行</strong>这些话题，若是我风华正茂， 也会多说上几句ba。那时候，我听了很多，随声附和。</p>
<p>心底里我知道我，一片混沌。</p>
<p>我想去？</p>
<p>我不想去？</p>
<p>说不清，我甚至都想不清。</p>
<h4 id="2">2</h4>
<p>记不得多少次了，在那些文化作品中，<code>草地、鲜花、欢笑、孩子、蓝天、夕阳、村落······</code>这些，总让我陶醉，常常忘记了抑郁已久的情绪。</p>
<p>这些东西，可不就是我内心追寻的么！也是美啊。</p>
<h4 id="3">3</h4>
<p>昨日的午后，我似乎意识到了，</p>
<p>我并不具有正常的情感与渴望。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">生活中从不缺少美，而是缺少发现美的眼睛					——罗丹</div></pre></td></tr></table></figure>
<p>hhh</p>
<h4 id="4">4</h4>
<p>我生命中越来越多的光景，贴上了上帝的标签。蒙主眷顾，我的心扉逐渐打了开来，这一两年间，好了些。</p>
<p>再回到昨日午后的思绪。</p>
<p>我想，我可能是被蒙蔽了。</p>
<p>被，眼前的迷雾，蒙蔽了发现美的眼睛…</p>
<h4 id="5">5</h4>
<p>远近的关系、时空，往往让我们迷失，至少说是怅然若失。</p>
<p>然而，这些看似深刻的事物，并没有多少跃迁性。</p>
<p>所少年前的样子，如今不过是换了新衣服，再次上演。</p>
<p>作为观众，应有的修养当然要有。</p>
<p>若是演员，该有的节操何处去寻？</p>
<hr>
<p>范围或大或小，终究逃不过一双眼，一颗心。</p>
<p>该回应的问题，也许是下顿饭，下次征途。</p>
<p>人性不变，终究道貌岸然，步履虚浮，思想虚妄。</p>
<p>我想，我已不再会去设想盲目与混沌。救赎的事情，这些真理，一直都未走远，我既看得见，就必摸得着。Amen</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1868553&auto=0&height=66"></iframe>]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 诉苦呻吟 </tag>
            
            <tag> 情感 </tag>
            
            <tag> 人生 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Less的若干记述]]></title>
      <url>http://zrdsj.cc/2017/03/10/less/</url>
      <content type="html"><![CDATA[<p><strong><u>什么是<a href="https://github.com/less/less.js" target="_blank" rel="external">Less</a>？</u></strong></p>
<p>一门CSS预处理语言，一切都为CSS更好使。</p>
<a id="more"></a>
<p><u><strong>什么是 CSS 预处理语言？</strong></u></p>
<p>CSS <a href="https://zh.wikipedia.org/wiki/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8" target="_blank" rel="external">预处理器</a>定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。</p>
<p>通俗来讲，“CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题”。</p>
<p>So你可以在 CSS预处理语言中使用<strong>变量</strong>、<strong>简单的逻辑程序</strong>、<strong>函数</strong>等等编程语言中的一些基本特性，可以让其生成的的 CSS <strong>更加简洁</strong>、<strong>适应性更强</strong>、<strong>可读性更佳</strong>，<strong>更易于代码的维护</strong>。</p>
<p>一些 CSS 预处理语言：</p>
<p>CSS 预处理器技术已经非常的成熟，而且也涌现出了很多种不同的 <strong>CSS 预处理器语言</strong>，比如说：</p>
<ul>
<li>Sass（SCSS）</li>
<li>LESS    — ⭐️</li>
<li>Stylus</li>
<li>Turbine</li>
<li>Swithch CSS</li>
<li>CSS Cacheer</li>
<li>DT CSS</li>
</ul>
<p>Less是一种动态的样式语言。Less扩展了CSS的动态行为，比如说，设置变量（<strong>Variables</strong>）、混合书写模式（<strong>mixins</strong>）、操作（<strong>operations</strong>）和功能（<strong>functions</strong>）等等，最棒的是，Less使用了现有的CSS语法，也就是说，你可以直接把你现成的样式文件“style.css”直接改成“style.less”，也能正常工作。</p>
<h3 id="起步">起步</h3>
<p>Less的使用，在不同平台上（服务器端、客户端和集成的第三方环境等等）也不太一样，但一样的是都可以使用。</p>
<h4 id="服务器">服务器</h4>
<p>在服务器上安装Less的最简单的方法是通过npm，node.js包管理器，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g less</div></pre></td></tr></table></figure>
<p>之后是用命令行使用我们的这个CSS编译器了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lessc styles.less</div></pre></td></tr></table></figure>
<p>这将输出编译之后的 CSS 代码到 <code>stdout</code>，将输出重定向到一个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lessc styles.less &gt; styles.css</div></pre></td></tr></table></figure>
<p>若要输出压缩过的 CSS，只需添加 <code>-x</code> 选项。如果希望获得更好的压缩效果，还可以通过 <code>--clean-css</code> 选项启用 <a href="https://github.com/GoalSmashers/clean-css" target="_blank" rel="external">Clean CSS</a> 进行压缩。</p>
<p>执行 lessc 且不带任何参数，就会在命令行上输出所有可用选项的列表。</p>
<h4 id="代码生成">代码生成</h4>
<blockquote>
<p>这部分是我当前不理解的，在我目前的经验中，这种方法并不合理难以体现<strong>更好用</strong>。</p>
</blockquote>
<p>Nodejs的用法，写调用模块的JavaScript即可。例子（来自<a href="http://lesscss.org/" target="_blank" rel="external">官网</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var less = require(&apos;less&apos;);</div><div class="line"></div><div class="line">less.render(&apos;.class &#123; width: (1 + 1) &#125;&apos;, function (e, css) &#123;</div><div class="line">  console.log(css);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>其实结果就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.class &#123;</div><div class="line">  width: 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>手动调用分析器（paser）和编译器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var parser = new(less.Parser);</div><div class="line"></div><div class="line">parser.parse(&apos;.class &#123; width: (1 + 1) &#125;&apos;, function (err, tree) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">    return console.error(err)</div><div class="line">  &#125;</div><div class="line">  console.log(tree.toCSS());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里（官方文档）其实提到了一些工具，第三方的命令行工具，基本没什么必要说。po出在<a href="http://www.runoob.com/manual/lessguide/#using-less-third-party-tools" target="_blank" rel="external">这里</a>。</p>
<h4 id="浏览器">浏览器</h4>
<p>在客户端使用 Less.js 是最容易的方式，并且在开发阶段很方便，但是，在生产环境中，性能和可靠性非常重要， 建议最好使用 node.js 或其它第三方工具进行预编译。</p>
<ol>
<li>在页面中加入 <code>.less</code> 样式表的链接，并将 <code>rel</code> 属性设置为 “<code>stylesheet/less</code>”：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt;</div></pre></td></tr></table></figure>
<ol start="2">
<li>下来，下载 <a href="https://github.com/less/less.js/archive/master.zip" target="_blank" rel="external">less.js</a> 并通过 <code>&lt;script&gt;&lt;/script&gt;</code> 标签将其引入，放置于页面的<code>&lt;head&gt;</code> 元素内：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;less.js&quot; type=&quot;text/javascript&quot;&gt;  -content-  &lt;/script&gt;</div></pre></td></tr></table></figure>
<p>也可以使用一些网站的CDN，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>然后就好了。</p>
<h3 id="使用">使用</h3>
<h4 id="变量">变量</h4>
<p>Less中的变量充许你在样式中的某个地方对常用的值进行定义，然后应用到样式中，这样只要改变你定义的变量参数值就可以达到改变全局的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*======== 定义变量===========*/</div><div class="line">@color: #4d926f;</div><div class="line">/*======== 应用到元素中 ========*/</div><div class="line">#header &#123;</div><div class="line">	color: @color;</div><div class="line">&#125;</div><div class="line">h2 &#123;</div><div class="line">	color: @color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是Less代码，编译成为CSS如下—&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #4d926f;</div><div class="line">&#125;</div><div class="line">h2 &#123;</div><div class="line">  color: #4d926f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Less还有计算功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@nice-blue: #5b83ad;</div><div class="line">@light-blue: @nice-blue + #111;</div><div class="line">#header &#123;</div><div class="line">	color: @light-blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译CSS为—&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #6c94be;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Less定义一个变量名为变量，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@color: #253636;</div><div class="line">@highlight: &quot;color&quot;;</div><div class="line">#header &#123;</div><div class="line">	color: @@highlight;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译CSS为—&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #253636;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>在Less中的变量实际上就是一个“常量”，因为它们只能被定义一次。</strong></p>
<p>Less code；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@color: #253636;</div><div class="line">@highlight: &quot;color&quot;;</div><div class="line">@color: #ff3636;</div><div class="line">#header &#123;</div><div class="line">	color: @@highlight;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Compiled Css code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #ff3636;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="混入">混入</h4>
<p>混入其实是一种嵌套，允许将一个类嵌入到另一个类中，而被嵌入的这个类也称为是一个变量。</p>
<p>换句话说，你可以用一个类定义CSS，然后把整个为当作一个变量来使用，嵌入到另一个类中当作他的属性；另外混入也像一个带有参数的functions，如下在的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*========= 定义一个类 ===========*/			Less code</div><div class="line">.roundedCorners(@radius:5px) &#123;</div><div class="line">	-moz-border-radius: @radius;</div><div class="line">	-webkit-border-radius: @radius;</div><div class="line">	border-radius: @radius;</div><div class="line">&#125;</div><div class="line">/*＝＝＝＝＝＝＝＝＝＝ 定义的类应用到另个一个类中 ＝＝＝＝＝＝＝＝＝＝＝*/</div><div class="line">＃header &#123;</div><div class="line">    .roundedCorners;</div><div class="line">&#125;</div><div class="line">#footer &#123;</div><div class="line">    .roundedCorners(10px);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译过后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#header &#123;							CSS code									</div><div class="line">  -moz-border-radius: 5px;</div><div class="line">  -webkit-border-radius: 5px;</div><div class="line">  border-radius: 5px;</div><div class="line">&#125;</div><div class="line">#footer &#123;</div><div class="line">  -moz-border-radius: 10px;</div><div class="line">  -webkit-border-radius: 10px;</div><div class="line">  border-radius: 10px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>这样任何CSS的类或ID下的样式都可以当作变量，使用混入模式用来当作另一个元素的属性值。</strong></p>
<p>混入(Mixin)有一个名词叫“混入参数（Parametric Mixins）”。Less具有一个特殊类型的规则集，就是一个类可以当作另一个元素的属生值，并且还可以接受其自己的参数。如下的Less</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*========== 定义一个规则，并且不设置默认参数值 ============*/</div><div class="line">.borderRadius(@radius)&#123;</div><div class="line">	-moz-border-radius: @radius;</div><div class="line">	-webkit-border-radius: @radius;</div><div class="line">	border-radius: @radius;</div><div class="line">&#125;</div><div class="line">/*============ 应用到元素中 ============*/</div><div class="line">#header &#123;</div><div class="line">    .borderRadius(10px); 	/*把10px传给变量@radius*/</div><div class="line">&#125;</div><div class="line">.btn &#123;</div><div class="line">    .borderRadius(3px);		/*把3px传给变量@radius*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Complied CSS code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#header &#123;				 /*把10px传给变量@radius*/</div><div class="line">  -moz-border-radius: 10px;</div><div class="line">  -webkit-border-radius: 10px;			</div><div class="line">  border-radius: 10px;  </div><div class="line">&#125;</div><div class="line">.btn &#123;					 /*把3px传给变量@radius*/</div><div class="line">  -moz-border-radius: 3px;</div><div class="line">  -webkit-border-radius: 3px;</div><div class="line">  border-radius: 3px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mixins的参数定义默认值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.borderRadius(@radius:5px) &#123;		/*定义默认是 5px*/</div><div class="line">	-moz-border-radius: @radius;</div><div class="line">	-webkit-border-radius: @radius;</div><div class="line">	border-radius: @radius;</div><div class="line">&#125;</div><div class="line">.btn &#123;</div><div class="line">    .borderRadius;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的CSS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.btn &#123;						/*全部变成5px*/</div><div class="line">  -moz-border-radius: 5px;</div><div class="line">  -webkit-border-radius: 5px;</div><div class="line">  border-radius: 5px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给Mixins不定任何参数，特别是在你想隐藏输出的CSS规则，但又想在别的规则中包含它的属性，使用这种不带参数的Mixins将非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.wrap()&#123;				Less code</div><div class="line">	text-wrap: wrap;</div><div class="line">	white-space: pre-wrap;</div><div class="line">	white-space: -moz-pre-wrap;</div><div class="line">	word-wrap: break-word;</div><div class="line">&#125;</div><div class="line">pre &#123;</div><div class="line">	.wrap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的结果是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pre &#123;		/*wrap()的内容直接混入了pre的样式*/</div><div class="line">  text-wrap: wrap;</div><div class="line">  white-space: pre-wrap;</div><div class="line">  white-space: -moz-pre-wrap;</div><div class="line">  word-wrap: break-word;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Mixins还有一个重要的变量：<strong>@arguments</strong>。</p>
<p>@arguments在Mixins中具是一个很特别的参数，当Mixins引用这个参数时，他将表示所有的变量，当你不想处理个别的参数时，这个将变得有用。以下是一个阴影的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.boxShadow(@x:0,@y:0,@blur:1px,@color:#000)&#123;</div><div class="line">	-moz-box-shadow: @arguments;</div><div class="line">	-webkit-box-shadow: @arguments;</div><div class="line">	box-shadow: @arguments;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#header &#123;</div><div class="line">	.boxShadow(2px,2px,3px,#f36);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译过后的CSS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#header &#123;				/*header全部的样式都变成了boxShadow下的内容*/</div><div class="line">  -moz-box-shadow: 2px 2px 3px #FF36;</div><div class="line">  -webkit-box-shadow: 2px 2px 3px #FF36;</div><div class="line">  box-shadow: 2px 2px 3px #FF36;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="嵌套规则">嵌套规则</h4>
<p>针对一多层元素的样式规则写法，以前我们在多层元素中写样式，要么从头选下来，要么另外给这个元素加上类名或id名，但在Less中我们不需要这样操作了，我们只要使用他的嵌套规则就可以完成。</p>
<p>对于一个结构式这样的HTML来说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;header&quot;&gt;</div><div class="line">	&lt;h1&gt;&lt;a href=&quot;&quot;&gt;WWW.baigle.com&lt;/a&gt;&lt;/h1&gt;</div><div class="line">	&lt;p&gt;封侯非我意，但愿海波平。&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>我们写Less如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  display: inline;</div><div class="line">  float: left;</div><div class="line">  h1 &#123;</div><div class="line">    font-size: 26px;</div><div class="line">    font-weight: bold;</div><div class="line">    a &#123;</div><div class="line">      text-decoration: none;</div><div class="line">      color: #f36;</div><div class="line">      &amp;:hover &#123;</div><div class="line">        text-decoration: underline;</div><div class="line">        color: #63f;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  p &#123;</div><div class="line">    font-size: 12px;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的CSS如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  display: inline;</div><div class="line">  float: left;</div><div class="line">&#125;</div><div class="line">#header h1 &#123;</div><div class="line">  font-size: 26px;</div><div class="line">  font-weight: bold;</div><div class="line">&#125;</div><div class="line">#header h1 a &#123;</div><div class="line">  text-decoration: none;</div><div class="line">  color: #f36;</div><div class="line">&#125;</div><div class="line">#header h1 a:hover &#123;</div><div class="line">  text-decoration: underline;</div><div class="line">  color: #63f;</div><div class="line">&#125;</div><div class="line">#header p &#123;</div><div class="line">  font-size: 12px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见：<strong>使用Less的嵌套规则让CSS代码更简洁，因为写法就是模仿HTML的DOM结构来写的。</strong></p>
<p>从上在的实例代码中，可以清楚的了解到，嵌套规则可以让样式书写时能像DOM树形那样有结构的去写代码，从而减了选择器的层级关系，更主要的是这样使用我们的代码更简洁，更具有阅读性，这种嵌套规则对于操作伪元素更为方便和重要，如:hover，:link,:focus等，其写法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a &#123;</div><div class="line">  color: red;</div><div class="line">  text-decoration: none;</div><div class="line">  &amp;:hover &#123;			/*hover所在行*/</div><div class="line">    color: blue;</div><div class="line">    text-decoration: underline;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a &#123;</div><div class="line">  color: red;</div><div class="line">  text-decoration: none;</div><div class="line">&#125;</div><div class="line">a:hover &#123;</div><div class="line">  color: blue;</div><div class="line">  text-decoration: underline;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里的**&amp;<strong>很重要，在Less中嵌套书写中有没有</strong>&amp;<strong>区别是完全不一样的效果，有</strong>&amp;<strong>时解析的是同一个元素或此元素的伪类，没有</strong>&amp;**解析是后代元素！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  &amp;.fl &#123;			/*伪类*/</div><div class="line">    float: left;</div><div class="line">  &#125;</div><div class="line">  .mln &#123;			/*子元素*/</div><div class="line">    margin-left: 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后的CSS代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#header.fl &#123;			/*与下面的.mln不一样*/</div><div class="line">  float: left;</div><div class="line">&#125;</div><div class="line">#header .mln &#123;</div><div class="line">  margin-left: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数与操作">函数与操作</h4>
<p>有很多元素的属性都具有一定的比例或倍数，那么这两个刚好可以帮我们实现这方面的功能，首先来看Operations（直译“懆作”）。可以对元素的属性值，颜色进行四则运算：加、减、乘、除。而Function就像javascript中的function一样可以让你进行你想要的值的操作。</p>
<p>以下是个综合实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@the-border: 1px;				/*Less code*/</div><div class="line">@base-color: #111;</div><div class="line">@red: #842210;</div><div class="line"></div><div class="line">#header &#123;</div><div class="line">	color: @base-color *3;</div><div class="line">	border: 1px solid desaturate(@red,100%);</div><div class="line">	border-width: @the-border @the-border*2 @the-border*3 @the-border;</div><div class="line">	border-color: desaturate(@red,100%) @red lighten(@red, 10%)	darken(@red, 30%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译过后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #333333;</div><div class="line">  border: 1px solid #4a4a4a;</div><div class="line">  border-width: 1px 2px 3px 1px;</div><div class="line">  border-color: #4a4a4a #842210 #b12e16 #000000;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>Less中的Operations主要是针对任何数字、颜色、变量的操作，可以对其是行加、减、乘、除或者更复杂的综合运算.</strong></li>
</ul>
<ul>
<li><strong>Functions主要是针对Color functions，Less提供了多种变换颜色的功能。</strong></li>
</ul>
<p>先来看Operation的使用。同一单位下的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@base: 5%;</div><div class="line">@filler: @base*2;			/*10%*/</div><div class="line">@other: @base + @filler;	 /*15%*/</div><div class="line"></div><div class="line">#header &#123;</div><div class="line">    color: #888 / 4;</div><div class="line">    height: 100% / 2 + @filler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译的CSS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #222222;</div><div class="line">  height: 60%;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不同单位的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@var: 1px + 5;		/*其实是6px*/</div><div class="line"></div><div class="line">#header &#123;</div><div class="line">    border: @var solid red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译过后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  border: 6px solid #ff0000;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@var: 1px + 5”，Less最终解析的值是“6px”。接下来使用（）改变下运算顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@var: 20px;</div><div class="line"></div><div class="line">#header &#123;</div><div class="line">    width: @var + 5 * 2;</div><div class="line">    height: (@var + 5 ) * 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  width: 30px;			/*20+10 = 30*/</div><div class="line">  height: 50px;			/*25*2 = 50*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>利用百分比来整理颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@base: #f04615;</div><div class="line"></div><div class="line">#header &#123;</div><div class="line">  color: @base;</div><div class="line">  background-color: fadein(@base, 10%);</div><div class="line">  h1 &#123;</div><div class="line">	color: lighten(@base,20%);</div><div class="line">    background-color: lighten(fadeout(@base,20%),5%);</div><div class="line">    a &#123;</div><div class="line">	  color: darken(@base,50%);</div><div class="line">      background-color: spin(@base,10);</div><div class="line">      &amp;: hover &#123;</div><div class="line">	  color: saturate(@base,30%);</div><div class="line">      background-color: fadein(spin(@base,-5),20%);</div><div class="line">	      &#125;</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line">  p &#123;</div><div class="line">    color: desaturate(@base,60%);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译过后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#header &#123;</div><div class="line">  color: #f04615;</div><div class="line">  background-color: #f04615;</div><div class="line">&#125;</div><div class="line">#header h1 &#123;</div><div class="line">  color: #f69275;</div><div class="line">  background-color: rgba(242, 89, 45, 0.8);</div><div class="line">&#125;</div><div class="line">#header h1 a &#123;</div><div class="line">  color: #060200;</div><div class="line">  background-color: #f06b15;</div><div class="line">&#125;</div><div class="line">#header h1 a:hover &#123;</div><div class="line">  color: #ff3e06;</div><div class="line">  background-color: #f03415;</div><div class="line">&#125;</div><div class="line">#header p &#123;</div><div class="line">  color: #a56f60;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="命名空间">命名空间</h4>
<p>有时候想要把一些变量或Mixins组织起来，并封装，想用的时候就把要关的一部分取出来，那么可以将在前面的Mixins基础上将其功能扩展，比如说有一个这样的库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#bundle &#123;</div><div class="line">  .button () &#123;</div><div class="line">	display: block;</div><div class="line">	border: 1px solid black;</div><div class="line">	background-color: grey;</div><div class="line">	&amp;:hover &#123; </div><div class="line">	  background-color: white </div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">  .tab &#123; ... &#125;</div><div class="line">  .citation &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在在实际操作中，header中的a样式和.button一样，那么我们就可以这样操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#header a &#123;</div><div class="line">  color: orange;</div><div class="line">  #bundle &gt; .button;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>换过一种思维来说，如果页面上有几个部分的样是完全一样的，或者只是部分不同，就可以这样来写，就如上面的代码，#bundle可是以web页面中已存在的元素，然后#header中的a元素和#bundle中的.button样式是一样的，那么就可以把#bundle中 .button的所有样式引用到#header中的a元素上。</p>
<h4 id="变量范围">变量范围</h4>
<p>Less中的变量和大部分程序语言一样，他的变量也有一个范围概念，这个概念就有点像局部变量和全局变量一样，只是在Less中采取的是就近原则。</p>
<blockquote>
<p>元素先找本身有没有这个变量存在，如果本身存在，就取本身中的变量，如果本身不存在，就寻找父元素，依此类推，直到寻找到相对应的变量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@var: red;			/*局部大于整体*/</div><div class="line"></div><div class="line">#page &#123;</div><div class="line">  @var: white;</div><div class="line">  #header &#123;</div><div class="line">    color: @var; 	// white</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#footer &#123;</div><div class="line">  color: @var; 		// red  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译过后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#page #header &#123;</div><div class="line">  color: #ffffff;		/*白*/</div><div class="line">&#125;</div><div class="line">#footer &#123;</div><div class="line">  color: #ff0000;		/*红*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="else">else</h3>
<p>Less的用法，在<a href="http://less.bootcss.com/usage/" target="_blank" rel="external">这里</a>可以看到很多，包括了编译器与插件等等。</p>
<p>这里不再进行额外补充。基本上常用的Less语句，都有提及和演示。</p>
<p>参考与鸣谢：</p>
<p><a href="https://www.w3cplus.com/css/less" target="_blank" rel="external">https://www.w3cplus.com/css/less</a></p>
<p><a href="http://less.bootcss.com/#" target="_blank" rel="external">http://less.bootcss.com/#</a></p>
<p><a href="http://tool.oschina.net/less" target="_blank" rel="external">http://tool.oschina.net/less</a></p>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Less </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[响应式设计笔记01]]></title>
      <url>http://zrdsj.cc/2017/03/10/Responsive_Design_notes_1/</url>
      <content type="html"><![CDATA[<p>主要是针对一些学习中出现的一些基本的非基本的问题，当然了全是跟<a href="https://www.zhihu.com/question/20976405" target="_blank" rel="external">响应式设计</a>有关的。</p>
<a id="more"></a>
<p>如何去实现响应式设计，不是要写进本文的内容。更多的是一些响应式实现过程中会遇到的可能遭遇遗忘的问题。</p>
<h3 id="媒体查询与响应式设计的关系">媒体查询与响应式设计的关系？</h3>
<p>媒体查询？</p>
<p>说实在的，不去查资料，我不知道媒体查询就是原来是<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries" target="_blank" rel="external">那种东西</a>。我只知道那样那样去写就可以是响应式设计的实现。不管如何，我们为了专业点，搞清楚总是好的。</p>
<p><strong>媒体查询（Media Queries）是为了做成响应式设计所需的最强大的工具。</strong></p>
<p><a href="http://mediaqueri.es/" target="_blank" rel="external">这里</a>是一些使用了媒体查询的站点，</p>
<h4 id="为什么需要媒体查询">为什么需要媒体查询？</h4>
<p>HTML和CSS可以使页面的样式变得风格化与专一，媒体查询可以让这种表达有更强的针对性，拓展了媒体类型的功能。</p>
<p>媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有<code>width</code>、<code>height</code>和<code>color</code>等。使用媒体查询，可以在不改变页面内容的情况下，为特定的输出设备定制显示效果。</p>
<h4 id="媒体查询的语法">媒体查询的语法？</h4>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#%E8%AF%AD%E6%B3%95" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#语法</a></p>
<h4 id="媒体查询可检测的特性列表">媒体查询可检测的特性列表？</h4>
<hr>
<ol>
<li>width：设备的视口宽度；</li>
<li>height：屏幕宽度；</li>
<li>device-width：设备屏幕的宽度；</li>
<li>device-height：设备屏幕的高度；</li>
<li>orientation：检测屏幕是横向还是竖向；</li>
<li>aspect-ratio：基于视口宽度和高度的宽高比。一个16:9比例的显示屏可以定义为，aspect-ratio：16/9；</li>
</ol>
<ol start="7">
<li>device-aspect-ratio：和aspect-ratio类似，基于设备渲染平面宽度与高度的宽高比；</li>
<li>color：每种颜色的位数。如：min-color：16会检测设备是否支持16位颜色；</li>
<li>color-index：设备的颜色索引表中的颜色书。值必须是非负整数；</li>
<li>monochrome 单色：检测单色帧缓冲区中每像素所使用的位数。值必须为非负整数，如，monochrome：2；</li>
</ol>
<ol start="11">
<li>resolution：检测屏幕或打印机的分辨率，如min-resolution：300dpi。还可以接受每厘米像素点数的度量值，min-resolution：118dpcom。</li>
</ol>
<ol start="12">
<li>scan：电视机的扫面方式，值：progressive（逐行扫描）、interlace（隔行扫描）。 如,720pHD电视（720p的p表明是逐行扫描）匹配scan：progressive，而1080iHD电视（1080i中的i表示隔行扫描）匹配scan：interlace。</li>
</ol>
<ol start="13">
<li>grid：用来检测输出设备是网络设备还是位图设备。</li>
</ol>
<hr>
<blockquote>
<p><strong>说明</strong>：除scan和grid外，都可用min和max前缀来创建一个查询范围。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@import： url（“myphone.css”） screen and (min-width:200px) and (max-width:360px);</div></pre></td></tr></table></figure>
<p>这里对width 应用了min 和max 来设定查询范围。这样myphone.css 文件只会引入视口宽度介于200 像素至360 像素的显示屏设备。</p>
<p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#%E5%AA%92%E4%BD%93%E5%B1%9E%E6%80%A7" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#媒体属性</a></p>
<h3 id="如何引导客户去认识响应式网站">如何引导客户去认识响应式网站？</h3>
<p>设计师在创作设计图时，通常只会考虑固定宽度 “桌面版” 网站，考虑得更多的设计师也许会想到移动端。</p>
<p>客户们的想法往往是这样：客户签字认同了设计图，然后将其交给你、我这样的前端设计师/工程师，之后我们投入时间来确保最终代码在所有主流浏览器中的显示效果与原始设计尽可能接近——<strong>客户所见就是客户所得</strong>。</p>
<p>显然一切不可能是尽善尽美的。客户需要明白为什么应该支持响应式设计，响应式设计的结果如何，为何最终设计不会也不应在所有视口和浏览器中表现一致。有些客户能理解，有些则不能，解决这个问题的唯一方法就是说服引导。</p>
<p>当开始一个新项目时，不论响应式设计是否适合，都应该试着给客户说明以下几点。</p>
<ul>
<li>允许页面显示效果在老旧浏览器中有细微的差别，这样可以使代码更易维护，将来更新的成本也更低。</li>
<li>让页面元素在那些老旧浏览器中表现一致会导致网站增加大量的图片。这会使网站变慢，制作成本变高，而且更难维护。</li>
<li>现代浏览器可以理解的简洁代码等同于更快速的网站。快速响应的网站在搜索引擎中的评级高于慢腾腾的网站。</li>
<li>使用老旧浏览器的用户越来越少，使用现代浏览器的用户越来越多——应该支持大多数！</li>
<li>最重要的一点，<strong>支持现代浏览器，就能尽情地享受响应式网页设计</strong>，它能响应不同设备的不同浏览器视口。</li>
</ul>
<p>last</p>
<blockquote>
<p>在预算允许的情况下，一个完全定制的“移动”版网站比响应式设计更适合。澄清一下，我将那些完全专注移动平台、为移动设备用户提供不同内容/体验的解决方案称之为“移动网站”。提倡响应式设计方法的人，不会都认为响应式设计在任何情况下都可以替代“移动网站”。</p>
<p>使用HTML5和CSS3的响应式网页设计不是解决所有设计和内容服务问题的灵丹妙药。和以往的网页设计一样，项目的具体情况（即预算、目标用户以及网站用途）决定了其实现方式。如果预算有限或开发一个完全定制的“移动网站”不太可行，那么响应式网页设计较之标准的固定宽度设计，总能提供更好的和无歧视的用户体验。</p>
</blockquote>
<h3 id="响应式设计需要百分比布局">响应式设计需要百分比布局？</h3>
<p>仅使用媒体查询来适应不同视口的固定宽度设计，只会从一组CSS媒体查询规则突变到另一组，两者之间没有任何平滑渐变。</p>
<p>当某个视口处于媒体查询设置的固定宽度范围之外（可能是某种未知的未来设备及视口），网页就需要水平滚动才能完整浏览。不过我们想要的是一个灵活的设计，能在所有视口中都完美显示，而不仅仅只针对媒体查询设定的一些固定视口。</p>
<p>我们需要将固定像素布局转换成灵活的百分比布局。这样才能让页面元素根据视口大小在一个又一个媒体查询之间灵活伸缩修正样式。</p>
<h4 id="百分比布局和媒体查询">百分比布局和媒体查询</h4>
<p>使用百分比布局创建流动的弹性界面，同时使用媒体查询来限制元素的变动范围。将这两者组合到一起构成了响应式设计的核心，基于此可以创造出真正完美的设计。</p>
<h4 id="将网页从固定布局修改为百分比布局">将网页从固定布局修改为百分比布局</h4>
<p>固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。</p>
<p>仅使用媒体查询来适应不同视口的固定宽度设计，只会从一组CSS媒体查询规则突变到另一组，两者间没有任何平滑渐变。</p>
<p>需要将固定像素布局转换成灵活的百分比布局，才能让页面元素根据视口大小在一个又一个媒体查询间伸缩修正样式。</p>
<p>将固定像素宽度转换对应的百分比宽度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">目标元素宽度 ÷ 上下文元素宽度 ＝ 百分比宽度</div></pre></td></tr></table></figure>
<h3 id="em-px">em - px</h3>
<p>使用em替代px主要是为了文字缩放。现代浏览器很久以前就支持缩放以像素为单位的文字。</p>
<p><strong>那用em替换px还有什么必要性或优越性呢？</strong></p>
<ol>
<li>即使那些使用Internet Explorer 6的用户也将能够缩放文字</li>
<li>可以使设计师和开发者的生活更简单。em的实际大小是相对于其上下文的字体大小而言的。</li>
</ol>
<p>如果给＜body＞标签设置文字大小为100%，给其他文字都使用相对单位em，那这些文字都会受body上的初始声明的影响。这样做的好处就是：<code>如果在完成了所有文字排版后，客户又提出将页面文字统一放大一点，就可以只修改body的文字大小，其他所有文字也会相应变大。</code></p>
<p>em?</p>
<blockquote>
<p>em是书面形式的大写字母“M”的简称，发音和M相同。以前，“M”常被用来测定某种字体的大小，因为它是英文字母中最大（最宽）的字母。如今，em作为一个测量单位，指的是特定字母的宽度和高度相对于特定字体磅值的比例。</p>
</blockquote>
<p>推荐：</p>
<p><a href="https://www.w3cplus.com/css/px-to-em" target="_blank" rel="external">https://www.w3cplus.com/css/px-to-em</a></p>
<p><a href="https://segmentfault.com/a/1190000005936910" target="_blank" rel="external">https://segmentfault.com/a/1190000005936910</a></p>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 响应式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[上帝的名字]]></title>
      <url>http://zrdsj.cc/2017/03/07/god_name/</url>
      <content type="html"><![CDATA[<p>**读经：**创22：14、出15：26、17：15、士6：23-24、诗23：1、耶23：6、结48：35</p>
<hr>
<a id="more"></a>
<p>在上周的主日礼拜中，主讲张恩惠教士有意无意提到了一个话题，神（上帝）名字的数量。当时他直接给出了答案：<em>是七个不同的名字</em>。</p>
<p>在之后的时间里，我倒是渐渐地记下了这个可供学习的point。</p>
<p>我所谓的学习，当然是要理解贯彻了信仰的阅读与记录。但是对于此类的特性之特殊，我姑且做回引用，依然渴望荣耀我主，阿门。</p>
<h3 id="旧约圣经中神的名字部份">旧约圣经中神的名字（部份）</h3>
<p>圣经中的名字常常有特别意义，来表明那人的特点或与他有特别关系的历史，好像亚伯拉罕的意思是「<code>多国之父</code>」，撒拉是「<code>多国之母</code>」，以色列是「<code>尊荣的王子</code>」，……这些名字不仅有上述的特殊意义，更重要的是<strong>记录神的计划和神的应许</strong>。</p>
<p>神自己的名字更是如此，在圣经中神使用过好多个名字，每个名字都有特别的启示，把神自己向人启示，从神的名字便可以知道神是怎样的一位神，他性情又是怎样。</p>
<blockquote>
<p>没有一个名字可以把神包括起来，因为神的丰盛与无限是一个名字所不容易表达得完整的。</p>
</blockquote>
<p>不信的人以为神有那么多不同的名字，便据此而说圣经不是神的话，而是希伯来人把许多民族的神话累集而成。 <strong>这是无知的话</strong>。</p>
<p>看见神在某一个环境中就用某一个名字，而这名字正好配合那一个环境里所要有的启示，不是随意胡乱使用一个名字。在我有限的属灵生命当中，较早的时候我就体会到了，圣经、基督教信仰、灵修等等事务活动都是在一定的环境当中才得意义。</p>
<p>​	**以罗欣（ Elohim，希伯来文）**是圣经中最先出现的神的名字，中文圣经都把以罗欣翻作「<code>神</code>」。 这名字的意思是大能者，或是信实的大能者，当受敬拜的大能者。 这个名字常常使用在关乎神的创造上，创世记一章全章的「神」字都是以罗欣，是这样一位大能者创造了天地。 在看顾人这一面，神也常用以罗欣这个名字，叫接受启示的人得安息，也享用了安全的保证，因为他是信实的大能者。 创世记五十章廿四节里就是这样使用这个名字。 神这个名字在旧约里使用得最多，从创世记到玛拉基书都使用过这个名字，次数超过了2000次。</p>
<p>​	**耶和华（Yahweh，希伯来文）<em><em>是神的另外一个名字，这</em>道出了神是自自永有者的意思，并且指出了神一面是永有的神，一面又是现在的神。</em> 他固然是一切的源头，但又是时刻供应人的，特别是及时（现在）作人的供应。 神向摩西启示他是耶和华，就是让他知道神有这样的性情，使他可以安心的接受神的差遣。 在关乎救赎的启示上，神常常使用这一个名字（创3： 21 ；出:3： 12 ～ 17）。</p>
<p>​	<strong>阿多乃（Adonai）</strong> ，意思就是我的主，中文的圣经都翻译作「主」，这个意义很明朗，向人启示神就是主，是应当顺服祂的，这明显的指出神就是人顺服的对象。 认识神的人都有这一个学习，因为这是人对神唯一的正确态度，人在神面前出事就是出在不持守这一个正确的态度上（创15： 28 ，18： 3 、 27 、 30 ，20： 4 ；诗篇7： 13 ）。</p>
<p>以上神的三个名字是在旧约中最常见的，在诗篇中也是最多见的。</p>
<p>​	还有另外一个神也用的<a href="https://zh.wikipedia.org/wiki/%E4%BC%8A%E5%8B%92%E6%B2%99%E4%BB%A3" target="_blank" rel="external">名字</a>就是<strong>以勒沙代（El Shaddai）</strong> ，意思是全能的神，神向人这样启示祂自己，要叫人明白在祂那里是样样都有的，什么都不缺。 在亚伯拉罕等候得儿子的事上，神让他看见在不可能的环境中，神还是能的，因为祂是全有全足全丰的神。 人所短缺的，在祂那里还是丰足的，等候祂的人可以放心倚靠祂又取用祂（创17： 1 ～ 8 ，28： 3 ～ 4 ）。</p>
<p>神还用了好些其他的名字，这里不能都提。 但在提过这些名字以后，我们可以因此知道神的性情，更重要的是在那显示出父来的神的儿子身上，这些性情都一一显露，并且透过神的儿子叫我们蒙救赎的人也有份于神的性情（彼后1： 4 ）。</p>
<h3 id="耶和华的复名">耶和华的复名</h3>
<p>神在他自有永有的基础上，也透过了这一些复名更细致的向人启示祂自己和祂的救赎计划的内容。 有人以为耶和华的复名只有六个，有人以为有七个。</p>
<p>这里选择是七个的说法。</p>
<p>篇幅所限，不可能细致的描述耶和华的复名，甚于连神用这些名字启示他自己时的背景也不能提，但这些并不重要，重要的是我们存渴慕的心等候在主前面，让主借圣灵把他自己启示在我们里面，叫我们真认识他，又爱他。</p>
<p>耶和华的复名启示了在整个救赎计划上神供应人的事实，也是关乎神的儿子耶稣基督的工作内容。 按在圣经内出现的次序叫我们可以看到神的计划是如何安排的。</p>
<ol>
<li>
<p><strong>耶和华以勒</strong> （创22： 13 ～ 14 ）</p>
<p><code>“耶和华必为我们预备”</code>—&gt;这是亚伯拉罕献以撒的历史。神试验亚伯拉罕的顺服及他对神的爱心，要他将独生子以撒献上当作祭物，亚伯拉罕完全顺从，证明了他的忠心及对神的爱心，使神的心大满足。于是神预备了一只公羊羔代替以撒作为祭物，所以以撒就不需要死。在这件事里我们知道神的名字是耶和华以勒就是耶和华必预备意思。在这一个过程里，神启示他自己是为那些等候他的人作预备（羊羔）的神，从这名字 “神必预备” 里，使我们注意到，神要预备他自己的独生子作代赎的羔羊来献上，基督就是为我们得完全救赎而献上的燔祭。</p>
<p>在我们的日常生活中，也多次经历了耶和华以勒。另外，在基督徒的生活中我们也要学会顺从神，要有信心、忠心，神必为我们预备一切。</p>
</li>
</ol>
<ol start="2">
<li>
<p><strong>耶和华拉法</strong> （出15：26 ）</p>
<p>“<code>我耶和华是医治你的。”</code>—&gt;这个名字向我们启示那从替代者基督而来的医治恩典。以赛亚曾宣告，他诚然担当我们的忧患（疾病），背负我们的痛苦（疼痛）。（赛53：4）</p>
<p>当以色列人从埃及出来过红海以后，以色列人在旷野玛拉遇到水苦的事，神给他们一个方法来解决他们的需要，那时他们只看见自己的缺乏而吵闹，却没有看见神的大能，神给他们除去了缺乏，神就启示以色列人说耶和华是医治你的神，神就与他们立了约，这是医治的约。因此，耶和华拉法的意思是耶和华医治你的，这个名字向我们启示那从替代者基督而来的医治恩典。</p>
<p>以赛亚先知说：因他受的鞭伤，我们得医治。”(赛53：5)马太福音说：“他代替我们的软弱，担当我们的疾病。”(太 8：17)神医治了我们的灵魂，医治了我们内心的疾病。</p>
</li>
</ol>
<ol start="3">
<li>
<p><strong>耶和华尼西</strong> （出17： 8 ～ 13 ）</p>
<p><code>“耶和华是我的旌旗。”</code>—&gt;胜利、统率。（出17:15）基督在十字架上战胜了一切掌权的。（西2:15）他作为我们的替代者为我们提供了这样的恩典，这样我们就能“感谢神，使我们藉着我们的主耶稣基督得胜。”（林前15:57）</p>
<p>耶和华尼西的意思是耶和华是我的旌旗。这是神为以色列人争战的记录，藉摩西举手仰望神而显出得胜。当亚玛力人与以色列人争战的时候，摩西向天举起双手，以色列就得胜了。这名字的意思就是耶和华是我的旌旗（得胜），表示需要神的帮助。在基督徒的生活中，在我们的里面常常有属肉体和属灵的争战，只有神的帮助才能得胜。我们若信靠神就能胜过肉体、情欲、罪恶、魔鬼。基督在十字架上战胜了一切掌权的，他作为我们的替代者为我们提供了这样的恩典。这样，我们就能感谢神，使我们藉着我们的主耶稣基督得胜。</p>
</li>
</ol>
<ol start="4">
<li>
<p><strong>耶和华沙龙</strong> （士6： 24 ）</p>
<p><code>“耶和华赐平安。”</code>—&gt;它启示给我们救赎的恩典，得享他赐的平安。同样，耶稣也说：“我将我的平安赐给你们。”（约14：27） 这一祝福也是在救赎之中，因为“因他受的刑罚我们得平安”，（赛53：5）借着他在十字架上所流的血成就了和平。（西1：20）</p>
<p>以色列人在米甸人的困扰下，神向基甸显现并差遣他作以色列的拯救，他见了神的面还能存活，神藉此向人启示他自己是赐平安的神，耶和华沙龙意思就是耶和华赐平安，今天许多人在寻找精神和心灵的平安，可是找不着。人只有认识基督，得着救恩，才有真正的平安。《圣经》中主给我们留下了许多关于平安的宝贵应许。意外平安(腓 4：7)、十分平安(赛 26：3)、生命平安(罗 8：6)、长久平安(耶 14：13)。有人曾经数过，《圣经》中“平安”一词用过365次以上，表明一年365天中在主里天天都有平安。耶和华是我的平安，这是恩典内容之一，藉着基督，神把安息供应人。</p>
</li>
</ol>
<ol start="5">
<li>
<p><strong>耶和华锐亚</strong> （诗23： 1 ）</p>
<p><code>“耶和华是我的牧者。”</code>—&gt;耶稣是我们的牧者，“好牧人为羊舍命。”（约10：11,15）因此，这也是救赎带给我们的恩典。</p>
<p>诗篇23篇：</p>
<blockquote>
<p>【诗23:1】（大卫的诗。）耶和华是我的牧者，我必不至缺乏。
【诗23:2】他使我躺卧在青草地上，领我在可安歇的水边；
【诗23:3】他使我的灵魂苏醒，为自己的名引导我走义路。
【诗23:4】我虽然行过死荫的幽谷，也不怕遭害，因为你与我同在；你的杖，你的竿，都安慰我。
【诗23:5】在我敌人面前，你为我摆设筵席；你用油膏了我的头，使我的福杯满溢。
【诗23:6】我一生一世必有恩惠慈爱随着我，我且要住在耶和华的殿中，直到永远。</p>
</blockquote>
</li>
</ol>
<ol start="6">
<li>
<p><strong>耶和华齐根努</strong> （耶23： 6 ）</p>
<p>（齐根努）：<code>“耶和华是我们的义。”</code>—&gt;（耶23：6）耶稣在十字架上担当了我们的罪，由此他成了我们的义，我们接受了他所赐的义，（罗5：17）这是救赎的洪恩。</p>
<p>以色列人背逆神而仍然得神的记念的秘密，就是因为他们献祭的羔羊所预表的基督遮盖了他们，耶和华是我们义，这事到了新约就明显了。基督是我们的义，因为世人都犯了罪，亏欠了神的荣耀（罗3：23）。谁能够除去世人的罪孽？唯独耶稣能够，除了他以外，别无赎罪的救恩。耶稣拯救我们，代替我们死，使我们信而得救。保罗说：“乃是有信基督的义，就是因信神而有的义。”(腓3：9)</p>
</li>
</ol>
<ol start="7">
<li>
<p><strong>耶和华沙玛</strong> （结48：35）</p>
<p><code>“耶和华的所在。”</code>—&gt;它启示给我们救赎的恩典——得享与神的同在。耶稣应许：“我就常与你们同在。”（太28：20）这一祝福来自救赎之工，这一点已得到证实：你们从前远离神的人，如今却在基督耶稣里，靠着他的血，已经得亲近了。（弗2：13）</p>
<p>神与我们同在之处，在以西结书的记载里，这个地方是明明指国度的，也一直伸延到永世，也就是说耶和华在我们中间。主耶和华时刻与我们同在，这是我们最大的福份。有首诗歌说：“耶稣同在就是天堂。”有一位牧师说：“神与我同在，比我与你面对面在一起，更具体，更实在。”神在我们前面引导带领，神在我们后面看顾扶持，神在我们上面拯救眷顾，神在我们下面托住帮助。这就是耶和华的所在。</p>
</li>
</ol>
<h3 id="以罗欣和耶和华">以罗欣和耶和华</h3>
<p><strong>为何在创世记一章里不说耶和华、耶和华神，而只说神呢？</strong></p>
<blockquote>
<p>按原文的意思，神──以罗欣──字即那强有力者。 神这名字，是神对于造物方面说的，是指神在创造方面的关系说的。 耶和华是神与人发生关系的名字。</p>
<p>创世记二章是指神和人的关系，所以立刻说耶和华神；这是因为神同人的关系。 创世记一章没有人(第六日造人，还是注意创造)，所以说神。 创世记第二章有人，所以就说耶和华神。</p>
</blockquote>
<p><strong>每一次用耶和华神，即表明神和人发生关系。 每一次用神，就表明神的能力，和造物发生关系</strong>。</p>
<h3 id="interesting">Interesting</h3>
<p>以下是一些引用：</p>
<ul>
<li>中文的『神』字中文神字左边示字，上横两划表意上天下地，下三竖是日月星。 示字多是属天和属灵等字的部首。 神字右边申字谐音和会意，含义万物和万福是从神引伸出来的。</li>
<li>中文的『神』字神字在中文，是由一个缩写的名词和一个动词合成的。 左边是缩写的「神」字，右边是「申」字，引申的意思。 照说文，神的意思就是「天神引申万物」。 这样在创世记第一章用神字再合适也没有了，因为这一章告诉我们，神怎样创造万物。 当我们每次提到「神」字的时候，让我们记得，宇宙万物是祂创造的啊！ 》</li>
</ul>
<h3 id="我是自有永有的">我是自有永有的</h3>
<p>（出3:14）</p>
<blockquote>
<p>神对摩西说：「我是自有永有的(即耶和华) 。」 (这并非原文的字，这里译得不很好；不过当时译圣经的人，实有难处。因为他们若照原文直译，在中文就不成话。 )若是直译的话，就是：「我是，」「我就是我，」「我是那个，」「我就是那一个。」 「我就是我！」这真不成话。 不过这里面是包括自有永有之意。 我就是我，我就是那个我，译者只能用意译，译出我就是我之意思来。</p>
</blockquote>
<blockquote>
<p>若神在「我是」之下加上「能力」两字，就「我」不是「爱」了。 若加上「爱」字，就「我」是爱，而非能力、智慧、义、圣洁、救赎、安慰、保障、坚固台、避难所了。 神只说祂是…… ，而不说祂是什么，好让信祂的人自己在下面加上字眼， (哦，不是字眼，乃是属灵的实际！ )我们可以按 信心随便加上什么。 我们若有需要，同时并有信心，我们就可以在「神是」之下加上我们所需要的，而得 神补满我们那个需要。</p>
</blockquote>
<p>――倪柝声《耶和华》</p>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基督教 </tag>
            
            <tag> 圣经 </tag>
            
            <tag> 以色列 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue-learn-notes.1]]></title>
      <url>http://zrdsj.cc/2017/03/03/Vue-learn-notes-1/</url>
      <content type="html"><![CDATA[<p>第一篇关于<a href="https://cn.vuejs.org/" target="_blank" rel="external">Vue.js</a>的内容，其官网的内容与文档已经足够nice了，甚至只需要几个浏览器标签都可以学习了。</p>
<p>这里还是想记录些东西，作为一个健忘之人的备忘录罢了。</p>
<a id="more"></a>
<h3 id=""></h3>
<p>hb</p>
<p>wreh</p>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经验之谈 </tag>
            
            <tag> 用户故事 </tag>
            
            <tag> 敏捷方法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[扯不下去的读后感2]]></title>
      <url>http://zrdsj.cc/2017/03/02/book-review2/</url>
      <content type="html"><![CDATA[<p>此篇是借之前某篇博客的续写，系列一共是7篇。本篇是第2篇，第一篇—<a href="http://zrdsj.cc/2016/09/23/book-review1/">http://zrdsj.cc/2016/09/23/book-review1/</a></p>
<a id="more"></a>
<h3 id="4444444444">4444444444</h3>
<p>这一章在书中的标题是：<strong>搜集故事</strong>。</p>
<blockquote>
<p>搜集故事，其实是告诉你如何与用户一起工作，通过互相的沟通来发现故事。熟练使用各种合适的方法，提出恰当的问题，获得用户真正的需求。</p>
</blockquote>
<ol>
<li>
<p>首先要说的是一个错误的想法—<strong>（我们）能够引出及捕捉需求</strong>。</p>
<p><em>引出(elicitation)</em>、<em>捕捉(catch)</em>，好像是捕鱼相关的术语，然而确实在1999年就有需求方面的专家引入了类似的概念[脱网（trawling）<a href="https://en.wikipedia.org/wiki/Trawling" target="_blank" rel="external">https://en.wikipedia.org/wiki/Trawling</a>]来描述收集需求的过程。</p>
<ul>
<li>不同的网用来捕获不同的鱼（需求）。</li>
<li>需求会像鱼一样，会成长会变化还会死亡。</li>
<li>某个区域进行拖网捕鱼不可能捕获所有的鱼（需求）。</li>
</ul>
<p>也就是说，我们可以通过用户故事来规定更为细化合理的职责分配，然而在具体的实施时，技能显得格外重要。就拿本小节的主题<u>需求</u>来说，一个好的需求分析人员(requirements trawler)知道到哪里寻找需求，而不会像新手一样在错误的地方浪费时间。</p>
<p>那么**（我们）能够引出及捕捉需求**这句话哪里错了呢？</p>
<blockquote>
<p>用户并不专业，也不能清楚地向我们解释他们的需求。需求并不是已经存在让用户去感受到并提供给我们（产品or开发）。</p>
<p>需求是可变的，不是一成不变的。及时找到了满意的需求并加以满足，但迭代的开发进行过后，需求会不会不再是需求？会不会膨胀？</p>
</blockquote>
</li>
<li>
<p>敏捷过程简单的方法之一，是<strong>辨别传统规范过程中搜集需求的方式</strong>！</p>
<p>传统规范过程的特征是它过分强调在项目早期正确地获取并写出全部的需求。敏捷项目并不要如此，敏捷过程也承认并没有一种理想的方法可以在一个单一阶段获取得到所有用户的用户故事。</p>
<p>即使如此。。。</p>
<p>我们还是应该在早期尝试编写我们可以编写的故事，即使是在十分笼统的阶段。</p>
<p>即：</p>
<blockquote>
<p>敏捷流程支持需求的后期涌现，依然需要对预期的发布进行展望并开始写下容易发现的故事。</p>
</blockquote>
</li>
<li>
<p>一些可以反复进行用户故事收集的方法。<strong>用户访谈</strong>、<strong>问卷调查</strong>、<strong>观察</strong>、<strong>故事编写工作坊</strong>。</p>
<ul>
<li><code>用户访谈</code>：大部分团队用来获取用户故事的默认方法。成功的关键在于是否选择到了正确的受访者。同时进行访谈时提问的技巧也很影响成功率，问题的选择是关键。</li>
<li><code>问卷调查</code>：这是另一种有效的方法，尤其在面对大规模的用户群体时，问卷调查显得格外有用。值得一提的是，问卷调查不适合作为脱网捕捞新故事的主要方法。主要是因为这是一种单向的静态问卷，不方便立即对用户的想法进行深入探讨。</li>
<li><code>观察</code>：唯一的缺点是能够产生的实际观察机会太少。优点是可以快速直接从用户处得到反馈，从而更早更频繁地发布软件。</li>
<li><code>故事编写工作坊</code>：理想情况下将各种与编写故事有帮助的人们聚集起来进行的会议。开发人员，用户，产品，客户等等都可以。每个人都尽可能多的编写要写的故事，在短时间内即可将产品的原型塑造。理想情况下，这种方式是最容易获取用户故事的。唯一的缺点在于，理想情况并不容易达到。</li>
</ul>
</li>
</ol>
<h3 id="5555555555">5555555555</h3>
<p>这一章在书中的标题是：<strong>与用户代理合作</strong>。</p>
<p>项目是做给别人的，准确来讲是做给客户的。客户团队因此必然显得举足轻重。</p>
<p>在客户团队中，拥有一个或者几个实际用户（真实用户）是重要的，遗憾的是我们很难有机会与实际用户一起工作，当我们无法求助于实际用户时候，我们就得求助于用户代理（user proxy)，他们代表着用户。</p>
<p>选择合适的用户代理对于项目的成功至关重要，要考虑潜在用户代理的背景和动机，不同领域的专家作为用户代理，是有差异的。</p>
<h4 id="用户的经理">用户的经理</h4>
<p>作为一个开发，你也许不会接触到很多的用户，却可能会接触到用户的经理，因为其代表着用户的立场可以讲作是用户代理。但是，<strong>如果用户的经理不是产品的实际用户，ta就不会是合适的用户代理</strong>。就不必为此上调其话语的优先级。</p>
<h4 id="开发经理">开发经理</h4>
<p>开发经理会试图担任用户代理，因为他们依然参加到了项目每天的细节之中。然而开发经理大多不是产品的用户，所以他们也不是理想的用户代理。</p>
<p>开发经理的立场不是用户甚至也不是企业的立场，他们也没有用户的亲身体验也不是领域专家。当然，如果其本身也是用户的话，一切处理当有所调整。</p>
<h4 id="销售人员">销售人员</h4>
<p>基本沿袭了老毛病。<strong>结论是：销售人员充当用户代理是危险的。</strong></p>
<p>销售人员必须避免把重点放在那些可以重新赢得已失去订单的故事上，在此基础上凭借着自己与用户的有效沟通，才可以很好的开发项目。</p>
<h4 id="领域专家">领域专家</h4>
<p>就是指那些主题专家，他们对软件应用领域的了解程度直接影响了软件的成败。尽管，在领域专家的丰富资源中，看似可以大加利用。实际上，<code>避免将产品开发成只适合那些与他们有相同水平的用户使用</code>才是重点。</p>
<h4 id="客户">客户</h4>
<p>你会不会感到惊讶？wtf？客户？</p>
<p>对的，我说的就是客户。</p>
<blockquote>
<p>在这里，我们所说的<u>客户</u>，和<u>用户</u>不一样的。</p>
</blockquote>
<p>作为做出决定购买决定的人，如果他们能与用户密切地交流，那么他们会是优秀的用户代理。如果他们本身也是用户，完美！（强无敌233</p>
<h4 id="else_1">else_1</h4>
<p>有一些培训师，业务分析师，系统分析师什么的，这些角色的问题也在于缺点的过于暴露。</p>
<blockquote>
<p>“术业有专攻”</p>
</blockquote>
<p>这些人员往往更关心产品（软件），而不是如何代表用户。</p>
<h4 id="else_2">else_2</h4>
<p>q:作为开发人员，这个过程我的职责是什么？</p>
<p>a:负责帮助组织机构为项目物色合适的客户。+负责了解不同类型的用户代理怎么考虑正在开发的产品。</p>
<p>q:负责客户的团队该干啥？</p>
<p>a:了解自己是属于哪类用户代理+了解自己作为用户代理可能存在的问题并加以防范克服。</p>
<h3 id="6666666666">6666666666</h3>
<p><strong>用户故事验收测试</strong>，标题如此，不难想象是要我们做什么。</p>
<p>一般来说，这个测试分为两个流程：</p>
<ol>
<li>将测试要点记录在股市卡的背面，任何时候发现新的测试，都可以记录在故事卡的背面</li>
<li>将测试要点变成全面的测试，这些测试可以用来掩饰故事已正确、完整地实现。</li>
</ol>
<p>要知道，验收测试可以将客户与开发人员之间讨论沟通的很多细节记录（虽然这些细节一部分是假设），但是测试也提供了检查故事是否完整的一个标准，这样我们便可以知道什么时候某件事情是做完了，这几乎是避免花费太多或太少时间精力的最好方法。一个书中的例子：</p>
<blockquote>
<p>我的妻子在烤蛋糕，她的验收测试是在蛋糕内插一个牙签。如果牙签是干净的，蛋糕就是完成了。如果是“wo”，也许是吃下去才知道呢。</p>
</blockquote>
<p><em>测试应该在写代码之前进行，由客户来编写。</em></p>
<p>这样做的好处，可以避免程序员的出错（更合理的说法是正确认识功能的开发）。</p>
<p>开发人员与湖库的职责分配：</p>
<ul>
<li>开发人员
<ol>
<li>负责自动化验收测试</li>
<li>新故事开始的时候，负责更多的验收测试</li>
<li>负责为代码做单元测试，是验收测试不必顾及故事的每个细节</li>
</ol>
</li>
<li>客户职责
<ol>
<li>负责编写验收测试</li>
<li>负责执行验收测试</li>
</ol>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经验之谈 </tag>
            
            <tag> 用户故事 </tag>
            
            <tag> 敏捷方法 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[apm npm nvm cnpm都是什么鬼?]]></title>
      <url>http://zrdsj.cc/2017/02/22/apm_npm_nvm_cnpm/</url>
      <content type="html"><![CDATA[<p>来给自己普及下基本的几种工具的事情。</p>
<p>其实也不是那么有必要po出这么一篇，实在是，，，po主是太健忘。过上俩月，基本见面跟新的一样。。。wc，不敢想。</p>
<a id="more"></a>
<h3 id="apm">apm</h3>
<p>apm是啥啊？</p>
<blockquote>
<p>“我是搞node的，知道npm。这个apm呢······”</p>
</blockquote>
<p>还好你知道npm，hhhhhhhh</p>
<p>我想这么“简单”的东西，不会有人写博客来告诉你做什么怎么做了吧。似乎真是事实。</p>
<p>我们去Atom编辑器的官网上看看，就在 <a href="https://atom.io/" target="_blank" rel="external">https://atom.io/</a> 。点击<strong>Documentation</strong>:</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/atom-doc.jpg" alt="shenmegui"></p>
<p>搜索关键词：<strong>apm</strong>。结果就是那个所谓的<em>PackageManager</em>。。。</p>
<p>参考下npm (全称Node Package Manager，即node包管理器）是<a href="https://zh.wikipedia.org/wiki/Node.js" target="_blank" rel="external">Node.js</a>默认的、以<a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="external">JavaScript</a>编写的<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1" target="_blank" rel="external">软件包管理系统</a>。)，很容易理解我所指的apm了。</p>
<blockquote>
<p>就是Atom编辑器的包管理器。</p>
</blockquote>
<p>用过Atom编辑器的话，你会知道这个apm是集成进了Atom安装包的，默认自带。再有多点了解的话你可能会点击GitHub的网站上看看这apm是个嘛玩意？传送门：<a href="https://github.com/atom/apm" target="_blank" rel="external">XXX</a></p>
<p>这一部分说的很清楚，只是全英文的阅读是有些难度的。。。<a href="https://github.com/atom/apm#apm" target="_blank" rel="external">https://github.com/atom/apm#apm</a>—atom-package-manager</p>
<p>至此，apm的事情就说完了。。。更多相关的学习，<a href="https://atom-china.org/" target="_blank" rel="external">https://atom-china.org/</a> Atom的中文社区，希望浏览的你可以有所收获。</p>
<h3 id="npm">npm</h3>
<p>这部分，我其实是拒绝的。我很想把官网的文档链接贴出来，留下句：“自己看吧” 就拍拍屁股走人的。结果，我拍拍屁股又回来了。</p>
<p>中文维基百科里面介绍了npm的前世今生，看这里 <a href="https://zh.wikipedia.org/wiki/Npm" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Npm</a> 。看上两遍，在有些nodejs基本认识的话，就很清楚了。</p>
<p>这个地方—<a href="https://docs.npmjs.com/" target="_blank" rel="external">官方文档</a>，你值得去看看（非常详细，但是全英文）。无论你是如何的使用npm，更不用说你和po主一样健忘类型的2333</p>
<p><strong>那么</strong>，node（npm）用户比atom（apm）用户要多得多，node用户都在用“npm”来做开发，那么。。。为啥不先讲npm呢？</p>
<blockquote>
<p>apm的规模不如npm，其使用模式却是和npm如出一辙。所以将apm一笔带过，在npm的论述上着重bb，在apm的理解上照旧就可以了。</p>
</blockquote>
<p>npm随着nodejs自动安装，在使用上也是依托命令行即可。</p>
<blockquote>
<p>在一个项目中存在package.json文件，那么即可使用<code>npm install</code>命令行自动安装维护项目所需的模块。在<code>package.json</code>文件中，开发者可以指定每个依赖项的版本范围，这样既可以保证模块自动更新，又不会因为所需模块功能大幅变化导致项目出现问题。开发者也可以选择将模块固定在某个版本之上。</p>
</blockquote>
<h4 id="">—</h4>
<p>以<em>express</em>为例，看看一个npm包都咋回事啊？？？</p>
<ol>
<li>在<a href="https://www.npmjs.com/" target="_blank" rel="external">npm官网</a>搜索到<a href="https://www.npmjs.com/package/express" target="_blank" rel="external">express框架</a>，这是一个快速简约的Web框架。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/express-pic.jpg" alt=""></p>
<ol start="2">
<li>
<p>继续浏览，可以看到使用的命令行说明，功能特性的更新等等。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/express-use.jpg" alt=""></p>
</li>
<li>
<p>是不是觉得我会把那个<a href="https://www.npmjs.com/package/express" target="_blank" rel="external">网页</a>接下来的每一项都给截图说明讲解？</p>
<p>，，，，，，</p>
<p>------不会的！😢</p>
</li>
</ol>
<ol start="4">
<li>接下来的说明也都是围绕着<em>express</em>框架的使用来进行的。文档、社区、安全问题、快速上手、原理、示例、测试等等一应俱全。也就是说，<strong>所有你在</strong><a href="https://www.npmjs.com/" target="_blank" rel="external">https://www.npmjs.com/</a><strong>找到的包</strong>，<strong>都会有类似的说明指导页面</strong>。</li>
<li>其实你若知道一些包的名称，直接谷歌得到的往往就是你要的。。。比如说<em>express</em>的google结果就是<img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/express-google.png" alt="233"></li>
</ol>
<h3 id="nvm">nvm</h3>
<p><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>是全称Node Version Manager，是专门管理不同版本的nodejs和npm的工具。这个工具是Mac下的专属工具，Windows的话可以使用<a href="https://github.com/hakobera/nvmw" target="_blank" rel="external">nvmw</a>或者<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">nvm-windows</a>.</p>
<p>那么我现在面临一个选择------我是继续说nvm?还是说Win平台的nvmw和nvm-windows?</p>
<p>我也不知道。</p>
<p>把每一个都提一下好了，毕竟自己的记性在那摆着，多写点也是有好处。</p>
<p>233</p>
<h4 id="nvm">nvm</h4>
<p><strong>nvm 不是一个 npm package，而是一个独立软件包。</strong></p>
<p>安装方式有两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</div></pre></td></tr></table></figure>
<p>以上脚本会把<code>nvm</code>库clone到<code>~/.nvm</code>，然后会在<code>~/.bash_profile</code>, <code>~/.zshrc</code>或<code>~/.profile</code>末尾添加source，安装完成之后，你可以用以下命令来安装node…</p>
<p><a href="https://github.com/creationix/nvm#usage" target="_blank" rel="external">https://github.com/creationix/nvm#usage</a></p>
<p>（逃</p>
<h4 id="n">n</h4>
<blockquote>
<p>你：这tm哪来的？是啥？</p>
</blockquote>
<blockquote>
<p>我：…</p>
</blockquote>
<p>其实讲到nvm其实是想说说node管理工具吧，哈哈。。。既然nvm只是支持Mac，那就说一个都支持都可用的—<a href="https://github.com/tj/n" target="_blank" rel="external">n</a>.</p>
<p>首先n 是一个需要全局安装的 <strong>npm</strong> 包(package)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g n</div></pre></td></tr></table></figure>
<p>这意味着，我们在使用 n 管理 node 版本前，首先需要一个 node 环境。</p>
<p>然后我们可以使用 n 来安装不同版本的 node。</p>
<p>在安装的时候，n 会先将指定版本的 node 存储下来，然后将其复制到我们熟知的路径 <code>/usr/local/bin</code>，非常简单明了。当然由于 n 会操作到非用户目录，所以需要加 <code>sudo</code> 来执行命令。</p>
<p>所以这样看来，n 在其实现上是一个非常容易理解的方案。</p>
<h4 id="n-or-nvm">n or nvm?</h4>
<p>这样看下来，nvm 和 n 的差异还是比较大的，具体体现在：</p>
<ol>
<li>安装简易度。nvm 安装起来显然是要麻烦不少；n 这种安装方式更符合 node 的惯性思维。见仁见智吧。</li>
<li>系统支持。注意， nvm 不支持 <a href="https://zh.wikipedia.org/zh-cn/Microsoft_Windows" target="_blank" rel="external">Windows</a>.</li>
<li>对全局模块的管理。n 对全局模块毫无作为，因此有可能在切换了 node 版本后发生全局模块执行出错的问题；nvm 的全局模块存在于各自版本的沙箱中，切换版本后需要重新安装，不同版本间也不存在任何冲突。</li>
<li>关于 node 路径。n 是万年不变的 <code>/usr/local/bin</code>；nvm 需要手动指定路径。</li>
</ol>
<p>所以，如何选择？见仁见智了，不过这里可以给出大体的建议：</p>
<ol>
<li>如果你使用 Windows，那没得选了，使用 n，或者换一台 Mac。</li>
<li>如果你会频繁切换 node 版本（比如本地经常测试最新版的特性，同时又要兼顾代码在生产环境的兼容性），那么从全局模块兼容性的角度考虑，只能使用 nvm。</li>
<li>如果你是一个轻量级的用户，不需要担心兼容性的问题，更关心 node 安装和使用上的体验，那么选择 n。</li>
</ol>
<p>参考出处—<a href="http://taobaofed.org/blog/2015/11/17/nvm-or-n/" target="_blank" rel="external">aaaaaaaaaa</a>.</p>
<h4 id="nvmw">nvmw</h4>
<p>这玩意相比nvm多了个w，其实就表达了这是在Windows平台使用的—Node.js版本管理工具。</p>
<p>这种玩意的官网一般没什么用（有没有都是一回事2333），直接在GitHub上看看去吧。。。<a href="https://github.com/hakobera/nvmw" target="_blank" rel="external">https://github.com/hakobera/nvmw</a></p>
<p>很不幸，在下方的README.md我们看到了这样一句话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SORRY, nvmw is no longer maintained. If someone wants to keep maintained, contact me by email or twitter.</div></pre></td></tr></table></figure>
<p>不再维护了，hehe.</p>
<p>不过呢，不维护有不是不能用了。。。继续看看吧</p>
<p>好的，</p>
<p>安装-用法-支持列表-镜像列表（好评啊，哈哈知道在瓷器国不能用2333）</p>
<p>这个项目已经是2年没有更新了，使用上可以预见的都是问题（主要是win作为开发平台我是不看好的）233</p>
<p>在<a href="https://segmentfault.com/" target="_blank" rel="external">Sf</a>找到了<a href="https://segmentfault.com/a/1190000004855835" target="_blank" rel="external">这篇文章</a>，也许是有些帮助的。需要的话，大家可以看看。</p>
<h4 id="nvm-windows">nvm-windows</h4>
<p>也就是一般说的<code>nvm for windows</code>，<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">链接</a>.</p>
<p>说到这里，如果还说用法和内容的话，没什么意思了。。。从apm讲到这里，其实都是一个样式的用法安装（我觉得可以这么说，虽然很不严谨）。</p>
<p>不再赘述，本小节的链接就很详细（全是英文233）.</p>
<h3 id="cnpm">cnpm</h3>
<p>俗称淘宝镜像。谷歌出的第一个结果是这个链接：<a href="https://npm.taobao.org/" target="_blank" rel="external">https://npm.taobao.org/</a> .</p>
<p>是个中文界面，剩下的不再说了。</p>
<p>其实就是npm在国内的网络环境下经常抽风不起作用，搭梯子也是不好使。然后国内的一些站点就引入了国外npm站点的全部资源，整个全给拷贝过来，然后呢这些国内站点就被称为<code>npm镜像资源</code>.</p>
<p>这些镜像资源的主页，大都是中文，很好理解与使用。</p>
<p>博客参考过的参考的几个页面：<a href="http://yijiebuyi.com/blog/b12eac891cdc5f0dff127ae18dc386d4.html" target="_blank" rel="external">1111</a>，<a href="http://riny.net/2014/cnpm/" target="_blank" rel="external">2222</a>。</p>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
            <tag> Atom </tag>
            
            <tag> 版本工具 </tag>
            
            <tag> npm </tag>
            
            <tag> nvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭衣服想起的事情---国旗下的演讲]]></title>
      <url>http://zrdsj.cc/2017/02/19/speech-under-the-flag/</url>
      <content type="html"><![CDATA[<p>部署的最后一刻我仍觉得，这篇博客应该发成微博比较好，甚至是朋友圈的分量，都会好一些。</p>
<a id="more"></a>
<p>在第二实验小学的六年间，度过了所谓的童年。很多事情影响了后来的自己，这也是废话扯一下。要说的事情，其实是童年国旗下的演讲。</p>
<h3 id="演讲">演讲</h3>
<p>演讲的形式，是在每周一的早晨全校升国旗时候。国旗台前边总会有个孩子，拿着话筒郎朗上口地朗诵一篇《国旗下的演讲》。我清楚地记得每个人的第一句永远都一样，是：“老师好，同学们大家好，我是xx年纪x班的xxx,我今天国旗下演讲的题目是《Hello World😄》”，很单纯的套路，很单纯的年纪。</p>
<p>演讲是3-6（之前是5，有了6年级就是3-6了）年级，每个班轮流准备一名“演讲员”。我们每个年级只有两个班（二小规模小，后来证明仅仅是规模小，不耽误nb），所以每两个月总是能循环个一圈。</p>
<p>到我最终毕业成为初中生，我都没见过太多的同学登上这个台子。基本上这个任务是全班前3、4名的轮流任务，虽然他们不情愿（但别人也是不情愿），极少数情况下也有毛遂自荐的同学，一旦有人自荐，我看不到老师应有的欣喜反倒是那些本不愿演讲却被指派的同学会喜乐无比。（可能我还是太年轻，真的不懂得为什么老师不欣喜真心想演讲的同学）</p>
<h3 id="正题">正题</h3>
<p>在今天下午洗衣服的时候，我突然想到了旧时听了多次的一个<strong>国旗下的演讲主题</strong>。</p>
<p>很显然，<code>珍惜时间</code>是个好话题，如果是打鸡血催化信心，这个话题适合任何行业的任何级别的实际操作。因为我们没有无限的精力和时间。</p>
<p>是这样的：</p>
<p>我记得，很多次的演讲都是这个话题。这不奇怪。</p>
<p>我还记得，这个话题的多个演讲都有这样一个故事，穿插其中。</p>
<blockquote>
<p>是说有个人，怎么怎么样的碰到了一些mo法，可以让他返老孩童的一些事情。</p>
<p>这个人的设定是年纪很大的loser，这个人祈求啊求助啊，希望可以turn back time，可以一切再重来，可以再度活过。以便努力一波，成就新的成功人生。</p>
<p>返老孩童，多么浪漫的故事。</p>
<p>结局就是这个人又一次的生命中，依然浪费时光贪玩懒惰之类的。。。最后呢，又是一个老loser。。。</p>
<p>。。。。。。</p>
</blockquote>
<p>在有些版本中，这个返老孩童turn back time的次数甚至到了34次，不变的是。。这个主人公的结局，都是依然悲惨。</p>
<h3 id="so">so?</h3>
<p>那个时候，每年都要听上几遍这个故事。当时并没有很多的想法啊，只会感觉：啊，真的是要好好珍惜时间啊，人生短暂时间一去不返…之类的。。。</p>
<p>在今天下午，我想到这个事情的时候。</p>
<p>我在想，我为什么不是：<code>在当时和小伙伴们讨论下这个呢？深入思考一下为什么故事的结局是这个人反反复复一事无成，还觉得很合理呢？反思呢？</code></p>
<p>不知道看到这里的你，是否明白了我的意思呢？</p>
<p>这个事情，真的是细思极恐！<strong>可能</strong>是这个故事中的人有问题吧，才会反反复复如此low；也<strong>可能</strong>是这个人本身就是个zz，只知道happy &amp;&amp; lazy，最后loser了；还是说这故事本身有毒，就是告诉你对于大部分人来说，你就是那主人公，给你多少机会都是。。。。。。</p>
<p>stop！</p>
<p>停下来了，不再无休止的yy了。真的没什么用唉</p>
<p>多想这是个段子，笑一笑，结束了。。。</p>
<p>之所以会写这么多没用的事情，恐怕是在现实中找到了故事中的那个人的影子吧。想想看，作为号称有着智慧的人们，其中的一部分要是真的被返老孩童，恐怕以后还是那个b样吧。</p>
<p>相由心生，境由心造。不改变内心，何谈改过自己？</p>
<p>最后，段子结束吧</p>
<blockquote>
<p>如果代码敲的足够快，我的孤独就追不上我。
如果排查bug查的足够仔细，便能找回丢失的自己。
只要我程序里的坑埋的够深，就能骗过匆匆流逝的时光。</p>
<p>😢</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 情感 </tag>
            
            <tag> 杂谈 </tag>
            
            <tag> 回忆 </tag>
            
            <tag> 人生 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我妈开始催我结婚了]]></title>
      <url>http://zrdsj.cc/2017/01/23/marry/</url>
      <content type="html"><![CDATA[<p>妈妈开始逼我结婚了555555</p>
<a id="more"></a>
<h3 id="001">001</h3>
<p>说点什么吧，如题。约么是26个小时前（170122 20:00），我和我妈就这个话题开始了沟通，显而易见这是第一波沟通。</p>
<p>结果，也挺正常的结果。我们彼此表达了<code>最真最深</code>的个人态度，跟预想的一样，我果然困苦不堪。</p>
<p>我喜欢月亮，不仅是生活中的月亮，也是心中的月亮。</p>
<p>我们在足够多的地方，遇见过动人的话语，感人的台词，无非是点触到了我们内人柔弱的那部分！只要不是傲慢无礼，我们总会被“征服”，进而越发感慨反而在另一个方向影响了自己的生活，当然了，，，是有人愈发沉沦也有人倍加叛逆渴望新生。</p>
<h3 id="002">002</h3>
<p>我的恋爱经历不多，却也是被折磨得够呛。其中的缘由，想必是因为无知的时间太过持续而不能在那个年纪珍惜拥有吧。值得唏嘘的是，还好没有把彼此折磨死去活来才放手，这一点上，一直让我深深内疚有暗自庆幸。内疚的是我竟是如此忠于现实归于理性，庆幸的是过得不好还好没折磨自己去变得更差，大抵如此吧。</p>
<p>如果现在，在经历了算是人生年轻时可的“迷茫期”之后吧，对于即将大学毕业的我来说，爱是什么？</p>
<p>我做一番引用吧，是塞林格的一个句子。</p>
<blockquote>
<p>“There are some people who think love is sex and marriage and six o’clock-kisses and children, and perhaps it is, Miss Lester. But do you know what I think? <strong>I think love is a touch and yet not a touch.”</strong></p>
</blockquote>
<p>若即若离，翩然浮现，氤氲迷醉，若只初见。</p>
<h3 id="003">003</h3>
<p>初二时候，深深爱上了柯南道尔笔下的福尔摩斯，那个cool cool的侦探。不得不承认，那时候的自己，在不幸福的成长环境中，爱上那样的角色，是可怕的。</p>
<p>种子只要不发芽，就没什么问题。可是什么种子要是在心里生了根发了芽，就不平常了。</p>
<p>我得说，中二这种病，不管因为什么。。总之持续到了现在，就是问题了。<code>福尔摩斯对于女性的看法，在原著中的体现，放到今天是不合理的！极其不合理！！！</code></p>
<p>不幸的是，我虽然没有那种看法，却再难有了喜爱的心。我得说，我也不是虚伪，我所夸赞的女性的美和女性的好，我是真心的！两者的关系很<strong>矛盾</strong>，我说不清楚，我自己也是为此不快乐，我想这是<strong>矛盾</strong>的副作用吧。</p>
<h3 id="004">004</h3>
<p>结个尾，我妈催我结婚了。这意味着，曾经的哭哭啼啼恩恩怨怨小打小闹的日子快结束了。真正的人生吧，才要开始。我有多留恋天上的月亮，我的斗争就会有多jilie吧。。。</p>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 情感 </tag>
            
            <tag> 人生 </tag>
            
            <tag> 谶语少bb </tag>
            
            <tag> love </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017计划]]></title>
      <url>http://zrdsj.cc/2017/01/20/plan-2017/</url>
      <content type="html"><![CDATA[<p>2017过去三周了，看着自己2016年1月1日的新年计划，完成度最终定格在了70%。按照60分是及格分的话，算是及格了。hehe</p>
<a id="more"></a>
<h2 id="2017该干点啥">2017该干点啥</h2>
<p>这是毕业年，总觉得会是意味着许多事情。。。却在写的时候不知道意味着什么。。。想到过统筹各个方面，去进行自己下一步计划的评估，最终却是不了了知。（can’t read my Poker Face  23333</p>
<p>最后想了几条大的，基本上和去年的计划一样。</p>
<h3 id="技能工作学习">技能/工作/学习</h3>
<ul>
<li>
<p>合格的前端</p>
<p><a href="https://www.zhihu.com/question/38922374" target="_blank" rel="external">1</a>   <a href="https://www.zhihu.com/question/40343934" target="_blank" rel="external">2</a>   <a href="https://www.zhihu.com/question/19657253" target="_blank" rel="external">3</a></p>
</li>
<li>
<p>清醒的头脑和更专心学习能力</p>
</li>
<li>
<p>顺利毕业</p>
</li>
<li>
<p>合适的工作</p>
</li>
</ul>
<h3 id="生活">生活</h3>
<ul>
<li>素食主义，再彻底些</li>
<li>可以的话，开始专业的健身。不可以的话，也得健健康康（拿手上的xx来做标准</li>
</ul>
<h3 id="life">life</h3>
<ul>
<li>BIBLE</li>
<li>全年12条朋友圈</li>
<li>尽量在年底给自己一台Mac</li>
<li>51篇博客（全年）</li>
<li>做成自己的 ‘阳明先生’</li>
<li>读完豆瓣的书，听完喜马拉雅的书</li>
<li>克制自己不再进入别人的世界，一如既往地别浪费时间去爱别人，好好爱自己爱家人。</li>
</ul>
<p>that’s all</p>
<h2 id="远方的期许">远方的期许</h2>
<blockquote>
<p>道通著行迹，期无负初心。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 在路上 </tag>
            
            <tag> 辞旧迎新 </tag>
            
            <tag> 杂谈 </tag>
            
            <tag> 憧憬 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[无虞与无余]]></title>
      <url>http://zrdsj.cc/2017/01/16/No-%20fear-or-nothing/</url>
      <content type="html"><![CDATA[<p>Ok, 2017的第一篇，写点东西。缅怀下外公。</p>
<a id="more"></a>
<p>在这个月的4日晚，我得知了外公去世。6日办理了丧事，8日（周日）又看了看，算是告一段落。</p>
<p>存在的印象，如果仅仅是这两年的话。。。有五个：<strong>一个青年发呆的模样</strong>，<strong>一条没能弯曲的大长腿</strong>，<strong>入殓日泥泞的小路</strong>，<strong>幼年我火烧过的树根</strong>，<strong>老家窗台的火柴盒子</strong>。</p>
<h3 id="1">1</h3>
<p>这个青年不是我，是舅家的大儿子，外公的长孙。</p>
<p>高中紧张的生活，还有他特殊的家庭生活，不说是折磨的话，也像极了折磨。他的状态看起来，总归不是个好状态。</p>
<p>几年来，我陪他回过几次老家探望老人。年龄也比较相近，我们有些共同的语言和话题。然而大多数时候，总是我在bb我在主导两人间的交流，哈哈我并不是强势的人也无意于主导同世界沟通方面的事情。然而，他压力比较大思维比较不活跃，就如此了。</p>
<p>这几年的生活里，总是纠结交织着这份情感。共同的长辈，不同的后辈身份，“剪不断，理还乱”的关系。。。</p>
<p>喜欢也许是以后的情感，讨厌也永远谈不上，亦庄亦谐过日子吧！</p>
<h3 id="2">2</h3>
<p>外公在我童年的印象中是个停不下来的人，停不下来的木匠。</p>
<p>性格很急，脾气倒不大，外婆总是规劝唠叨，哈哈。在那个村落里，这是我熟悉的场景，我喜欢这个。</p>
<p>最近几年，外公的身体一年不如一年，多种心脑血管的问题纷至沓来。那个硬朗的木匠不见了，他先是不怎么动了，再后来，他动不了了。</p>
<p>每次回家，帮助外婆照顾几个小时的外公，当时的感觉是痛苦的，照顾人的技能很惭愧我实在是做的不好。每次结束离开，过上一段时间，会有那么几分钟我会感到很舒服，很安心。</p>
<p>仅仅是我看望了外公吧，</p>
<p>外公的大长腿，在当年是走来走去，不亦忙乎？！。记忆中最后看见的大长腿，是坐在轮椅上，毫无动静，而老人脸上平静而又哭丧皱眉的表情，酷似幼时淘气顽皮的自己孩童的面庞。</p>
<h3 id="3">3</h3>
<p>开封回来是5日，6日下葬。天气凄冷无比的风和雨，心情所致吧，黑夜凌晨所见的光景，总也好不到哪去。</p>
<p>泥土遇了雨水，就成泥土了。粘的鞋子裤子到处都是，带来带去，似乎是不愿你离开又像是希望你带走它。</p>
<p>真的，泥水有点多。。。恐怕是忘不了那些鞋子最后的模样了</p>
<h3 id="4">4</h3>
<p>在我五六岁的时候，离老家20米的小土岭上有棵老杨树。那是一个秋天，我记得很多玉米杆堆在一旁，还有些麦秸堆。“城里孩子”自然是少见火柴，各种玩啊玩。</p>
<p>最后，终于一根火柴带着火花飞了出去。。。燃着了许多东西，。刚开始，我用石头砖头进行了尝试（灭火），失败了。</p>
<p>边上没人，最后我听见小姨的呼唤离开了。</p>
<p>再后来，附近的人看到了黑烟和一人多高的火苗。。。废了点事，解决了问题。。。</p>
<p>总得说说是谁家孩子干错了事情。。。</p>
<p>我很害怕，最以后事情不算太大不了了之了。但我记得，我被大人询问的时候，我脸很红很辣。</p>
<p>大概4年前吧，我注意到火灾发生的地方，那棵树被砍了。树墩仍可见我造成的伤痕，</p>
<h3 id="5">5</h3>
<p>幼时，父母下乡忙的时候，常常寄宿在老家。</p>
<p>流鼻血，外公拿掉了嘴里的烟斗迅速磕去了烟灰，并与另一只手里的火柴一并放进口袋中。治疗我。。。······</p>
<p>下巴磕破了，外公拿起窗台上的空火柴盒子，撕破了贴在我血流不止的下巴。。。······</p>
<p>好吧，这个小物件儿，不简单吧。</p>
<p>最后是一首那时候一直听的歌，想妈妈时候会听</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=332567&auto=0&height=66"></iframe>]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活随笔 </tag>
            
            <tag> 回忆 </tag>
            
            <tag> 人生 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2016 Conclusion]]></title>
      <url>http://zrdsj.cc/2016/12/31/Conclusion-2016/</url>
      <content type="html"><![CDATA[<p>开始敲下这篇博客第一个字符的时候，离2016的离去还有两个多小时。这篇博客是这个阳历年的最后一篇了，其实之前的18篇有的也仅仅是写了一部分，并没有写完。</p>
<a id="more"></a>
<p>这样的‘匆匆’总能说明，说明我的生活是出了问题的。也诚然，我是认可这个说法的。这一年过得太快，和以往经历过的任何一年都一样，快！我多希望，自己可以不再感叹这些尘埃落定的事情。hhh</p>
<p>我总结了10个，可以称之为<strong>things</strong>的东西吧（顺序无关排名），来缅怀过去的一年，也是安慰自己饱经“沧桑”的内心。</p>
<h4 id="剃须刀">剃须刀</h4>
<p>2016年初的时候，不再用那种便携的小型电动剃须刀了。换成了传统的手动剃须刀，用的是吉列锋速3这个较为通常的入门品牌吧。</p>
<p>没啥好说的，怎么想这个话题都是没啥好说的。提起来我也是些许郁闷呢，哈哈哈哈。在一月的时候，有一次和lc去县城的ty大酒店洗澡，又是开车又是大包小包的衣服，一切比起平日的生活整的很不和谐。一通下来我花了40，他花了80？</p>
<p>总之俩人洗了个痛快。偶然间的谈话中，我谈到了他洗澡篮里的剃须刀，进而引出的聊天内容中我总结2个points：</p>
<ul>
<li>基本上每两天就得刮一次脸</li>
<li>起初都是会觉得不可思议</li>
</ul>
<p>好吧，是这样啊。</p>
<p>有时候走在大街上看到十几岁的青年们，脸上也是淡淡的胡须时候，会联想到几年前的自己。这是一种睹物思人吧，得到了暗示，思维总是停不下来的。</p>
<p>那个时候的自己（几年前），即使胡须有时候也看上去有点显眼了，也没想过什么。大学有很长一段时间，我是蓄了胡须的，我总觉得这样让自己显得毛茸茸的可以不被别人伤害。。。哈哈，我不知道是否算是奇怪的想法。后来，我意识到胡子硬了也长得快了，还是啊，得刮！</p>
<p>基本上两三天我也是得刮次胡子了现在。起初觉得不可思议？我倒没有这先关的记忆和印象了。如今的每次刮胡，都像是在进行一种仪式，为了生活？为了什么？我说不清楚，我有点慌，是 我有点慌！</p>
<p>别说岁月改变了我们模样，是生活造就了我们，就是我们选择的所过的生活，它造就了我们。我们小心翼翼，不免浑浑噩噩，也常常困倦不已却依然一副傲慢的姿态对待世界对待自己。还好，也许刮胡子的时候，会放慢自己的节奏，你不会想刮不好更不会想慌张到刮破了脸皮，，，。。。好吧，下次刮胡子的时候，要拿好剃须刀，好好的刮刮胡子。</p>
<h4 id="红楼梦">红楼梦</h4>
<p>这个好说很多了，就是这一年我正式成为了《红楼梦》的读者，而后迷上了其中的<strong>故事</strong>。详细完整的读了通行本，仅一遍。</p>
<p>喜欢是喜欢，我掩饰不住；认识尚肤浅，我必须承认。所以，我得实事求是陈述一下。喜欢很爱，但是呢尚且初级一点，但又已然是：<strong>一朝入梦 终身不醒</strong></p>
<p>我不是喜欢立flag的人，但是提及《红楼梦》，立flag的事情变得复杂起来了。奇书之奇，也许这就算是一处吧。不做搬运工，什么都不做了，表示一下未来的话，，，肯定，这本中国古典名著与我本人的故事并未结束，未来的日子里我的生命中，肯定是有《红楼梦》的影子的。</p>
<p>而那时候，又是一番：你方唱罢我登场 么？</p>
<h4 id="口语粉碎机">口语粉碎机</h4>
<p>在2015年的12月初始，我报名de一个微信上的英语培训班。英语口语教学为其口号，实则是英语思维的教授与学习监督。</p>
<p>骨子里是DC粉丝（今年4月份才搞清楚DC 漫威），却在“山头”成为了<code>复仇者联盟</code>小组的组长。06301-06310，组长在这里不会说太多的东西，但组长忘不了你们的。</p>
<p>山头的故事告一段落，日后的事情。。。有机会再续前缘吧。</p>
<h4 id="叶隐老师">叶隐老师</h4>
<p>起初这是bigger的副作用。试想你突然间在网络上遇见了一个让你知识认识全方位五体投地的大叔，还是会很吃惊的。bigger的话，其实可以说是附庸风雅也可以说是近朱者赤的想望吧。</p>
<p>不与介绍了，叶老师是个基督徒说来的话我们互相称为弟兄。叶老师的学问，见识，胆量，气质等等虽说我仅是几篇文字几张照片去了解的，，，但是我觉得，堪为此国度少有的清醒之人。</p>
<p>此处写来，我更希望是给自己的一份勉励与期许，希望在不久的将来，我和叶老师之间的距离，可以近一些。</p>
<h4 id="缘分">‘缘分’</h4>
<p>这个是在说，与另外几个人的相遇。十分感激这几段生活，列个列表的话是这样：</p>
<ul>
<li>十月份火车上认识的大姐姐小阿姨（深圳）</li>
<li>二月份山上认识的Susan（温州）</li>
<li>九月份火车上认识的会计小学姐（深圳）</li>
<li>十二月豆瓣上因音乐偶然认识的kiwi姐（上海）</li>
</ul>
<p>差不多就是这几位吧，在往年的生活中，并无这般的际遇！对于我来说新认识一些人，或多或少会有所审视有所察觉，发现更多的Fun。不是几句长短，几声问候，几个祝福，而是说我的心创造我自己的生活，而生活如何，我想不是容易解答的吧。</p>
<p>引用一段塞林格的话语（写<strong>爱</strong>的一段话）结束这个章节吧</p>
<blockquote>
<p>There are some people who think love is sex and marriage and six o’clock-kisses and children, and perhaps it is, Miss Lester. But do you know what I think? <strong>I think love is a touch and yet not a touch</strong>.</p>
<p>有人认为爱是性，是婚姻，是清晨六点的吻，是一堆孩子，也许真是这样的，莱斯特小姐。但妳知道我怎么想吗，我觉得爱是想触碰又收回手。</p>
</blockquote>
<h4 id="网易云音乐">网易云音乐</h4>
<p>自己的品味，让自己说是不合适的。但是呢，客观来看还是有些奇怪或者说是意料之外的事情发生了。</p>
<p>网易云音乐，会在每天根据用户所喜爱所听的音乐<em>口味</em>给出20首推荐。最近的四五天我的推荐全是些外国风情的曲子。。。是的，是曲子。钢琴，胡琴，萨克斯风，口琴，小提琴，吉他…是些轻音乐和英文歌。</p>
<p>我喜欢目前的状态，我喜欢这些推荐，和音乐背后大家的段子、故事。就像是自己也经历了参与，不带着过度的陶醉，淡淡的如清茶如白水，慵懒又像午后的阳光，清净好似雪野的黎明。。。所爱者，该是这样，就是这样。</p>
<h4 id="基督生活">基督生活</h4>
<p>在这十个话题中这个话题是最重要的！这次拿出来说，却是说不了很多，自己根基尚浅学问鄙陋无以为谈。一直以来微信关注的公众号服务号数量是30个（多了总要牺牲几个不去看，不要那么多），每一段时间我都会根据自己的情况有所整理，最新的数据是我关注的基督教相关的有7个（7/31，话说腾讯相关的服务号就有10个），比重也说明了是很重视的。</p>
<p>这一年的前半年，愈发感觉生命的无奈与困倦。于是重新开始了每周日的礼拜并强行拜读圣经，又加上平日自己刻意使生命慢下来平静下来的态度，逐渐好了很多。</p>
<p>在暑假去到深圳之后，有所浮躁也多了写忧愁。在平湖教堂，十一期间，得救了很多，学到了很多。</p>
<p>十一月的灵修生活中，应该是初步认识到骄傲的可怕。在十二月的灵修生活还有读书认识宗教改革这个过程中，更为深刻的认识到骄傲的巨大危害。</p>
<p>每次去教会，去参加活动，而后都会学到更多的思想和属灵的认识，而非是一时的感动。</p>
<p>所有一切的存在，都因天父上帝的恩赐，阿门。如今，2017新的一年也期待会有更好的灵修生活。</p>
<h4 id="素食主义">素食主义</h4>
<p>这一年的11月，在家里生了一场小病，但过的却是格外的难受。不再赘述。</p>
<p>我开始了有过的最深刻的关于健康的思考，夹杂着自我标榜的基督思维以及回忆。我的身体在初一以前是极棒的，小时候同龄的孩子我是见过几个经常生病的，还有一些不那么利索的。大家一起成长，最后呢似乎是河东转河西了。</p>
<p>我在初二得了严重的鼻炎，这一病就是5年。直到后来严重成了<u>鼻息肉</u>做了手术，才算是将这一顽疾去除，现在的我身体已经不再遭受鼻炎的困扰。四年后，我才又得了值得一提的病，就是上个月让我无能为力无所事事的病。11月初刚得病时候我获知这病是病毒对于表皮神经的入侵，是来自肉类的病毒，但病因归根结底是来自免疫力的低下。</p>
<p>那个时候起，我决定了未来逐步规划自己的饮食与作息，讲健康看得更重要一些。</p>
<p><code>饮食</code>上，只是非常简单的一点<strong>不再吃肉</strong>。我不再枚举这个国度关于食品安全的问题和事故了，但我自己想要以后的生活里忍住不再吃肉了，渐渐地改掉吃肉的习惯吧，对血管心脏也是有好处。这个也是双刃剑吧，哈哈自己承受吧。</p>
<p><code>作息</code>上，就一点，有意识的少熬夜。</p>
<h4 id="王阳明">王阳明</h4>
<p>这个仅仅是半个月来新培养的偶像吧，王守仁王阳明！</p>
<p>关于这位仁兄的事情，我是因为听书而感兴趣的。在喜马拉雅fm有档节目《明朝那些事儿》（上下共计350集*23min）,这节目中有那么四五十集是有说到王阳明的，从那个时候起，对于这位“圣人”，产生了浓厚的兴趣。</p>
<p>前几天，专门了解了一些王阳明的介绍事迹生平,在<code>知乎</code> <code>贴吧</code>这些地方也逛了又逛。</p>
<p>“阳明心学”的评价，比较公认的一条是<code>近500年来中国诞生的最伟大的智慧</code>。伟不伟大厉不厉害，中外近代许多名人相关的事迹相信是有说服力的。</p>
<p>最后，笑笑表个态：2016是认识了解王阳明的元年，但此后对于“阳明心学”的学习和感悟，才刚开始吧。</p>
<h4 id="一丢丢花钱的事情">一丢丢花钱的事情</h4>
<p>这个话题，很有的聊。我只是说自己这一年感受最大的一点。这一年，在一些新的领域花了钱。</p>
<p>豆瓣上买电子书，订阅付费的新闻服务，网易云的音乐会员，付费的视频学习和教学。。。相比于传统的文化学习方面的投资，2016在这方面我的心态和行为也都有了变化。</p>
<p>诚然，谁不喜欢有品质有内涵的生活呢？希望这是个契机，借此激励自己在未来的生活中努力加油，去为自己拼下更好的生活。</p>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活随笔 </tag>
            
            <tag> 基督教 </tag>
            
            <tag> 辞旧迎新 </tag>
            
            <tag> 杂谈 </tag>
            
            <tag> 智障人生 </tag>
            
            <tag> 回忆 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[圣诞note]]></title>
      <url>http://zrdsj.cc/2016/12/25/Christmas-notes/</url>
      <content type="html"><![CDATA[<p>今天是2016/12/25，阳历是圣诞节。近几日的生活，是有一些感触的。在此做些分享。</p>
<a id="more"></a>
<h3 id="1223">1223</h3>
<p>这一日是周五，天气是个多云的冷天，天空中的太阳并没有露脸，无风无雨无云，就是这样。这一天的活动是<strong>圣诞崇拜演出</strong>，在上午的08:30演出到了12:00，下午是13:00演出到了17:00吧，晚上的聚会我并没有参与。</p>
<p>演出在我的心里，意义大于形式。不是我马后炮，也不是妄自菲薄，而是说日常的所见所闻之下，但凡内心有波动又不失理智，恐怕都会这么想。</p>
<p>汝阳、开封、深圳三个地方我去过几个教堂，深圳的老年人比较少所以到教堂的人也没什么老年人，但是也是深圳年纪最大的阶层了。汝阳和开封的情况，说句令人唏嘘的话，全是些老头老太太。这样的群体里，凡有聚会演出的话，事实上是有很大限制的。</p>
<p>周五的演出也确实印证了这一点，仅仅上午就有17个表演队二十多个节目，我数了数差不多5、6个是中年人的表演节目其余全是老年人们的。很真实很真诚，得益于主的恩典，演出节目并不失精彩与掌声。阿门！</p>
<h3 id="1224">1224</h3>
<p>这天的19:00有平安夜崇拜聚会，在我写这篇blog时候应该称之为昨晚。我有点大意了这是我自己的失误，我在当天晚上的17:50走着走去教堂基本上是走了50分钟走到了。</p>
<p>我没想到人会有那么多。</p>
<p>多到来了警察维持秩序。我相信这些人都可称得上是弟兄姊妹，但是确确实实人多了许多事情都进行不好。仅仅呆了20分钟，无奈我实在听不到聚会分享的内容只是些嘈杂的声音。</p>
<p>眼所见，耳所闻，心所感。皆不是自己所喜所感，我也很难过也很惭愧，我对不住主的恩赐。最终我离开了西门教堂，走回学校。</p>
<p><strong>作为基督徒，我充满怜悯和悲伤，愿这个民族在基督真理的光照下新生，而不是在暗夜里徒劳的折腾</strong>。我真真的希望，日常的礼拜可以有更多的年轻人和中年人到来。😄</p>
<h3 id="1225">1225</h3>
<p>就是今天。</p>
<p>设想一下，周日礼拜天+圣诞节，真的是人tai多了。情形和昨晚一样，人多到警察维持秩序。</p>
<p>最终无奈，站在外面太冷，只得离开。</p>
<p>······</p>
<h3 id="写在最后">写在最后</h3>
<p>【腓1:27】只要你们行事为人与基督的福音相称，叫我或来见你们，或不在你们那里，可以听见你们的景况，知道你们同有一个心志，站立得稳，为所信的福音齐心努力。</p>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 圣诞 </tag>
            
            <tag> 生活随笔 </tag>
            
            <tag> 诉苦呻吟 </tag>
            
            <tag> 基督教 </tag>
            
            <tag> 情感 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[I am back]]></title>
      <url>http://zrdsj.cc/2016/12/21/return/</url>
      <content type="html"><![CDATA[<p>这次是来说说，为什么到了12月的下旬，才想起来写点东西，在这孤独的博客中。</p>
<a id="more"></a>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1612-1701/shijian.png" alt="hh"></p>
<p>上面看到的这张pic，是2016.12.21下午的14:47分，我的一张截图。十月，十一月，十二月的前二十天，我没有写一些东西，似乎是我的学习中断了停下了脚步。事实上，这是很难让我接受的事实，我不太走运吧也许。</p>
<h3 id="luoyang-shenzhen">luoyang-shenzhen</h3>
<p>我依然记得，十月八日那天晚饭是在哪家饭店吃的什么，炒面吃的炒面！饭后我接到一个电话，是妈妈打来的告诉我奶奶走了。第二天1009我坐了下午的飞机，在17点钟的时候到了郑州新郑国际机场。那时候机场外是下面那个样子。。。</p>
<p>我依然记得，十月八日那天晚饭是在哪家饭店吃的什么，炒面吃的炒面！饭后我接到一个电话，是妈妈打来的告诉我奶奶走了。第二天1009我坐了下午的飞机，在17点钟的时候到了郑州新郑国际机场。那时候机场外是下面那个样子。。。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1612-1701/xzjcc.jpg" alt="jc"></p>
<p>后来的事情：在家停留了四天，奶奶的葬礼是基督教葬礼，并无太多的形式，并没有太嘈杂大家的生活。</p>
<p>有些事情，并不需要它们再次掠过大脑，不需要。that’s all!</p>
<p>我，回到了深圳。</p>
<h3 id="shenzhen-suzhou">shenzhen-suzhou</h3>
<p>之后的时间就是十月中旬了，我回了深圳。四个月的培训其实三个月已经基本完成了，因此这次的回归，似乎更像分别离别的情调。</p>
<p>我还是挺了解自己的，在一些方面。哈哈，果不其然。紧紧回深圳一周之后，我就确定了下一站自己的目的地:苏州。zcy所在的地方。离开深圳的那天，下雨了，胃口很不好，牛肉粉，也有点腻。</p>
<p>1119，到了苏州。缓缓休息，准备面试，不料，意外频出。！</p>
<p>我之前是无神论者，但一直相信因果逻辑轮回报应之类的事情，总会有个说法有个缘由，不然人lei的事情就太简单了。我没有办法解释自己，但是我确实很难受，就像那几天苏州的天气一样，一直下雨，一直刮风，一直阴天。</p>
<h4 id="背疼">背疼</h4>
<p>就在苏州，刚刚调整好了自己，我的右背疼了起来，起初我以为是拉伤，后来发现不是，因为它一直在痛。再后来，右胸下边儿，也就是肋骨外皮肤的位置，也开始痛。我以为是吃了不太干净的食物引起的皮肤过敏发炎，就搞了一些消炎类的涂抹膏药。然而我错了。仅仅过了一天，疼痛没有减轻，而且好像加重了。开始出现红色的带状疹子？（我不确定，但是绝对有颜色了）然后在疼了第三天的下午，我打算出去买点水果。</p>
<p>我不知道为什么找到水果摊之后我没有立即买，而是在手机地图上，找到了几个附近诊所，我可能是想去看看。还是在那个方向，我多走了几步路，找到了两个诊所。</p>
<p>我走进了一个社区卫生院之类的三层楼小医院。在二楼，大夫们似乎都不在。我问了问仅剩的一位牙科大夫，说明了自己的情况，给他看了我的身体“杰作”。牙科医生不耐烦的回复模样我至今记忆犹新，但是他告诉了我两件事情，我得的病是什么？（<code>带状孢疹</code>）我应该怎么办？（<code>hospital</code>）</p>
<h4 id="苏州-洛阳">? 苏州-洛阳</h4>
<p>没了心情，我还是买了水果，苹果和香蕉，回到了住处已经是下午的4点钟了。我没有太犹豫，收拾了几件东西，一边告别出差的zcy，一边安排好了自己的归途。是的，我想回去，回洛阳回家。</p>
<p>事情就不详说了，我回到了家，治好了病，然而，我没想到的是，这一切整整花了我一个月的时间。整个11月，我都在一个休养的状态。这期间的生活很丰富，我也得到了好的休息，无奈的是，我知道和我身份相同的人们，他们并未停下努力的脚步去工作学习。</p>
<p>So，白天我可以嘻嘻哈哈一副正常模样，晚上离开网吧到家，稍微静下来我就如吸烟的马男波杰克那般。。。会哭出来么？</p>
<p><img src="https://pic4.zhimg.com/06438940f6566b1cceba113f9608105b_b.jpg" alt=""></p>
<p>渐渐地，我也缓了过来。</p>
<h3 id="拯救与福音">拯救与福音</h3>
<p>接下来要说的事情是关于自己属灵生命的，关于基督教事宜的。本篇博客有一个新标签：骄傲与道德主义。这次我也不会大谈特谈什么东西，圣经坚持读了也就半年（还差得远呢），谈不了什么的！说一些自己的事情罢了。</p>
<p>九月份十月份的一些时间里，我常常莫名感到激动。是因为<strong>我觉得那段时间的自己到教堂忏悔祷告，日常不行试探不行恶，假以时日天父上帝定会将福音传授与我并救我脱离险恶给我信心是我彰显主的大能在这人间</strong>。</p>
<p>似乎第一眼看上去，我的想法也是没什么大问题。至少我是觉得，我怀着自己的<u>信心</u>信封耶稣侍奉主，是不会有问题的！</p>
<p>苏州回洛阳治病是在1025这天，回家之后很快病情得到了控制（不再严重，疼依然如故），随即来临的几次礼拜我也认真参与了，然后我意识到了我已经出了很大的问题。</p>
<p>上面那段黑体字，彰显的不是神的大能而是我的无知。我的信仰，是怀揣着功利在里面的，为了自己？哈哈哈哈，可笑。基督徒的奉献是为了天上的神父，怎么能是为了天父的恩赐救赎而去信奉基督呢？那样就算是信了一辈子，能得着福音么？答案是显而易见的。下图是我1106在家中古严教会的礼拜日记吧算是，截图</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1612-1701/czbqjt.png" alt=""></p>
<p>至此，我明白了自己属灵生命中，多了几分骄傲，而这是不可取的！</p>
<p>后来的事情，这个链接：<a href="http://mp.weixin.qq.com/s?__biz=MzAxNTE5NzQyNA==&amp;mid=2650623409&amp;idx=1&amp;sn=006f5c8c80b674d07ee846980f2b7022&amp;chksm=838e582eb4f9d138302f31198067e97972a973f683807204552451e71285a801bef19f5821c9&amp;mpshare=1&amp;scene=1&amp;srcid=1221gpvLVAteu7tw3rZeSMA2#rd" target="_blank" rel="external">教会</a>了我更多。</p>
<h3 id="最后">最后</h3>
<p>我回来了，往后的日子，托付与主，托付与自由的心。😄😢</p>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活随笔 </tag>
            
            <tag> 基督教 </tag>
            
            <tag> 杂谈 </tag>
            
            <tag> 智障人生 </tag>
            
            <tag> 骄傲与道德主义 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一些关于161001平湖教堂的分享]]></title>
      <url>http://zrdsj.cc/2016/10/01/Something-in-Pinghu-church/</url>
      <content type="html"><![CDATA[<p>不知道若干年后，是否存在某个惬意的午后，也许是雨天也许是艳阳。。。我会想起那年的十月一日，那个内心欢欣不已的日子。😄.</p>
<a id="more"></a>
<p>主上赐予的眼界与慈爱!阿门！</p>
<p>上午的早堂，是两位来自美国的老者所分享的。话题是基督世界经典的&quot;希望、信心&quot;话题，值得一提的两点是，1是我第一次看到外国人在做’传教士’之类的工作（两人并不是神学起家）2是通俗世界里两人的工作与宗教的距离实在是相差甚远。。。</p>
<p>不多说了，回顾现在开始。</p>
<h3 id="dr-henry">Dr Henry</h3>
<p>这个名字曾经在我的生命中，是另一份含义。几乎是时间和青春的代名词。伴随着那些年的风，散尽了只剩回忆。。。Thierry·Henry。。。</p>
<p>这次的Henry博士，是位近80岁的退休工程师，之前平湖堂张牧师的介绍说是喷气式动力发动机方面的科学家，后来我又问了翻译得知Henry博士还为谷歌发射卫星时做了技术顾问之类的工作。以一个旁观者，我来回顾下。</p>
<h4 id="生平">生平</h4>
<p>老人的童年没有被提及，学习方面说了一点，可以知道的是当年的Henry是个不折不扣的聪明孩子。也就是上个世纪的5060年代的那个时间段，老人轻松解决了在自己学业上的问题。在大学顺利拿到了博士学位。</p>
<p>按照老人自己的感慨：‘<code>我一度觉得我自己足够厉害，我可以通过自己的方式改变自己的生活。年纪轻轻成为工程师，成为人们眼中羡慕的人！</code>’。</p>
<p>老人在1967年，加入美国阿波罗登月计划。当时是不到30岁的年轻人，却以工程师的身份，去参与可以说是至今为止都是最重要的几个人类事件之一的’<code>阿波罗登月计划</code>’，赞叹之余我也更好奇这样的牛人后来的故事。</p>
<p>继续讲。</p>
<p>在计划成功的1969年，许多科学家工程师退出了，仅仅一部分还在执行其中的收尾工作。Henry当时退出了，并且在大学成为了教授。Henry说自己大学教授时期都在研究火箭，喷气式发动机之类的。。。</p>
<p>再后来的故事是关于老Henry的生活。。。</p>
<h4 id="生活">生活</h4>
<p>老Henry很感激上帝给予他生命中的两个爱人！两个Susan，2333</p>
<p>第一个Susan，是老Henry的大学女友。毕业后没多久，老Henry就同Susan结婚了。老Henry直言当年他喜欢男孩子，然而Susan第一次生了个女孩。</p>
<p>我难以描述台上老Henry诉说这些故事时候的表情和态度，但一切都让我觉得：踏实，愿意倾听，又不感觉空洞乏味。</p>
<p>生活仍在继续。老Henry和Susan的第二个孩子也来到了世上，还是个女孩。但这个时候，已经过去了几年了，老Henry表示这个时候他已经没有很多想法了，他表示这都是自己的爱自己的亲人。所以，当时还年轻的Henry其实生活都很快乐都很充实。</p>
<p>接下来老人的一番话以及后来老人的遭遇，着实让我陷入深思。</p>
<p>老Henry说：按照平常的看法，他的人生着实完美。对他来说，爱情和生活都是如此的完美，，，所做的工作在今天来说可以说是顶级技术流是不会失业的那种。也因此，老Henry坦言那个时候的他，觉得什么事情都可以凭借自己的能力去解决去变得不再是问题。（月球都上的去，还有什么办不了？2333，私人吐槽毫无恶意，，，just for fun）</p>
<p>这样，生活仍再继续！！！到了某一年，是在老Henry与Susan结婚30多年后，Susan患上了脑癌。这一年的话，Henry已经60多岁了。</p>
<p>我们不再探讨这种事情对一个家庭的影响，也不说各种无意义的骚话段子了。结果是，在经历了两年的治疗与痛苦之后，这位Susan，离开的深深相爱的Henry和他们的两个女儿。</p>
<p>此时的Henry，不再年轻的Henry，独身一人的Henry。。。几次寻死未成，并因此患上了严重的心理疾病。。。当年的他曾经认为，自己的世界可以自己去改变自己去使之美好。。然而毫无疑问，妻子的患病离世让Henry过往的骄傲和自豪也变得支离破碎。我很同情那时候的Henry，本该携手走向黄昏的美丽人生，却是天人永隔的悲痛。</p>
<p>这个时候，最大的事情莫过于先帮助痛苦的老者振作起来。在亲朋好友以及两个女儿的帮助下，减少了工作的Henry开始去向往日他并不熟悉的教堂。</p>
<p>这个过程持续了5年，在神父与牧师的帮助下。老Henry成为了一名忠实的信徒，内心的创伤得到解脱，支离破碎的心再度愈合。Henry博士坦言，在那几年里，重新学会笑容让他意识到生命中诸多美好的事情其实如此简单，对，微笑就行了！</p>
<p>同样的，在逐渐疗伤的过程中。老Henry逐渐的开始了自己的神职职业工作，跟随着教堂去帮助其他的人（主要是给予相似经历的人以心灵帮助）。</p>
<p>感谢上帝，Henry遇到了第二个Susan。像电影剧情一样，但确是老者身上的真实故事！这第二个Susan，也是一把年纪的中年妇女了，丈夫因为脑癌去世留下了自己和三个男孩。如此这般之后她也在也在教堂工作了。</p>
<p>故事的最终，老Henry和第二个Susan在一起了。他们有两个女儿和三个儿子，孙子辈的都已经有13个了！当时老Henry在讲到这里时候，教堂里面有人都开始鼓掌了。哈哈，谢谢上帝！</p>
<p>2004年，带着妻子的祝福，Henry第一次来到中国，他是来传授福音的，在一些地方的教堂里讲述他受神眷顾重新振作的励志人生并且致力于对因亲人疾病离世引发的心理障碍患者进行帮助与疏导。今天十月一日的聚会，是Henry的第13次中国之行了。</p>
<p>在最后，Henry表示他的妻子Susan同他一样十分喜爱中国。但Henry深知这些年妻子的身体状况并不理想，体重很轻经常睡不了觉。。。为此他为进行了一些健康疗养，Henry表示在不久的将来他会和妻子一同来到中国，为人们带去福音和祝福！</p>
<h3 id="dr-randy">Dr Randy</h3>
<h4 id="生平">生平</h4>
<p>这位白发苍苍的老者，叫兰迪 Randy。是为牧师，同上面那位Henry起初是同样的梦想—工程师。后来，并不像Henry那样顺利成为了科学家。</p>
<p>这位Randy的父亲老Randy是二战的美国空军英雄！从父亲那里，Randy学到了很多，比如说信仰。在Randy还是个年轻青年的时候，就完成了对基督教的绝对信奉和对神的忠贞侍奉。</p>
<p>然而命运无常造化弄人，在Randy20多岁的时候，发生了意外事故。在和自己的师傅一同进行实验时候意外触电，Randy失去了双臂师傅则失去了生命。阿门。</p>
<p>题外话：但凡了解基督教祷告的事情的人都会知道，我们为了自己的身心不受伤害向上帝衷心祷告并且献上赞美与荣耀。在这种情况下却受到命运的这般照顾，即是说是一个充满正能量和信心的人，也不免会感到伤心失意甚至不理解。</p>
<p>话说回来。。当时的Randy才20多岁，用世俗的话说其实就是’空军英雄的儿子是个残废’。。。这样的事情太可怕了，及使对一个已然多年调整心态的的教徒来说这也是困难凶险的事情，何况一个20多岁的年轻人！</p>
<p>Randy老人并没有说太多自己遭受的痛苦，老人平静的演说配合着左臂义肢的铁钩笔画，在空中撩出的画面似乎在表示着。。。都过去了，我现在很好！</p>
<p>Randy表示，在失去了双臂之后，他最终振作了。他之后所做的事情被限制太多了，最终Randy选择了成为神职人员侍奉上帝。他说：<code>我向上帝祈祷，渴望得到一副新的义肢</code>。</p>
<p>听上去，也是可以理解的。失去了手臂的信徒，向他的主祈祷得到应得的义肢。合理不过分！</p>
<p>Randy之后哈哈一笑，继续说：他这一等，没想到竟然是39年。得益于技术的障碍，之前的假肢最多是个装饰并不能很好的使用。而他现在的义肢，则是在失去左臂39年后才获得的，可以根据大脑的信息操控去进行动作。去在我的角度看上去Randy可以夹起水杯喝水可以夹起《BIBLE》。。。</p>
<p>我不知道一个人的一生可以有多少个39年去祈祷一件事情，也不清楚有多少人会为了一件事坚守39年的信心，更理解不了反复祷告祈求天父恩宠30多年无果之时还能调整自我的伟大心态。。。愿主能赐予我坚强、力量。阿门。</p>
<p>Randy还说到了，在高中开始他就希望上帝在他未来的生活中赐予他位美丽善良的妻子。还好，仅仅是9年，也还是在Randy20多岁的时候，Randy遇见了生命中的另一半。至今，约莫是半个世纪的爱情了。:love:</p>
<p>Randy之前和妻子就来过平湖教堂，是在前年，那个时候许多当地的弟兄姊妹得到了他们老夫妻的祝福与祷告。所以在今天Randy再度提起自己的妻子时候，所有人献出了掌声。</p>
<h4 id="生命中的智慧-by_randy分享">生命中的智慧 by_Randy分享</h4>
<p>Randy的故事比起Henry，很不一样。至少一点显得Randy的事情是自己的，所以专门说说Randy的一些智慧的分享。</p>
<p>Randy在几十分钟属于它的时间里侃侃而谈，70多岁的年纪，精神矍铄情绪时而高涨动作时而夸张。。。我的天呢，天堂的人恐怕都是这个模样吧（我告诉自己2333）。</p>
<p>Randy说，终其一生他都觉得上帝在他的身边，在遇到事情的时候，心里总会有个声音在提醒他自己，诸如&quot;<code>嘿，兄弟。淡定点。。</code>&quot;&quot;<code>嘿，远离XXX，不要XXX</code>&quot;&quot;<code>别急着高兴，Randy</code>&quot;。。。这些来自上帝的声音让他受益匪浅，最初的时候他是怀疑自己有妄想症什么的后来也忘了如何不了了之了。但是真真切切的Randy表示，上帝借走了他的胳膊，却也给了他别样精彩的人生，他从来不觉得世界欠他什么反而觉得自己该回馈社会。</p>
<p>也因此，古稀之年的美国神父放弃安闲的退休生活去到遥远的东方宣扬上帝宣扬爱与自由。</p>
<p>救死扶伤与心灵救赎一直以来在我心中，都是人性最伟大的实际行为体现，其他的所谓的正能量不知道高到哪去了。Randy与Henry在这个层面上来讲，称得上真正的伟大。</p>
<h3 id="last">last</h3>
<p>献上两人的一张照片截图：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1610-1611/henryrandy.jpg" alt=""></p>
<p><strong>这不是段子也不是自我安慰的精神读物，但凡有所了解基督教的都知道，这样的事情在基督世界里可以说是司空见惯，却也不缺真实性。</strong></p>
<p>是我的信心不足，还想要强调一遍。2333😂</p>
<p>我信奉天父的阶段，无论如何认证都是浅显的初级阶段。我已经感受到了基督生活带给我的变化，走在路上可以因为一片飘落的树叶驻足而立可以为了一个步履蹒跚老者心酸难过，这些事情在别人看来似乎是不务正业的神经病，我自己的话，，，开心就好吧😄</p>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基督教 </tag>
            
            <tag> 情感 </tag>
            
            <tag> 圣经 </tag>
            
            <tag> 人生 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一篇关于微信公众号的辣鸡感想]]></title>
      <url>http://zrdsj.cc/2016/09/30/Idea-about-WeChat-public-number/</url>
      <content type="html"><![CDATA[<p>在昨晚小区院子里，和zcy喷了会。不禁想起些许往事。。。一些关于一本书的事情。</p>
<a id="more"></a>
<p>这本书：</p>
<p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCADcAJQDASIAAhEBAxEB/8QAHAAAAAcBAQAAAAAAAAAAAAAAAAIDBAUGBwEI/8QAUhAAAgEDAgMDBgYMCgkFAQAAAQIDAAQRBSEGEjETQVEHFCJhcYEydJGhscEVFhcjM0JiZIOTlLIkJjU2UlRVcqLRJTRDREVjguHxU3OEksLw/8QAGwEAAQUBAQAAAAAAAAAAAAAABQECAwQGBwD/xAA9EQABAwICBgYHBwQDAQAAAAABAAIDBBEhMQUSQVFxsQZhgZGh0RMUFSIyMzQWI1JyweHwJEJTYkOC8ZL/2gAMAwEAAhEDEQA/AMX0Ph7UuI7t7XTIBNKidowLhQFzjqfWatieR7igTKk6WkaYBYicMQfDHeal/IdGv2Z1aVgSq26KFBwSS+wHyGtuWFIS6RxBz1DEjv6H/tQmtr5IJC1trKxFC17brz7ceR/ibt282toexA2Ml0mfWdqUfyLcSr+DlsWHrkIr0E8qLt2RCn4Xojb1b9aSEpAYEDnJ26dSc/Jih7tJVhtqkd37qcQRDMLz03kd4tU7Q2bey5H10QeR/i7+q2v7Uteiu3G3LECMnc46Z/8ANdjH3tc9cZpkul6yID4T2HzStponLzr9x/i7utrT9qWujyO8WkfgLT9pWvRXL7a6Rjrmq3t6s3Du/dP9TiXnT7j3FwP+r2n7Utc+4/xb/V7T9pWvReMUMU37QVm4dx8171OJedB5IOLf6vaftK1w+SHi3+rWv7Utei+U77E46nFc5T/RPyU09Ia38I7j5pfU4t686fch4t/q1r+0rXfuRcWjbzW2/alr0S2FbDEA+BODXMg9CD7DmvHpBXgX1BbgfNL6lEvOx8kfFoP+q2x/+StF+5LxcP8Ac7f9qT/OvRZFcIqH7TVg/tb3HzS+oxda86HyTcXj/cYD7LpP86Yar5PuJdF0+W+vrBUtosF3WZGwCcdAc16YIqt8eIG4H1jbP8Gb6qnpeklVLMxjmtsSBt38U2ShjawuBOC8zgHFClD1NCtshK1DyGDOtasfC3T941uiqB0ABPXFYZ5C/wCW9WGetsn71buq7VldLN1qk9iJ0ptGiNGrjDKCPXRClupCkRgnuOAaccoptdWtrytPcRKQq5LHPQZNUoIQ92q6/YpyUVo4MIcR4fZDkbk9MVVodF1ho7VTxAo5Jmdys7HnTKnA6dMH5e6pFNc0u5azjNu4++8sXpDCEd5326beNKWOqafcwpLb2cyo0whwU3BZfDPf0x/lROCD0QIF8eCnYZYgSB4DrCil0DW0WJ5NdDqJxIWMzgMm3oj5KL9rutRKVTiIgtNz5MjjYj4PftmphdX06SLslhkZIZY4lXqcnOMb+o+2nNtd2t3qFzbJE/aWbrzO4OAT4eHsqS5AJcD4eakNVUC+A7h5dar32A1wxMh4hBd5TKn3x9kGdvZ821SepadqN7f2ktvqiWyopDxxyMA/pbEDPgR1oqa3pbwpILeQKC0O/wCKCuSevTf5akZRZRSQB4RmVCi4JzgKDv8AIBTXPaCL3v2JHzT6wLhY47B2qHstE1CMWhv9UiuHiuRKW535iMLhVORjceG/TxrrcOTssYXVWXlR058nm3MhwDzdPTHN3+gOlPfPtObs+a3kUGcrlkbCkZPMT4bdP8q5c31hbKPOLSUCORowTuclSTnB8B7sipLP6/BJ6ecuwz4DrTBuGy9xayme1YwjYj+iZCzDcHKqoCqM+JyOlIcP8LXmkX0k899FylV9GJuqhubB2Gx+upGXXtJtZWzDOCh7PKxnYHY7Z6DIo8er6feyviCUkwdozE7FQgcDr1IB+Q0jwXe6b+Hmn+mqvRlp+E54dqkwyEkB0PL19MbUGBBIxUXHe6a0butnLysnaNlM9FPr67Y9+9PbS+j1C3W5ijeNWGeVlxjcjHzGs7XaNbDFrsB672y7FCNa+IwSpqt8dnl4I1k/mzfVVlNV7jhc8D618Uf6KF0X1Mf5hzSy/LPBeZWwGI3NCiE7mhXU8VnlqvkJXOt6s3hbIP8AEf8AKt5UVhfkJXGq6u3/ACIx/iNbqtZzSQBqD2ckQp/gC7y1xlDDBAI8DR64aH2tkp0g0MQQr2cfJnJXlGCc56e3ek+WJQQI0AJ5iAo+F4+2uXkvZx+O/Sq/qV7I8a28b4aY4JHUKOtQyTuabXKnii1zZTEtxZxk87Q55uYgKCc+O3fSJ1O3Vi0cbkn8YIBmoCJ3ibklX2OBsfb4GlH5ycqxAxtgZ39dU3VUpNgfFXhRsAxUut7a5INuEUjBPICCPA49tOjLHMoZSHHUHFV8stvEWc9Nyeu9Ghv2t1aRVbs/xkIwR66YJ5HYEpH0wAu1WOIrygMBlSWG3QnqR69z8tdkjiZSHjRlJLEFQQSepqCXVldeZX29lcj1Z3LJGAxHUnuqT07wMyqoi1nYBTJ7INlYk6f0B7fqFFCQgj7xF05dkHTGMezG1RDam0TqjtktvsnT1nHdTyO6DY5vRz35yKidUTZ6x8VK6DVzCfjk2ARQMY2UUbA6AAd+wpuhYEGnAPNUT5pHiznFRFoCKRVe4224K1r4pJ9FWI1XuN/5laz8Tk+im0gtUs/MOYSSfAeC8vk7n0aFcz66FdPWfWveQv8AlHV/Dso/pNbivSsO8hm19q5/5cf0mtuU7VmtIutUOHDkiNOPuwlsik3lC+2kbmbsYXkz8EVWr26vJnDJOypg5KYFCpKgNNlehpzJknep3h5yAw5R1wepqAjM01004LCNFwGyACc79abpfPeXUqSK3JAF5gOrk9MU9lnXkWOWMQgMOQNuCR0wBUHopXvIaLn9FZZqQjXkIGxLlVeRZGJwRgDOQfqpPsZQW/hDgZ9HAGw9dIM9wlowLKAu+EXGd89acwzSMR2iIoYZXlJz76rEFowV4XSqffUIblJBwR4+ug6OqsUj5mPce80jL2ryMFZVAAwCM83jQkeW3UurMwH4pOaj1ccF6xUNe2t3aSF7fLxyHBwpHKx+qpOztbi0QQkKOhdzuST1x7KcJdMcpNFkMu/I2Rj2UzSC3WaQFudVIIJ8D0z66sGRzm6rh+6YyOziVJt5qrffJELAY+FTeG9kBbMag7jHQDw9tEjCrGwgVZJApI7q6iBGGSwlb0jsBjNQhoAIKdYZFTWnszWw5z6QJ+TNP0I/8VWHuLhrZY+Qx8u4YHr7a6J45Mc7lGGd1JAPr2pHR3N1WMBOKtBqvcbfzL1o/mcn0VI6bctcROWYkK2BnrjFRvG38yta+JyfRXqcWqWD/YcwqkrS1rgdy8vHrQru9CunLPLXvIdtd6sfyY/rra+YKuT3eFYp5EP9Y1c/kx/XW0BtqyOlZNWqcOHJFaUfdhRuryGWJIcYUsGYNtkD/v8ARUHdlobbCcqgk5Ht8Ksc9kk0xkZnGQBgGm8mmwc6vyFmXpzMT76COJc+5yRSKVrG22qBt7VYIw7Rt6Q79zsdvf1prdQr5yZopeeQDIRmwI87c2aslwvZwu5wAozUA0kfPJP2Y5X5QQxHToceNFtFfOMhdYW6scsMUL0lIXxiPVub9eHWou4uY4gBJK2SdyCcE+smpC3uIxF2iEMQAAFNSDWdncrlY1wT+Kdqi5tDCykwK6juIOKqTyNld72Hd+lkQppfRMDfP9SU/VmkRlLBWx1Q5xR35RF6b4UDck1GpZX8EscfbZBHNuOYqPdS99K1qY0dluW5cuIeit4VE6jkA1tiuioYc04jaLs+ZCOXvJ2qFmluLi9lFuq8ocekTttTg6isoAa2kBDcwHiaVg7SJCIso0jnr0G2etNY0x3JzTnO18GFJxW9ykivcSg5yRyDBB8akFJ5jGlxKZeoDnaiJzKVeQO5YY2OSB4eyloEN1fBSzLygjJpjjrYlKPdb7yMxdkCpOGP45zzY91Gh0yeeAtG0YBPTJ28fnp5BpNvEV+ESBjbAqTjRI0CovKo6AVWMwbg1QPmt8KTtbVbWLA3Y7sfXUPxrvwXrI/M5PoqezUBxof4l6z8Uk+ikpHE1Mf5hzVOW5Y4ncV5i5TQoxG/ShXUVnVrPkTOJdW9kf11sittWNeRQ+nq36P662FWrB6bfatf2cgjVGLxBLZorEYonNQJyOtCDIrNlH6oz+aMFcpkjLAd3fVcQKZUlFqhjHUxpufcas97D20BQNyt1VvA1XLsX0RCy2jSKu4aBhg+6rMLwRYKzGWW95Hh1aJJhAfSB3UgY9xqUiImCsp2PSqs8VxdahHMts6BTvkYxVm09JI4sFDnJIFSTgAAhQPA1sElqKymSNYrgJKO/kz6PhQghkEeJgHbJ5n5QOY0jfLfJeh4dPd9/TkDAgjwxT2xN04Ky25ijUYXm6mrE9UDTtFwSve6cAuSWCyxHlUIxGxxULJb6nZEqih4y2SO/wBxq1BRjJoFAaGNqC3rUjbtyVQbU5Y1ZJredAcgEYbFOdCSS5v2mIKRJkopHX11Y3t4ZFIaNW9oqC1biCHSpPM7ONZLnoQBkL7h1NFdG0dRpOQ09KzE5nYBvKrVukGUsWvMcPEqyLRxVOtE4qv35/ORagqWUSYGfAYHTNKW3Ed/p14LPXLdoyTtJy49+2zD2UXqug1axhdDI17h/aL37LjFB4ukMD3DXaWg7Tl2q25qB4034M1kfmkn0VOBlZQysCpGQR0IqC4yP8TdZP5pJ9FZCka5tUxrhYhw5o3JYxkjcvM560K5zChXVVnbLV/IqfS1b9H9dbAprHfIt8LV/wBH9da+DmudafP9e/s5BHaIfchKZoZooNDNBrq1ZBt6IIVdwM4ztR80F9Jgu2W2BYEgHPeAR9NSwDWka3mkdg1QL65pcem3d8HnZbSRYpojHyyIxOAME47j39xp/Z6hbXN7JZRpPFcRxJLyTRhSysAQRufHp1qk6xqF/qvDbzyW1tHENRInlhTszK2MLkd53O/sqZtiZ+KdTgukspY4ryNIo726b738LaLxbwz9da92iqZzS0C3Xc9avSUgZGXbRfaDaxaOred2BCstxcwWqPJcXEUSRjLlmGR7hv7sU2+ytt9l7fTl7R5Li384jlTBjK7+vPdSOq63d2usJaWyxCMxGae5kV8WqFiAzAEg/wD93VXNZe6h1+WY6lLPPBpLyG5jVUPpZ5ccuQB6Q6eNV4dEU+pci5IwN79uQUNNTul+LC4JH6bN/XtGG1XjGwIDtn+ihOPbikriWO1t5LibtI4o1LO5ibCjxpnosk0+g6fNcStLNJbqzyP1Oc9fdio27kebjm0spZGe08z7bzdjmMuofBK9D4+6h9PTUxlfG9vwA3N87dWxMZC4vcCfhue7cnlnrtpqWm3F7ZmTECkskq8rDrg+BBx3VE6LAjaMlxJyG6u5Xk5z8LGcDfw2Py1aLhPObaSB2PK6FeuwyMVnlla6hHcXdvBKyy26l2tiM9oAfSC56HHf663fQySldTTui90hwJGeFrDsvdY7pK176hgaPdINsct+PBXe3kEFsyz7dluTnu7qruvQ6prUttJHDM9qgIErA4eRjgADrvgAbY3rlyxjuL6C7uwweCRbN5mHwo2BZSRsrgAjx3HiKQj4pFl2kVlD20QYvbyyMQY1blfkOfhBW5/btvWsjMzn60DblBzDExlpnYKd4TunuNEVJM80LmMZ6gdcV3jEZ4O1j4pJ9FKcOQNFphmeJInuZDN2ca4VQegA7h3++icWjPCGsD8zk/dNch0y6M6ekMeWuO/C/jdbPRzXDR7A7d4bPBeYz1oUDQrcIWtY8iw31f8AR/XWuisi8i/XV/0f11rgO1c70/8AXv7OQR6i+QEcGhmi0KDK1ZGzQRgrqcjY53rgUsjEFQ2wXmDEZPjygnFUw6xq03C+s6i1+6SRTrFEkMBUR4Zdw3cCCdjRig0XJM0TXsNm3JPjiMxLW7wO/LYiy8K6kvDjwE9vdyXokEKSgRxruC25wSdvYMDxqdg0h7TVb+8hbTibqdZAklsXEajOQvhnbf1USw1S78yvH1C3llFtB28dxHEVWZOTmwWOwf6d6bjiLzB/PLxbtoNSJmtEMilYY1QEZXOxJO+O6j59cxGAtl1+OFlO99TNdueeW29jbuF+++KeT6BbNNqVz2t9dm7YsYGuuyXfYA77gZ6nPsqGHC97YaDPaWbQXV3ehYp5HkKiKMHIC56jIGds+qn+k6jd2dvpFhqq3c95qHM4ld1JjG2AQd+m5z0zSUGvSpxFfwSi5eGe6W1gAZWWFkUcxCnbfbOO7NejFWXFpcD1779QOCVhqWEhpuBj1ENNhbhYnZe23BT9nALOytrUsG7CFYsjOCQuM+OM1Bw2Gqy8afZG7toorWCBoUkR8iQcpwQDv1bfwpppXEl1qF9pazXltCjrLJcpyqqsAeVFydwSRtv30vqXFi22rSW8ETiGCR47gmJSwIP4hzjp4iq0dFOzXxaS7M47ezHh/CggqI5HMAuSDfvt1Ym3XmrNmozUNIW5u4762lFvfRfBk5eZW2xhh37VBXWt3kMzXttdXciSW8UNlFcxbXMhxznlXC5Xm695IqzTXfmssVrOvPftbtM0MR5QeUenyluvQ4HqqKnpK3Rswko33ccCN46wcCP2VGromysDZRcHHrBG3qtfPiNhVPueGdanlJmdbgk552lyCcAZwe/AHyVIaXwgIpFmv3R8HIiTofaasNjfQalYw3lsWMUoJHMMMCDggj2inFXq3ptpZ0ZprNj2HVFjzPgg0fRukjl133cRsJXeg7qh+Kt+E9XH5pL+6al81EcUn+KmrfFJf3TWRpSTUMJ3jmjcgtGeC8xUKNQrq1lmFqvkX+FrH6P/APVa2KyPyL/8X9sf11rgrnWn/r39nILQUPyGowrtFFDNBlbTe9S8ktv4DewWUiuGe4mUMFj7yM9/Sqfo9ml3wvqkSRzXt5PcSRxBOYjOFIfGeVd+pO/cKu5YKCxIC9DzdN+45pvH5pY2zxRJFb28Q52SNCFGe/bqenia0mjaiQU+pHEXEbhgcdp/mCUVbYGlpIBuD3Xz2nvVU0J7NOHdXDXMr6rLZzieN8js1jXAXHyb9e7bFKrDb3M3BME6tPFJGVaOQHlOQOmQM7+3pVokgsknlvJbaAytCO0mMJJaNtt9sHPy0F1G0DCJbmNSIhKqBSMIRsQMbbDoKKesTFt2QPO/D/3+Yrz9JRlxcDib7crtLcMMhs4Kr2sRs+KeHbJtRXUWthMxZTnkHpYXqemO/wAaa31peWGrKtlFLeoZJo4pOUKfOZV9LofS5BjJ6A+FXBV09L5bxUt0u7iIyCflPM6AZJz3be80st1BP2ciSxnmjbkcJg8gOSM42GQdvVXjNUAkiF+W7b/B+yX2owODgQcLG+8km+H5u5VTXbKxsdJ07Q0Ns9400EMnIF7Rl3JJ78EttRJtKtJ04umbIeC6k7HlkVOULkjY7kHYe6rSLiyeaCTnheZg0cUvZ5YAbkBsbDeupPZqpVJIFW5diyhMCVtgxYY36jJNIyaoa2xgeezjy2JrdJta0AOxzJvmbgnkFQpna40XVPOXimeztLVbZpVyyK3LlU3AGPHBJ76u08kGm6HDDLdGCHs4rcSkFiOfHNjYnJHN78Vzn0adZsiwZbhlilym0hTl5QfZlem1PTcRRo8hlVVRxE3onZgQMYx3HFNnfUOcwthfgbnDPPzST18MoAuAAb5jc0bt4Jy2oRwR2sa28MSxRRDkSNOiijUCMEgnfvrmdqxsji95cc14LtRHFP8ANTVvikv7pqVzUTxQf4qat8Ul/dNS0o+/ZxHNNlHuHgvMuDQoUK6usvZar5GDvq/tj+utbFZN5GRtqv8AeT6DWs1znTv17+zkFoaH5DUnc3C21vJMwJCDOB1J7gPWTgVKW/DGozxh7vURbORnsbeENy+os3X3AVD3jCOGOcoXSCaOZ1HUqrgn5hn3VoUUiTxJLE6ujgMrg5DA9CKL9HKCmmhdJK0Ode2OzDcqtfPJG4BpsFSrvTtT0li0qte22Pw9vGedP7yDPyrn2CmS31ldxsvbwSKQAyuwztuMg77VomN6Z3mnW10rs9naTT8p5DcRBhnuycZxRObQERfr07zGerL9OarMr3WtI3WVGF/adtyQlZ5uQJyQIZG5R0GFztTqOz1WQZi0KRQV5MytFEeXGMdc4xXODuMptb16+0VtItdNawU9skbklmDcuFAAGM+PjTzQ+O7XWONNU4fSJFFoD2MwbPalSA+3dgn5qtRaDMfzJXuI/wBiOXmo3VoPwsA7FHyrc2Aje80me2SFeVJVQSKg8OZCcD20kLu2uJY1tohdzKuES3j7QhSMd2wG56+NTljr2r6hr+r6bDZWSpppCtcmV+V3ZeZVAxkHHXemPk94pl4nTVXfT7Wyjt5kUJbj4TEHmLHvORTH6DJf6QSvAGfvfr/6lFaLWLBfgiCx1dmjlXQmBjJMZaaJWXPXAztTeSR7DBu9NnswM4d4MoMkE4ZcgbgGtCx6qCdACRzAely09+imFtmyPH/Y/qkbVY4tHcs8iuLHkDRPa8obmBUrsdtx4dB8ldW4W+Y29jbC+k5geWJcqCOhZ+g9pNXiTSNOmcySafaO/XmaBSfop2kaRoERVVANlUYHyVVj0NI1+s+oeRxI8blSOq22s2MBVWPhS9kTnudWMczblLeBSin2tufmqMurW70u/S0vHil7VC8M0alefB3BB6EZB699X/GKqfFc8cupabap6UsTPPJ+QhUqM+0n/CabpXRtG2ke5rA0gYH+Z3yxTqaplMoBN7qMNRPFH81NW+KS/umpaojik44T1c/mkn7prD0vz2cRzRmX5Z4LzN0oUqvKVGetCuq3WWWp+Rr8Fqh/KT6K1gdKyfyN/gdU/vp9FauOlc6079e/s5BaGh+Q1GFSnCEjIdRsl/AQSo0Q7k51yVHqyM4/KqJfnEbGMAvg8oY4BPdmrBwktuNCjeJi00js1yXGG7bowI7sYAHqAoj0WY4zveDhbL+blBpIj0YFtqna5302vtTsNLiEt/ewWqMcKZpAufZ403teItGu7lbaDU7V532WLnw7d+ynfurcWKCLKeMpbrgzypprNhCX+ylqyqg/GlI5P3uRqT4t0d/J/e8LcQ2ilzahbe9I/wBqwyWJP5QLj3CtLmk4Y4k1izjNxaX19YsbiFY5OYxEEAk49eNjUVrGsaPrULaTrGnGSDz3spVaTAVVDMsuRvg8jAAb7Hwqy2TLDimWzUhwVayRcOpeXKkXWpSPfT565kOVHuXlFZTwNo1rqfCvF8t12haAs8PLIyhGCO3NgHc7Dr3VrR4j0We2Nt2syI0ZGFRkIUIrHBHTCMrbdxz3GoSxt+E9OdLLSbCSNdV5Le4jDugMcgflcgnfPK2CN9+tNa8gHDNKQqXa8U6zb+RUzQXMvbi+807fmJdIiM7Hu64z66e8TW0Wi+TTh/WdNla31INC5uo3IeUupZuY/jbjv8Ks0cWgaI97oVvog81nuIoXgMpeKRXIUvhs4IYqCOp2p/pfCvDWpWVo8VrdTWVpIfN7a7ldo4mB3whPccjB6EGnmRoN7bbr2qVY9Fu577RLC6uU5J5reOSRcYwxUE1IUQDAplf63pemMqX2oW1s7DmCyyAHHjjw9dVMzgnp8T7/AFVnFjI1zAb2U8090xllY9ck7D2AbD2VokU0dxCssMiSRuOZXRshh4giqHcJDFrmoQ2Z5rRXyfBJTu6r4jO/qJIrO9JY3OpAQbAHEb0R0c4ekIsu1DcWHHCWr/FJP3TUwaheLt+ENY+KSfumsVSD+oZxHNGJflu4LzYCcdKFEyR/4oV1RZVax5Gfweqj8tPoNazWTeRn8Hqn95PoNawK51p369/ZyC0VD8hqMM1J8IBmm1SVc+bvOiqR0Z1XDkf4R7RUJd87xJDHIY2nljh5x1XnYKSPXgmr7a20NpbRW9vGI4olCog6ACi/RijN3VJP+vIqrpKWwEfasf8AJ7dPxZ5StX1fVPvstohNtG+4iy/KOUd2B85zWq3uj219qmn6jICLmwd2jcAZIZSpUnw3z7QKp54E1DQOMZuIuGZ7cpc83nNhcsUVgxyeVwDjfcZGx9VWLl4hvdRsXmgtrCxhcyTKtyZZJ/RIC7KAFycnxxW4lcHOu04WQVoss50N9Qh8snFQ0u2t5bhlfAncoijmQ5OAScnb31Y+HuPNP1PhrVNV1HTYrWTSnxNHGobJ35eXI6kkj2k+NK6FwlrGl8fajxHcmzMOocwaFJG5ogSCDkrhvg+rrUZofk31C20rX9M1Ge2MOrYdZYGYtC6sSuQQOYbjvp7jG7M7v3SC4R7fj0x2el340myltLqQhra0R2mtQduY7cp22OMeFPbri2w+2a60fTLTTIpNNiJNxdRnl5wfwaBRkYJ3Pd4UtwppvGGgaXHosqaVJbQErDddu+VUnOOQDfGfEU2bhHXtC45uuIdBazuIb/PnFtcyGI5OCcEA94yPkpvuXI7l4XXLnyjrBwR9nZdEkS6NyLZreQFVD4zzcxGcYG3fmpnQuJDNbtMz6fNpcdo1w13ZyMezYbsjq2+TknPfg0vqVnrmo6dCtxb6bN9/BnsmdjHJDykFC7DdskEHAG1VrR/Ju1rxDql4Vj0/TLy1e2WxhmMp9MYJLYAAHUDek+7LTfBOxujDynXE2knWLWxt5LYXHZiz5nNyUzjn2HLnvx4d9OuKLWzeCe90u1nn1riO0FpDCzYXk5QSzA7KFXc+uicJaBxdwhby6TFHpt7YGUyQzvO0bJnrlQpJ8cfPVh1fT9VutT0GaGLTpVtZi91JMpDoCMExeGd/mrxLWu91JiRij8IaDJw3wvaaXJOJpYgzO4+CGY5IHqGaqmmgpZLE+08TMkwPUSZPNn37++tJA2xVR4ptkt9VsbyIBXui0EwH4/KpZW9owR7DWd6Q0pqaUvvi3HzRGglEcmrvUcahOLzjg/V/ikn0VN1B8YbcH6wfzST6KwlH9RHxHNG5flu4Feaz1oUahXU7LLWWreRr8Fqn99PoNaxWTeRg+hqo/KT6DWsjpXOtO/Xv7OQWhofkNSV1b+c2zxBijEZVx1Vgcg+4gGp234u7OJV1DTrlZgN3t1EqMe8jcEewiogUKZo/S09CC2OxB2FOnpWTn3k7vdf1HUG5bRX06273YK0z+zqEHyn2VFPp9vMxe4Ely56vPIzn5zTqhTKrS1XUuu55A3DAJ0VLFGLAJGGCSzObG8urX8mOUlf/AKtkfNT2PWtejGPOLGf1yW7Kf8LY+amNzarcqVZ2UbfB9RzRZbNZuyJkcGNyw5TjJPjUsGlauIANmPaL87pr6aJ+bU9m1DWbsFZr9YIz1W0i5Cf+okn5MU1t457Bi2n3k9sxOWHN2iOfFlbOT69jTYWMUEkc7XEgERJ9JsA58aUms4rsFxM4DADmRu4Ur9J1TniQzHusO7JeFNGG21ApQa7ryrjm05z/AEjC4PyBsUhNe6tdDFxqboh6paoIh8u7fPUcNMUDBuJW9EDfcbeqlra0FtJK4kd+0IPpHOMeFPl0zVvZb0x7AB4hNbSRA31Fw6baMcvEZGP48jszfKTmnNvPf6eQbG+lCj/Y3DGWM+rfce412hVKLSFXE7XbIb8bqZ0MbhYgKYh4wRYgLrTL1Jh1EKiRD7GyPnAqJvr241jUIrqaDzeGBGWGJnDNzN1ZsbA4AAAz30TO9d28avVWnqqphMLgADnbb4qGKiijfrBcNQHGh5eDNY+Kv9FT5qtcdvycE6uScZtyPlIodQi9THxHNTzG0TuBXnQ9aFA9Tg0K6ldZZal5GJcXOqw95VH+kVr6ivLOnanfaZO0tjdS27sMFom5SRUj9t/EQyBrV6N//VNZvSWgX1c5mY8C9kRp68Qx6hF16VxQxXmr7cuJBt9m779aa79uXEmf5bvv1xqh9lZv8g7ipvarPwr0pQrzV9uXEn9t33641z7cuJCMfZu+/XGvfZab/IO4pfarPwr0qVyRuRg9x60XszycvaSdMZzv7c15sPGXEm3+m779aaMeMuJMfy3e/rTUrejlSwWEo7kx2konZtPevQWsabJqNkYY5Qrc/MOfodsY2oaXpkljYrBJOxYMWJQ4Hz158+3LiT+2739aaMOMeJDsdbvcf+6akOgasx+iMote+Sf7Wbq6mqbL0aLcjrcTH/qH+VGjhMbZ7WR/UxzXnEcZcSH/AI3e/rTXRxlxIQM63e/rTUB6N1GXpB3JvtSP8JXoH7FnmyLluvTH/elBYP33Gf8Aprz19ufEn9t3v600f7c+JP7bvf1pq/7P0l/nHcPJVvWab8B716AOnMXz5y/ToNhXfscw/wB4avP3258Scv8ALV7+tNGHGXEmR/pq8/WGlGjtJH/mH/yPJL6xTfgPevQawGNcERtv+Mpqm+UgdlwdfNzqObkTlUdcsKzH7b+Ij11i7P6Q0x1PXdV1G1MN5fzzxlgSrtkZFS09FXNka6SUEA4iw8k189O5pDWEHioQgZoVzNCjqpr/2Q==" alt="logo"></p>
<p>以往的时候，要想到一些<strong>感想</strong>的话，常常会为了拽文润色去查阅资料看了又看。这次，是关于<u>微信公众号</u> ，这个东西在过去的两三年内，彻彻底底融入了我们的生活。开始时候也许是广而告之，现在的话众多的公众号是个无所不能自动推送服务的<code>浏览器</code>了。</p>
<blockquote>
<p>我到底想说什么？</p>
</blockquote>
<p>不要着急，题目说了诗篇辣鸡感想！我先解释下什么叫做“辣鸡感想”？</p>
<p>我说的辣鸡感想，有两层含义。一个是这种感想不多，<a href="https://www.baidu.com/link?url=rU7DR8XyHBnq8N_UMG88rYhKjGmHdPBqiJdpOu2d68fsRRVUoq8FXeFFtlNScCgG0hqQzJP4GThGzx3INDYWfSPmBp0c4hX-hPssykbt-E3&amp;wd=&amp;eqid=8cf188830001d6c7000000035859313b" target="_blank" rel="external">量</a>层面来说少得可怜甚至只是句感叹词，也许就是：F**K!；另一个含义就有意思了，是我个人的思考和见识吧。233</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1612-1701/xiaochengxu.png" alt="lll"></p>
<p>最近，微信的所谓的<a href="https://mp.weixin.qq.com/wxopen/waregister?action=step1" target="_blank" rel="external">程序号</a>是红红火火，懂不懂开发的搞不搞微信的反正网上是一片呼声，都觉得这是个新的*^%$&amp;+_<em>-=-。。。。反正是个</em><em>牛逼的东西</em>*。几张<code>微信教父</code>张小龙的微信朋友圈截图也被放出来，一些论坛（专业的IT编程教育类的）也是被相关话题刷屏。说话办事孰优孰劣不是我们讨论的问题，这一哄而起的现象倒是值得深思！</p>
<p>按微信自己的话说，小程序是一种<code>不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用</code>。意思就是说，未来在微信内部也许会有一个小程序但不是你过去朋友圈点开过的H5推广秀，这个程序带来的体验堪比手机app商店下载的app应用。</p>
<p>nb（一个形容词）</p>
<p>好了，跪舔结束开始说正事的内容，也就是感想。</p>
<p>我当时就想到了一句古话和开头提到的那本书。古话是：人无远虑必有近忧。微信发展（改革）自己，相信是一群人远虑的体现吧。书，我其实只是断章取义取了个名字。</p>
<blockquote>
<p>谁动了我的奶酪？？？</p>
</blockquote>
<p>恐怕自己的奶酪，别人谁动了都不好，显而易见的事情。在九月下旬二十几号小程序火热的那几天，我就看到了呼应（似乎是呼应）我感想的一些文章，不再列举但是我说下，意思就是微信（腾讯）此举会不会动了别人的奶酪？</p>
<p><u>往大了说动没动了苹果App Store的奶酪各大安卓市场的奶酪？小了说会不会影响各app的下载量卸载量的微妙变化？</u></p>
<p>我也不是没事扯淡，更不是太监操心，小程序的推出我所在乎的事情只有一个：<strong>创业者门槛的降低</strong>。现在各方面的消息看来，跨平台+降成本+更多的试错机会+技术门槛低等等因素都是让更多创业者收益的，虽然最终的话语权在于腾讯有多开放。</p>
<p>underline的那两个问题，我想除了预测没人能回答。小程序正式推出后，一切才知分晓。。。为时尚早的定论咱不说也不搬运，拭目以待以后的故事吧。</p>
<p>最新的消息大概是，12月中旬马化腾也表示了，会在春节前推出小程序。</p>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 情感 </tag>
            
            <tag> 杂谈 </tag>
            
            <tag> WeChat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端该了解的'http'故事]]></title>
      <url>http://zrdsj.cc/2016/09/30/Fe-http/</url>
      <content type="html"><![CDATA[<p>算是聊一聊技术，顺便谈谈一个前端该知道的http故事。。。</p>
<a id="more"></a>
<p>时间已经过了很长了，都没写几个字。。。也是不好意思。。哈哈最初想到写篇这样的博客是因为物联网还不是因为自己是个前端。</p>
<p>在之前的那篇物联网博客里面，有提到物联网的核心是联网，当然了在那个时候才发觉了一些互联网的协议或者说是科学研究的协议等的存在感，比如说<code>http协议</code>。</p>
<p>这次是想说一些一个前端该懂得的http知识，该说多少我也拿捏不好。一度我是这样想的—&gt;找几个知乎链接+博客地址，贴出来over2333</p>
<p>哈哈哈，好吧。。。还是自己写几句吧。</p>
<h3 id="前奏">前奏</h3>
<p>先说说<em>为什么</em>这次会说<code>前端的http故</code>事，直接说http不行么？为什么现在说http？</p>
<p>OK，是这样的。</p>
<blockquote>
<p>如今我自己在实习并且在学习新的技术（想对自己而言2333），不管以后的话是做什么，现在的学习情况表明了就是前端之路。未来前端的趋势我说不太好，但我知道。。。<code>无论web技术再如何发展，理解web程序间通信的基本协议很重要，理解web应用程序的内部工作就必然会有http的事情。</code>关于http前端之外的更多事情，也许以后我会以<code>计算机网络</code>的视角再写一篇http？2333</p>
</blockquote>
<blockquote>
<p>现在说http是因为：在了解了一个web世界的多个角落之后，在某一天总会有些原因驱动着你去做些不同往日的事情，比如联通彼此产生信息的交流。。。so,it’s the Time.</p>
</blockquote>
<p>说完了前奏，接下来就是主要的内容了。讲道理，<code>http基础内容</code>完全可以在百科上、在某个硬盘上的文档里、在某篇博客里、在互联网上的不明奇妙的角落里学习到······我所总结的点并不全面，只是常用到的几个点。😉</p>
<p><strong>顺应博客的标题，仅仅说下前端应该知道的掌握的基本原理，更深层次不再进行探讨。</strong></p>
<p>赛高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这篇博文中的诸如是http或者https或者是HTTP等大小写拼写问题，请理解精神！</div></pre></td></tr></table></figure>
<p>3个部分：</p>
<ol>
<li>初级
<ul>
<li>请求/响应</li>
<li>状态码</li>
<li>post请求发送</li>
</ul>
</li>
<li>中级
<ul>
<li>how?</li>
<li>Session</li>
<li>Ajax与同源策略</li>
</ul>
</li>
</ol>
<ol start="3">
<li>高级
<ul>
<li>https</li>
<li>Web Sockets</li>
<li>http2</li>
</ul>
</li>
</ol>
<h3 id="1111111">1111111</h3>
<h4 id="请求响应">请求/响应</h4>
<h5 id="http是啥">http是啥</h5>
<p>HTTP ，是<strong>超文本传输协议</strong> （Hypertext Transfer Protocol ）的缩写。</p>
<p>网上都有大量的图片，视频，HTML 页面等等这些东西飞来飞去，从服务器上送到我们的浏览器里，这个过程都是实用 HTTP 协议来传输数据的。所以理解 HTTP ，不管是对于做网站，还是做 Web App ，都是开发者非常重要的基本功。</p>
<p>Web 客户端和服务器端</p>
<p>Web 内容都是存储在 Web 服务器上的，Web 服务器都是使用 HTTP 协议的，因此也被称为 HTTP 服务器。HTTP 服务器存储了各种类型的数据，如果 HTTP 的客户端（浏览器）发出<strong>请求</strong>的话，服务器就会返回数据给客户端，叫做<strong>响应</strong>。<strong>请求（ request )和响应（ response ）都是重要的术语。</strong></p>
<p>HTTP 的服务器和客户端是<a href="https://zh.wikipedia.org/zh-cn/%E4%B8%87%E7%BB%B4%E7%BD%91" target="_blank" rel="external">万维网</a>（ World Wide Web ）的基本单元。其实我们每天都在使用 HTTP 的客户端，最常见的客户端就是浏览器。浏览一个页面的时候，浏览器会向服务器发出一个 HTTP 请求。等到服务器响应返回之后，浏览器再去处理响应数据，以美观的形式展示给用户。</p>
<h5 id="请求响应">请求/响应</h5>
<p>HTTP 的开始是浏览器发出请求。但是请求的是什么呢？<strong>是服务器上的资源，英文叫 Resource 。</strong></p>
<p>对应的每一个资源，都有一个 URL ，也就是<strong>统一资源定位地址</strong>，指向这个资源。不过资源分两种：一种是静态 资源，也就是各种文件了，最常见的就是静态 HTML ，但是也可以是 PDF ，json，MP4 文件等等。另外一种，就是动态 资源，也就是 URL 指向的地方不是一个文件，而是一段代码的入口，服务器经过运算后，才返回运算结果给客户端。</p>
<p>所以， 我们有 <a href="http://xxxxx.com/23333.txt" target="_blank" rel="external">http://xxxxx.com/2333.txt</a> (雷同纯属巧合)，这个 URL 就是指向一个静态资源的。如果是 <a href="http://xxxxx.com/username" target="_blank" rel="external">http://xxxxx.com/username</a> 这个可能就是指向动态资源的，后台对应的可能就是一个 API 。</p>
<p>发起一个 HTTP 请求很容易。比如你说你想用浏览器访问 <a href="http://zrdsj.cc">zrdsj.cc</a> 。你所需要做的仅仅是启动浏览器然后在地址栏输入 <a href="http://zrdsj.cc/">http://zrdsj.cc/</a> ，然后你就可以在页面中看到本站的首页了。</p>
<p>那么底层发生了什么呢？首先，浏览器作为 <strong>HTTP Client</strong> ，发出了一个<strong>请求</strong>给服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET http://zdsj.cc/</div></pre></td></tr></table></figure>
<p>上面的 GET 是 HTTP 方法，这个后面还会介绍。</p>
<p><a href="http://zrdsj.cc">zrdsj.cc</a> 的服务器收到请求后，给出<strong>响应</strong>。响应中带有各种数据，html/css/图片 等等，返回到浏览器。 浏览器是理解这些文件格式的，所以可以最终展示一个美观的网页给用户。</p>
<p>用一些工具，可以清楚看出这些变化。有浏览器的插件，也有专门的软件，还有命令行工具。这里我们简便起见，达到目的即可，使用Chrome的开发者工具就可以。</p>
<p>我们访问这个网站 <a href="https://office.qq.com/" target="_blank" rel="external">https://office.qq.com/</a> 作为举例。</p>
<p>在控制器中我们看到了下列的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Request URL:https://office.qq.com/</div><div class="line">Request Method:GET</div><div class="line">Status Code:200 </div><div class="line">Remote Address:127.0.0.1:8888</div></pre></td></tr></table></figure>
<p>这都是极为重要的信息，先不做陈述。我们看下<code>请求部分</code>和<code>响应部分</code>的截图。</p>
<p>请求部分的截图：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/http_Get.png" alt="请求信息"></p>
<p>下面是响应信息：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/http_Get-resp.png" alt="响应信息"></p>
<ol>
<li>
<p>我们这次的请求实际上，是一个<u>GET</u><strong>请求</strong>，就是想要从服务器上 GET （拿到）一些内容，而不是想去修改服务器数据。到底要 GET 哪些资源，就是后面的 URL 这一项来指定了。也可以说我们的<strong>HTTP 方法</strong>（ <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="external">HTTP Method</a> ）是 GET 方法，当然还有其他种类的方法。</p>
<p>我们可见看出在Request Headers（请求头）中，有许多项，可以参考的列表在<a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8#.E5.B8.B8.E8.A7.81.E7.9A.84.E9.9D.9E.E6.A0.87.E5.87.86.E8.AF.B7.E6.B1.82.E5.AD.97.E6.AE.B5" target="_blank" rel="external">这里</a>。</p>
</li>
<li>
<p>响应也有对应的信息，<strong>响应头部</strong>、<strong>状态行</strong>、<strong>响应主体</strong>（response body/payload）等。基本的格式在上面的截图也有了：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ header 名]: [ header 值]</div></pre></td></tr></table></figure>
<p>​	在一些专门的工具中（除Chrome控制台之外），一般可以直接显示出<strong>状态行</strong> （ status line ）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP[版本号] [状态码] [状态信息]</div><div class="line"></div><div class="line">比如</div><div class="line">HTTP/1.1 200 ok</div></pre></td></tr></table></figure>
<p>​	其中含有的数据有一项为状态码，在稍后我们会讲道。</p>
<p>​	<strong>响应主体</strong>很好理解了，就是代码文件了，在浏览器会显示成相应的页面。</p>
<h5 id="无状态协议">无状态协议</h5>
<p>前面 HTTP 的基本格式介绍完了，再补充一个小点：</p>
<blockquote>
<p>HTTP 是一个无状态的协议</p>
</blockquote>
<p>所谓**无状态（ stateless ）**意思就是：对于之前的交互没有记录。每次交互能用的信息就只有这次交互所携带的信息。</p>
<p>换句话说，HTTP 协议是没有办法记住之前的一次请求的，所以也没有办法根据前一次请求来辅助后一次请求。当一个 Web 应用 看起来似乎可以记住之前的交互，例如，可以记住你的用户名，其实它采用的技巧已经超出了 HTTP 本身。HTTP 的信息就好像 是可以自销毁的，每次读取完毕，立刻就消失了。总之，HTTP 就是无状态的，也就是不能记录或者维持某种状态的。</p>
<h4 id="状态码">状态码</h4>
<p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#3xx.E9.87.8D.E5.AE.9A.E5.90.91" target="_blank" rel="external">维基百科</a>的内容，<a href="http://www.w3school.com.cn/tags/html_ref_httpmessages.asp" target="_blank" rel="external">w3</a>的内容。</p>
<p>简单介绍：</p>
<ul>
<li>20x 的状态码都代表某种成功状态。最常见的 200 ，它的意义，就正如它后面跟的 状态信息 一样，代表一切 OK 。</li>
<li>30x 的状态码，意味着资源已经被移动到其他地方了，但是响应中给出了应该跳转到哪里去找到这个资源。这个行为的 术语就叫做 <strong>redirect</strong> （重定向）。</li>
<li>40x 的代码也都是代表一种<strong>客户端请求错误</strong> 。一个最常见的状态码 404 ，它的意 义也跟它后面紧跟的状态信息所说的 一样：Page Not Found （页面未找到）。</li>
<li>50x 的状态吗也很常见。返回的如果是这一系列的状态码，就意味着 服务器端在处理请求的时候出错 。50x 出现，对于开发者，一般意味着服务器端代码出了错误。</li>
</ul>
<h4 id="post请求发送">post请求发送</h4>
<p>GET 请求是只读的，意思就是只能用来从服务器上获取信息。而相对的 POST 请求<code>就是用来修改服务器的，例如修改数据库记录，上传一个文件等等。</code></p>
<p>GET 请求中，我们一般通过对 url 添加参数的形式传递额外的参数给服务器端，但是 POST 请求的情况下，通常我们都会把要传递的数据放到 request body （请求体）中。</p>
<p>使用 POST 请求通过 request body 携带数据到服务器端，有四种方式:</p>
<ul>
<li>普通 html 表单 form 提交方式：application/x-www-form-urlencoded</li>
<li>上传文件惯用方式：multipart/form-data</li>
<li>通过 fetch/axios 等客户端提交 JSON 数据：application/json</li>
<li>还有一种方式是 text/xml ，不常用了</li>
</ul>
<p>前三种是比较重要的。</p>
<h5 id="applicationx-www-form-urlencoded">application/x-www-form-urlencoded</h5>
<p>这是最常见的 POST 提交数据的方式了。浏览器的原生 <code>&lt;form&gt;</code> 表单，如果不设置 <code>enctype</code> 属性，那么最终就会以 <strong>application/x-www-form-urlencoded</strong> 方式提交数据。</p>
<p>请求类似于下面这样（无关的请求头在本文中都省略掉了）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BASHPOST http://www.example.com HTTP/1.1</div><div class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</div><div class="line"></div><div class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</div></pre></td></tr></table></figure>
<ul>
<li>首先，Content-Type 被指定为 application/x-www-form-urlencoded；</li>
<li>其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</li>
</ul>
<p>很多时候，用 Ajax 提交数据时，也是使用这种方式。例如 <a href="http://jquery.com/" target="_blank" rel="external">JQuery</a> 和 <a href="http://www.qwrap.com/" target="_blank" rel="external">QWrap</a> 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。</p>
<h5 id="multipartform-data">multipart/form-data</h5>
<p>又一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <code>&lt;form&gt;</code>表单的 <code>enctype</code> 等于 <code>multipart/form-data</code>。</p>
<p>一个请求示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">BASHPOST http://www.example.com HTTP/1.1</div><div class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</div><div class="line"></div><div class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</div><div class="line">Content-Disposition: form-data; name=&quot;text&quot;</div><div class="line"></div><div class="line">title</div><div class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</div><div class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</div><div class="line">Content-Type: image/png</div><div class="line"></div><div class="line">PNG ... content of chrome.png ...</div><div class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</div></pre></td></tr></table></figure>
<p>这个例子稍微复杂点。</p>
<ul>
<li>首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。</li>
<li>然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，以及请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 <code>--boundary</code> （------WebKitFormBoundaryrGKCBY7qhFd3Trw）开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。</li>
<li>如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 <code>--boundary--</code> 标示结束。关于 multipart/form-data 的详细定义，请前往 <a href="http://www.ietf.org/rfc/rfc1867.txt" target="_blank" rel="external">rfc1867</a> 查看。</li>
</ul>
<p>这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p>
<p>上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <form> 表单也<a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4" target="_blank" rel="external">只支持这两种方式</a>（通过 <code>&lt;form&gt;</code> 元素的 <code>enctype</code> 属性指定，默认为 application/x-www-form-urlencoded。其实 <code>enctype</code> 还支持 <code>text/plain</code>，不过用得非常少）。</form></p>
<p>随着越来越多的 Web 站点（尤其是 WebApp），全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。</p>
<h5 id="applicationjson">application/json</h5>
<p>application/json 这个 Content-Type 作为响应头并不新鲜，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。</p>
<p>由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p>
<p>JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。</p>
<p>Google 的 <a href="http://angularjs.org/" target="_blank" rel="external">AngularJS</a> 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JSvar data = &#123;&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]&#125;;</div><div class="line">$http.post(url, data).success(function(result) &#123;</div><div class="line">    ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最终发送的请求是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BASHPOST http://www.example.com HTTP/1.1 </div><div class="line">Content-Type: application/json;charset=utf-8</div><div class="line"></div><div class="line">&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</div></pre></td></tr></table></figure>
<p>这种方案，可以方便的提交复杂的结构化数据，特别适合 <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful 的接口</a>。</p>
<p>各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。一些服务端语言还没有支持这种方式，但一些相应的框架已经开始做出改变了。</p>
<h5 id="textxml">text/xml</h5>
<p><a href="https://imququ.com/post/pingback-and-xmlrpc.html" target="_blank" rel="external">XML-RPC</a>，它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTMLPOST http://www.example.com HTTP/1.1 </div><div class="line">Content-Type: text/xml</div><div class="line"></div><div class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</div><div class="line">&lt;methodCall&gt;</div><div class="line">  &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</div><div class="line">  &lt;params&gt;</div><div class="line">    &lt;param&gt;</div><div class="line">      &lt;value&gt;&lt;i4&gt;233&lt;/i4&gt;&lt;/value&gt;</div><div class="line">    &lt;/param&gt;</div><div class="line">  &lt;/params&gt;</div><div class="line">&lt;/methodCall&gt;</div></pre></td></tr></table></figure>
<p>XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 <a href="http://codex.wordpress.org/XML-RPC_WordPress_API" target="_blank" rel="external">XML-RPC Api</a>，搜索引擎的 <a href="http://help.baidu.com/question?prod_en=master&amp;class=476&amp;id=1000423" target="_blank" rel="external">ping 服务</a>等等。JavaScript 中，也有<a href="http://plugins.jquery.com/xmlrpc/" target="_blank" rel="external">现成的库</a>支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。可能一些人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。</p>
<h3 id="2222222">2222222</h3>
<h4 id="how">how?</h4>
<p>我这里想表达的是一个技术是如何实现的？</p>
<p><a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="external">Cookie</a></p>
<p>前面我们已经说了：HTTP 的一个特点就是它是<strong>无状态</strong>协议（easy come, easy go）。</p>
<p>但是有时候为了实现类似电商网站购物车这样的应用，必须要求网络应用保持一种状态，所以 cookie 就被发明出来了。</p>
<h5 id="general">general</h5>
<p>通常来讲：：：：</p>
<p>比如我们现在访问 <a href="https://atom.io/" target="_blank" rel="external">atom.io</a> ，在 Chrome Devtools 的 Network 标签下可以看到，仅仅是打开首页， 就发出了很多个请求。其实具体的过程是这样，浏览器首先发出的是一个请求，也就是请求 <a href="http://atom.io" target="_blank" rel="external">atom.io</a> 的首页， 但是问题的是首页的 html 中有指向图片，css ，js 的一些链接，这样，浏览器就会自动发出后续的请求，以保证 最终页面是显示完整的。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/atomio.png" alt="atom"></p>
<p>上面所说的这些请求，都是 stateless 无状态的，也就是服务器收到后续请求后，根本不记得之前也收到过相关的请求。 也就是服务器根本不记得我的浏览器。 无状态就是<strong>随时忘记</strong>，也就是服务器没有办法去始终跟踪同一个浏览器。但是这样 比如说我们想用浏览器添加多个商品进购物车，那么服务器是没有办法记录，后添加的商品是不是跟前面添加的商品是同一个 浏览器请求的。</p>
<h5 id="then">then</h5>
<p>后来：：：：</p>
<p>也就真是为了解决购物车的这种需求，为了达成浏览器跟服务器之间的一种<strong>持续连接状态</strong>，让服务器知道到底用户是谁， 在1993年的时候，网景公司发明了 cookie 这个技术。</p>
<p>Cookie 就是平时所说的曲奇饼干，浏览器的 Cookie 可以翻译成<strong>浏览器的一个小文件</strong>。文件中的信息，会被设置成 http 请求 的一个 header ，header 的名字就叫 <strong>Cookie</strong> ，让浏览器对这个 header 做特殊对待，每次发出请求的时候都会携带着 cookie 信息给服务器。</p>
<p><em>那么浏览器的 cookie 小文件的信息是从哪里来的呢？</em></p>
<blockquote>
<p>Cookie 一般都是在服务器端设置的，通过 http 响应的头部返回给浏览器，浏览器拿到这些信息就可以保存到自己的 cookie 文件中</p>
</blockquote>
<p><em>cookie的作用？</em></p>
<blockquote>
<p>一旦客户端有了服务器发来的特殊信息，例如 <code>id=xxx</code> ，那么就等于服务器已经认定这个客户端了。客户端每次发请求都带着这些信息， 就可以到服务器上认领属于本浏览器的各种资源了。这样客户端和服务器端就建立起了一种连接状态，HTTP 的<strong>无状态</strong>的问题就被解决了。</p>
</blockquote>
<h4 id="session">Session</h4>
<p>先来普及下概念。</p>
<blockquote>
<p>什么是Session？—是会话！</p>
</blockquote>
<p><strong>会话</strong>这个词也本身意思就比较宽泛，容易被外行泛用。维基百科是<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="external">这么说的</a>。通俗点讲，从效果切入应该更合适。那么：</p>
<blockquote>
<p>会话开始和结束，就意味着服务器从认识一个浏览器到不再认识这个浏览器（url效用失效）。</p>
</blockquote>
<h5 id="实现会话的技术机制">实现会话的技术机制</h5>
<p>方法不唯一，最常见的一个方式是这样：</p>
<ul>
<li>第一步，准备建立会话的时候，服务器会在自己的内存里创建一个新的变量，例如这个变量叫做 session-3333 ，</li>
<li>第二步，服务器把这个会话的 id 也就是 3333 发送到我的浏览器，浏览器会把这个 id 保存到 cookie 中</li>
<li>之后，每次我的浏览器再去访问服务器的时候，都会携带 cookie 中存放的 3333 这个会话 id 值，这样服务器就认识 这个浏览器了</li>
<li>服务器端的 session-3333 变量中可以存放任意的会话数据，例如：我的用户名，我购物车里有哪几件商品等等</li>
<li>每次浏览器访问服务器，都可以凭借自己的会话 id 去服务器的 session-3333 变量中去认领属于我的信息</li>
</ul>
<p>每一个请求都会包含这个会话 id ，这样服务器就能唯一确认你这个客户端浏览器。 这样，直到会话过期，客户端和服务器都是互相认识的，都保持有效的链接。</p>
<h5 id="会话的意义">会话的意义</h5>
<p>说的抽象点：<strong>会话可以让无状态的 HTTP 协议保持特定的状态</strong>。</p>
<p>这种在客户端与服务器之间传递<strong>会话 id</strong>的机制，能让服务器创建一种各次请求之间的持续连接状态。Web 开发人员利用这种人造的状态，来构建一些”有状态“的应用场景：例如用户处于一直登陆的状态，购物车里面之前添加的商品，后续访问中还有等等。</p>
<p>不过即使这样，每一个 HTTP 请求本质上来说还是无状态的，各次请求之间并不知道彼此的存在。</p>
<h5 id="会话数据存在哪里">会话数据存在哪里？</h5>
<p>一句话来讲：是服务器上的某个地方。</p>
<p>之前所讲的cookie是在内存里，但其实有时候，可能会存在某个持久化存储介质上，比如数据库或者键 / 值存储。会话数据存在哪里不是我们需要关心的。现在重要的是要理解会话 id 存储在客户端，它是访问存储在服务器上的会话数据的 “钥匙”。</p>
<h5 id="会话过期">会话过期</h5>
<p>服务器上有多少个浏览器在访问，就会在自己内存中创建多少了类似 session-3333 这样的变量。但是，还有一点非常重要，在一个会话里发出的会话 id 是唯一的，而且有一个很短的过期时间。那什么情况下会话就会过期呢？</p>
<ul>
<li>手动删掉 cookie 中的会话 id （在 chrome devtools 里，右键 cookies 然后删除它）</li>
<li>点一个网站的退出登录按钮</li>
<li>关闭网站有时候也通常能结束会话</li>
</ul>
<p>当然，讨论到这里，会话过期的本质我们其实是知道的：<strong>用客户端 cookie 中的 id 找到服务器端对应的 session 了。</strong></p>
<h5 id="会话劫持">会话劫持</h5>
<p>会话 id 作为一个唯一的令牌来唯一标识一个会话。通常，会话 id 是作为 cookie 存储在计算机上的一个随机字符串.。很多 Web 应用的用户认证系统所在做的事情，当用户的用户名和密码匹配之后，会话 id 会存储在用户的浏览器里，这样我的下一个请求就不用重新认证了。</p>
<p>不幸的是，如果一个攻击者拿到了我的这个会话 id ，他就会跟我共享这一个会话，那服务器就会把他当成我，我的所有权限， 他都不需要知道我的用户名密码，都可以获得了。</p>
<p>防止会话劫持是安全问题，总之就是用各种方法让当前会话 id 作废，然后重新创建新会话。</p>
<h4 id="ajax与同源策略">Ajax与同源策略</h4>
<h5 id="ajax">Ajax</h5>
<p>AJAX 是 ”异步 javascript 和 XML “ 的简称（ Asynchronous JavaScript and XML ）。它的主要特点就是允许浏览器发送请求和处理响应的时候</p>
<blockquote>
<p>不用刷新整个页面</p>
</blockquote>
<p>举个例子，如果你访问一个网站，服务器会给你一个响应生成你看到的主页。正常情况下，每当用户点一个连接，或者提交一个表单，页面都会整个去刷新，这样有两个明显的弊端：</p>
<ul>
<li>用户体验不好，因为页面会闪烁</li>
<li>新页面很多时候跟老页面相似度很高，整个页面刷新其实很多工作量是没必要的（浪费网络资源）</li>
</ul>
<p>当使用 Ajax的时候，页面就不会刷新。</p>
<p>Why？</p>
<blockquote>
<p>Ajax 请求本质上也就是一个普通的请求，服务器也会给出响应。跟普通的请求的区别也就是页面不会刷新了。</p>
</blockquote>
<p>但是页面要是不刷新，那么响应数据如何加载呢？</p>
<blockquote>
<p>这些请求的响应会通过一些<strong>回调函数</strong>来处理。就是把一些逻辑存放在mou个函数里，当某个条件被触发之后再回来执行你前面存放的逻辑。当响应返回的时候，<strong>回调函数</strong>就会被触发。<strong>回调函数</strong>里面写一些可以用来更新页面的 JS 语法，配合上刚刚返回的服务器端的数据，就可以实现替换页面局部的效果了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">当代 Web 应用，无刷新几乎已经成为标配。尤其是单页面概念盛行之后，这个趋势就更明显了。另外，传递数据的格式原来用 XML ，现在大家也都用 JSON 了。</div><div class="line"></div><div class="line">AJAX 请求就像是普通请求，发送到服务器的请求依然跟普通请求一样有着一个 HTTP 请求该有的所有组成部分，并且服务器处理 AJAX 请求的方法跟处理普通请求也是一样的。</div><div class="line"></div><div class="line">唯一不同就是，不是通过浏览器刷新来处理响应，而通常由客户端的一些 javascript 代码来处理。</div></pre></td></tr></table></figure>
<h5 id="同源策略">同源策略</h5>
<p>同源策略（ Same-origin policy ）是一个重要的概念，它<strong>允许来自同一站点的资源进行互相访问而不受限制，但是会阻止其他不同站点对文档/资源的访问。</strong></p>
<p>同源策略涉及的是访问文件内容，而不是链接，你可以随意链接到任何 URL。 同源策略是防范会话劫持的重要手段，是 web 应用安全的基石。</p>
<p>参考：<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">1111</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="external">2222</a></p>
<h3 id="3333333">3333333</h3>
<h4 id="https">https</h4>
<p><a href="https://zh.wikipedia.org/zh-cn/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">超文本传输安全协议</a></p>
<p>通过 HTTPS 访问资源的时候，通常以 <code>https://</code> 开头而不是 <code>http://</code> ，而且通常在边上都会有个小锁子的图标。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1702-1703/douban.png" alt="douban"></p>
<h5 id="干嘛要用">干嘛要用？</h5>
<p>HTTP 是明文传输的，所以如果有人在网上截获了你的数据流，那么用户的密码等各种信息就会暴露。这样你就知道为啥大家都拼命上 HTTPS 了吧。。。</p>
<p>如果有用户登上你的网站买东西，需要输入信用卡的一些信息，然后他看到你的网站没有用 HTTPS ，也就是说是不安全的，那他就很有可能放弃这次购买。</p>
<p>HTTP 请求可以包含会话 id ，它唯一地标识你的浏览器和服务器之间的联系，所以如果别人复制了这个会话 id ，他们可以手动创建到服务器的请求，进行伪装，甚至都不需要你的用户名和密码就可以自动登陆。</p>
<p>这种情况就需要安全的 HTTP 也就是 HTTPS 来帮忙。通过 HTTPS 发送的请求和响应在发送前都会被加密。这意味着如果一个恶意的黑客监听 HTTPS 通信，他得到的信息都是加密的，就是截获了也难看懂。</p>
<h5 id="how">how?</h5>
<p>HTTPS 通过 <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">TLS</a> 的加密协议来加密消息。在 TLS 开发完成前，早期 HTTPS 使用 <code>SSL</code> （ Secure Sockets Layer ）。这些加密协议在加密数据之前，需要先使用证书来与远程服务器进行通信来交换安全密钥。</p>
<p>你的浏览器有了服务器颁发的证书，这样就可以按照一种跟服务器约定好的方式把要传输的信息进行加密，然后传输给服务器。 这样有了约定好的加密方式，安全的信息通道也就建立起来了。</p>
<h4 id="web-sockets">Web Sockets</h4>
<p>Web Sockets 是 HTML5 的新增功能之一。换句话说，Web Sockets 是浏览器提供给我们的一种通讯机制。</p>
<p>Web Sockets 技术到底算不算 HTTP 协议的一部分？</p>
<blockquote>
<p>不算！可以认为他们就是两套协议。但是毕竟二者紧密相关，所以聊 HTTP 就不能不聊 Web Sockets 。可以把 Web Socket 看成浏览器为了弥补 HTTP 协议的不足而打的一个大补丁。</p>
</blockquote>
<h5 id="web-sockets-要解决">Web Sockets 要解决？</h5>
<p>相对于 HTTP 这种非持久的协议，Web Sockets 是一个持久化的协议。</p>
<p>HTTP 协议特点就是简单直接：<code>客户端发请求，服务器给一个响应，然后就各找各妈，谁也不认识谁了。</code>这种关系不但健忘，而且是单向的，客户端必须主动发请求，服务器端不能给客户端主动推送信息的。</p>
<p>如果只是基于基本的 HTTP 协议，来做个网络聊天室是很难的。比如，我跟你在聊天，你那边发了新信息，我的浏览器怎么能知道呢？服务器不能给我主动推送信息的弊端就暴露出来了！</p>
<p>Web Socket 出现之前，往往是通过一些瘸腿的技术例如 <a href="http://www.cnblogs.com/hoojo/p/longPolling_comet_jquery_iframe_ajax.html" target="_blank" rel="external"><strong>long poll</strong></a> 和 <strong><a href="https://segmentfault.com/a/1190000005032921" target="_blank" rel="external">ajax 轮询</a></strong> 来实现，每次查询都是开启一次连接，然后再断开，耗费资源，效果差。</p>
<h5 id="web-sockets-带来的是两个改进">Web Sockets 带来的是两个改进：</h5>
<ul>
<li>客户端只要先发起一次 HTTP 请求，那么客户端和服务器这对朋友就算交上了，也就是建立了持久连接。</li>
<li>以前都只能是客户端主动问，服务器端只有回答的份儿，现在不是了，服务器如果想主动说话，客户端也听在监听着。</li>
</ul>
<h5 id="实际方案">实际方案</h5>
<p>Web Sockets 的确很棒，但是毕竟是新特性，总有些幺蛾子出现。</p>
<p>所以实际项目中可以通过 <a href="http://socket.io" target="_blank" rel="external">socket.io</a> 来更好的使用 Web Socket 技术。<a href="http://haoduoshipin.com/v/99.html" target="_blank" rel="external">http://haoduoshipin.com/v/99.html</a> 用 <a href="http://socket.io" target="_blank" rel="external">socket.io</a> 搭建一个项目，演示了效果。</p>
<h4 id="http2">http2</h4>
<p>维基百科<a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="external">这样说</a>。</p>
<p>通俗上讲，1999年的http1.1版本后的首个更新在2015年5月开启了正式版的发布—http2。在保留与http1.1的完全语义兼容情况下，http2的目标包括异步连接复用，头压缩和请求反馈管线化。</p>
<p>基本上，这篇 <a href="https://imququ.com/post/http2-resource.html" target="_blank" rel="external">https://imququ.com/post/http2-resource.html</a> 包含了详细的http2内容，入门进阶都可以在其中找到路线。</p>
<h3 id="bye">bye</h3>
<p>其实内容上讲，这篇博客算是入了门，入了http世界的大门。要学的还有很多。</p>
<p>推荐网络课程 <a href="https://haoqicat.com/http-with-peter" target="_blank" rel="external">https://haoqicat.com/http-with-peter</a></p>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> http </tag>
            
            <tag> 前端 </tag>
            
            <tag> https </tag>
            
            <tag> Ajax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS-面向对象编程sth]]></title>
      <url>http://zrdsj.cc/2016/09/27/Js-Object-oriented/</url>
      <content type="html"><![CDATA[<p>这次实实在在做了一次搬运工，内容是从大神阮一峰的网站上搬来的。手打成博客，希望可以增加一些自己的理解，😄.</p>
<a id="more"></a>
<h3 id="关于阮一峰">关于阮一峰</h3>
<p>一般来讲，在这个领域里不知道阮老师的，不应该很多。老师在编程学习上的造诣贡献很高，在我看来是很有价值的，对我帮助也很大。</p>
<p>2014的双11，在天猫买了《<a href="https://book.douban.com/subject/6021440/" target="_blank" rel="external">黑客与画家</a>》，其译者就是阮老师。从那个时候开始，我知道了这个领域的大神中，是有个阮老师的2333。</p>
<p>老师的个人网站是这个：<a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="external">http://www.ruanyifeng.com/home.html</a></p>
<p>从这里你可以很容易了解到许许多多有趣的知识。</p>
<h3 id="js面向对象-封装">js面向对象-封装</h3>
<p>面向对象的编程语言，第一反应我想到了Java，然后是C++，两者都是真正的<a href="http://baike.baidu.com/link?url=47orC6D5BkCpRxfI5hwgXRwd9qDoEpWGDyZPiyCDVUHepRenjasljzat3gNprFVT-N0OxcxonhpTUlYT_BeY3q" target="_blank" rel="external">OOP</a>编程语言。</p>
<p>js中并没有class（类），所以即使其中所有的东西都是对象，所以也不是真正的OOP。</p>
<h4 id="生成实例对象的原始模式">生成实例对象的原始模式</h4>
<p>我们将创建一个对象：猫。它有两个属性：“颜色”，“名字”。（<code>一瞬间我的思绪回到了一年半前学java是朱老师的ppt例子</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var Cat = &#123;</div><div class="line">　　name : &apos;&apos;,</div><div class="line">　　color : &apos;&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据这个原型的规格（schema），生成两个实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var cat1 = &#123;&#125;;  //创建一个空对象</div><div class="line">　cat1.name = &quot;大毛&quot;;  //按照原型对象的属性赋值</div><div class="line">　cat1.color = &quot;黄色&quot;;</div><div class="line">var cat2 = &#123;&#125;;</div><div class="line">　cat2.name = &quot;二毛&quot;;</div><div class="line">　cat2.color = &quot;黑色&quot;;</div></pre></td></tr></table></figure>
<p>最简单的封装了，把两个属性封装在一个对象里面。</p>
<p>但是，这样的写法有两个缺点</p>
<ul>
<li>一是如果多生成几个实例，写起来就非常麻烦</li>
<li>二是实例与原型之间，没有任何办法可以看出有什么联系</li>
</ul>
<h4 id="原始模式的改进">原始模式的改进</h4>
<p>写个函数改进一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color) &#123;</div><div class="line">  return &#123;</div><div class="line">　ame:name,</div><div class="line">　color:color</div><div class="line">　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后生成实例对象，其实就是调用函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var cat1 = Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div></pre></td></tr></table></figure>
<p>好了一些？</p>
<p>这种方法的问题存在，<code>cat1</code>和<code>cat2</code>之间没有内在的联系，不能反映出它们是同一个原型对象的实例。。。</p>
<h4 id="构造函数模式">构造函数模式</h4>
<p>接下来我们继续努力搞已存在的问题。。。</p>
<p>为了解决从原型对象生成实例的问题，JavaScript提供了一个构造函数（Constructor）模式。</p>
<p>所谓&quot;构造函数&quot;，其实就是一个普通函数，但是内部使用了<code>this</code>变量。对构造函数使用new运算符，就能生成实例，并且<code>this</code>变量会绑定在实例对象上。</p>
<p>下面我们再写下猫的原型对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">　this.name=name;</div><div class="line">　this.color=color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在就可以生成实例对象了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">alert(cat1.name); // 大毛</div><div class="line">alert(cat1.color); // 黄色</div></pre></td></tr></table></figure>
<p>这时<code>cat1</code>和<code>cat2</code>会自动含有一个<code>constructor</code>属性，指向它们的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1.constructor == Cat); //true</div><div class="line">alert(cat2.constructor == Cat); //true</div></pre></td></tr></table></figure>
<p>JavaScript还提供了一个<code>instanceof</code>运算符，验证原型对象与实例对象之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1 instanceof Cat); //true</div><div class="line">alert(cat2 instanceof Cat); //true</div></pre></td></tr></table></figure>
<h4 id="构造函数模式的问题">构造函数模式的问题</h4>
<p>构造函数方法好用，但是会存在浪费内存的问题。</p>
<p>如下。我们现在为<code>Cat</code>对象添加一个不变的属性<code>type</code>（种类），再添加一个方法<code>eat</code>（吃）。那么，原型对象<code>Cat</code>就变成了下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color) &#123;</div><div class="line">　this.name = name;</div><div class="line">　this.color = color;</div><div class="line">　this.type = &quot;猫科动物&quot;;</div><div class="line">　this.eat = function() &#123;</div><div class="line">　  alert(&quot;吃老鼠&quot;);</div><div class="line">　&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的方法生成实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = new Cat (&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">alert(cat1.type); // 猫科动物</div><div class="line">cat1.eat(); // 吃老鼠</div></pre></td></tr></table></figure>
<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。</p>
<p>那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。</p>
<p>既不环保，也缺乏效率。</p>
<pre><code>alert(cat1.eat == cat2.eat); //false
</code></pre>
<p>能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？</p>
<p>回答是可以的</p>
<h4 id="prototype模式">Prototype模式</h4>
<p>JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">　this.name = name;</div><div class="line">　this.color = color;</div><div class="line">&#125;</div><div class="line">Cat.prototype.type = &quot;猫科动物&quot;;</div><div class="line">Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</div></pre></td></tr></table></figure>
<p>生成实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</div><div class="line">alert(cat1.type);  // 猫科动物</div><div class="line">cat1.eat();  // 吃老鼠</div></pre></td></tr></table></figure>
<p>这时所有实例的<code>type</code>属性和<code>eat()</code>方法，其实都是同一个内存地址，指向<code>prototype</code>对象，因此就提高了运行效率。</p>
<h4 id="prototype模式的验证方式">Prototype模式的验证方式</h4>
<p>为了配合<code>prototype</code>属性，js定义了一些辅助方法，助我们使用它。。。</p>
<ol>
<li><strong>isPrototypeOf()</strong></li>
</ol>
<p>这个方法用来判断，某个<code>prototype</code>对象和某个实例之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Cat.prototype.isPrototypeOf(cat1)); //true</div><div class="line">alert(Cat.prototype.isPrototypeOf(cat2)); //true</div></pre></td></tr></table></figure>
<ol start="2">
<li><strong>hasOwnProperty()</strong></li>
</ol>
<p>每个实例对象都有一个<code>hasOwnProperty()</code>方法，用来判断某一个属性到底是本地属性，还是继承自<code>prototype</code>对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</div><div class="line">alert(cat1.hasOwnProperty(&quot;type&quot;)); // true</div></pre></td></tr></table></figure>
<ol start="3">
<li><strong>in</strong></li>
</ol>
<p><code>in</code>运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(&quot;name&quot; in cat1); // true</div><div class="line">alert(&quot;type&quot; in cat1); // true</div></pre></td></tr></table></figure>
<p><code>in</code>运算符还可以用来遍历某个对象的所有属性。</p>
<pre><code>for(var prop in cat1) { alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }
</code></pre>
<h3 id="构造函数的继承">构造函数的继承</h3>
<p>继承间的几种方法。</p>
<p>现在，我们又有了一个“动物”对象的构造函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fuction Animal()&#123;</div><div class="line">  this.species = &quot;动物&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有个“猫”对象的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">  this.name = name;</div><div class="line">  this.color = color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来思考个问题：<code>如何让猫继承动物</code>呢？</p>
<h4 id="构造函数绑定">构造函数绑定</h4>
<p>应该是最简单的办法。。。使用call或apply方法，<code>将父对象的构造方法绑定在子对象身上</code>，，，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Cat(name,color)&#123;</div><div class="line">  Animal.apply(this,arguments);</div><div class="line">  this.name = name;</div><div class="line">  this.color = color;</div><div class="line">&#125;</div><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">alert(cat1.species);    // 动物</div></pre></td></tr></table></figure>
<h4 id="prototype模式">prototype模式</h4>
<p>使用prototype模式。</p>
<p>如果“猫”的<code>prototype</code>对象，指向一个<code>Animal</code>的实例。那么所有“猫”的实例，就可以继承Animal了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cat.prototype = new Animal();</div><div class="line">Cat.prototype.constructor = Cat;</div><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">alert(cat1.species);    // 动物</div></pre></td></tr></table></figure>
<p>第一行，将Cat的prototype对象指向一个Animal的实例，相当于完全删除了prototype对象原先的值，然后赋予了一个新值。</p>
<p>那么第二行呢？任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有&quot;Cat.prototype = new Animal();&quot;（第一行）这一行，<code>Cat.prototype.constructor</code>是指向Cat的；加了这一行以后，<code>Cat.prototype.constructor</code>指向Animal。
即此时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Cat.prototype.constructor == Animal);     // true</div></pre></td></tr></table></figure>
<p>更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。
即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(cat1.constructor == Cat.prototype.constructor);   // true</div></pre></td></tr></table></figure>
<p>然后cat1.constructor也指向Animal了。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(cat1.constructor == Animal); // true</div></pre></td></tr></table></figure>
<p>这会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。</p>
<p>这是很重要的一点：<strong>如果替换了prototype对象，那么下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">o.prototype = &#123;&#125;;</div><div class="line">o.prototype.constructor = 0;</div></pre></td></tr></table></figure>
<h4 id="直接继承prototype">直接继承prototype</h4>
<p>其实是对第二种方法的改进。在本例中，Animal对象不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p>
<p>先来改写Animal对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function Animal()&#123; &#125;</div><div class="line">Animal.prototype.species = &quot;动物&quot;;</div></pre></td></tr></table></figure>
<p>然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cat.prototype = Animal.prototype;</div><div class="line">Cat.prototype.constructor = Cat;</div><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">alert(cat1.species); // 动物</div></pre></td></tr></table></figure>
<p>与前一种方法相比，这样做:</p>
<ul>
<li>
<p>优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。</p>
</li>
<li>
<p>缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。</p>
</li>
</ul>
<p>所以其实上面的代码是不合理的！因为在第二行，Animal.prototype对象的constructor属性被改掉了！
此时的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Animal.prototype.constructor); // Cat</div></pre></td></tr></table></figure>
<h4 id="利用空对象作为中介">利用空对象作为中介</h4>
<p>由于&quot;直接继承prototype&quot;存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var F = function()&#123;&#125;;</div><div class="line">F.prototype = Animal.prototype;</div><div class="line">Cat.prototype = new F();</div><div class="line">Cat.prototype.constructor = Cat;</div></pre></td></tr></table></figure>
<p>F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Animal.prototype.constructor); // Animal</div></pre></td></tr></table></figure>
<p>将上面的方法，封装成一个函数，便于使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function extend(Child, Parent) &#123;</div><div class="line">　var F = function()&#123;&#125;;</div><div class="line">　F.prototype = Parent.prototype;</div><div class="line">　Child.prototype = new F();</div><div class="line">　Child.prototype.constructor = Child;</div><div class="line">　Child.uber = Parent.prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extend(Cat,Animal);</div><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">alert(cat1.species); // 动物</div></pre></td></tr></table></figure>
<p>这个extend函数，就是YUI库如何实现继承的方法。</p>
<p>函数体最后一行：<code>Child.uber = Parent.prototype;</code>…意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是&quot;向上&quot;、“上一层”。）</p>
<p>这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>
<h4 id="拷贝继承">拷贝继承</h4>
<p>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用&quot;拷贝&quot;方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function Animal()&#123;&#125;</div><div class="line">Animal.prototype.species = &quot;动物&quot;;</div></pre></td></tr></table></figure>
<p>然后再写一个函数，实现属性拷贝的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function extend2(Child, Parent) &#123;</div><div class="line">　var p = Parent.prototype;</div><div class="line">　var c = Child.prototype;</div><div class="line">　for (var i in p) &#123;</div><div class="line">　　c[i] = p[i];</div><div class="line">　&#125;</div><div class="line">　c.uber = p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数的作用，就是将父对象的prototype对象中的属性，一一拷贝给Child对象的prototype对象。</p>
<p>使用的时候，这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extend2(Cat, Animal);</div><div class="line">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</div><div class="line">alert(cat1.species); // 动物</div></pre></td></tr></table></figure>
<h3 id="不使用构造函数实现quot继承quot">不使用构造函数实现&quot;继承&quot;</h3>
<h4 id="什么是quot非构造函数quot的继承">什么是&quot;非构造函数&quot;的继承？</h4>
<p>现在有一个对象，叫做&quot;中国人&quot;。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Chinese = &#123;</div><div class="line">  nation:&quot;中国&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>再来个对象，叫做&quot;医生&quot;。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Doctor = &#123;</div><div class="line">  career:&quot;医生&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>请问怎样才能让&quot;医生&quot;去继承&quot;中国人&quot;，也就是说，我怎样才能生成一个&quot;中国医生&quot;的对象？</p>
<p>值得注意：这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现&quot;继承&quot;。</p>
<h4 id="object方法">object()方法</h4>
<p>json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">　function F() &#123;&#125;</div><div class="line">　F.prototype = o;</div><div class="line">　return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。</p>
<p>使用的时候，第一步先在父对象的基础上，生成子对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = object(Chinese);</div></pre></td></tr></table></figure>
<p>then,再加上对象本身的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Doctor.career = &apos;医生&apos;;</div></pre></td></tr></table></figure>
<p>试试看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.nation);  //中国</div></pre></td></tr></table></figure>
<h4 id="浅拷贝">浅拷贝</h4>
<p>除了使用&quot;prototype链&quot;以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p>
<p>下面这个函数，就是在做拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function extendCopy(p) &#123;</div><div class="line">　var c = &#123;&#125;;</div><div class="line">　for (var i in p) &#123; </div><div class="line">　　c[i] = p[i];</div><div class="line">　&#125;</div><div class="line">　c.uber = p;</div><div class="line">　return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候，这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Doctor = extendCopy(Chinese);</div><div class="line">Doctor.career = &apos;医生&apos;;</div><div class="line">alert(Doctor.nation); // 中国</div></pre></td></tr></table></figure>
<p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>请看，现在给Chinese添加一个&quot;出生地&quot;属性，它的值是一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div></pre></td></tr></table></figure>
<p>通过extendCopy()函数，Doctor继承了Chinese。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = extendCopy(Chinese);</div></pre></td></tr></table></figure>
<p>然后，为Doctor的&quot;出生地&quot;添加一个城市：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure>
<p>好像发生了些事情。。。Chinese的&quot;出生地&quot;也被改掉了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门</div></pre></td></tr></table></figure>
<p>so，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做&quot;浅拷贝&quot;。这是早期jQuery实现继承的方式。</p>
<h4 id="深拷贝">深拷贝</h4>
<p>所谓&quot;深拷贝&quot;，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用&quot;浅拷贝&quot;就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function deepCopy(p, c) &#123;</div><div class="line">　var c = c || &#123;&#125;;</div><div class="line">　for (var i in p) &#123;</div><div class="line">　　if (typeof p[i] === &apos;object&apos;) &#123;</div><div class="line">　　　c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</div><div class="line">　　　deepCopy(p[i], c[i]);</div><div class="line">　　&#125; else &#123;</div><div class="line">　　　c[i] = p[i];</div><div class="line">　  &#125;</div><div class="line">　&#125;</div><div class="line">　　return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Doctor = deepCopy(Chinese);</div></pre></td></tr></table></figure>
<p>现在，给父对象加上一个属性，值为数组。然后再子对象上修改这个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];</div><div class="line">Doctor.birthPlaces.push(&apos;厦门&apos;);</div></pre></td></tr></table></figure>
<p>这时候，父对象就不会受到影响了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门</div><div class="line">alert(Chinese.birthPlaces); //北京, 上海, 香港</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 在路上 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 阮一峰 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于node.js的几句话]]></title>
      <url>http://zrdsj.cc/2016/09/26/nodejs-talk/</url>
      <content type="html"><![CDATA[<p>接下来用’nj’来表示’Node.Js’.全都是。。。参考了网上几个地方的文档总结快速教程之类的，总的来说我就说自己是转载参考了<a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">这个</a>吧！向原作者致敬，thx。</p>
<a id="more"></a>
<h3 id="基础">基础</h3>
<h4 id="nodejs是啥">node.js是啥</h4>
<p><code>是一个解析器</code></p>
<p>前展思考：</p>
<ul>
<li>脚本语言的运行需要什么？</li>
<li>独立运行的js又是怎么样？</li>
</ul>
<h4 id="nodejs干啥用的">node.js干啥用的</h4>
<p><code>实现高性能Web服务器</code></p>
<p>不是我说的，是nj作者说的。</p>
<p>值得关注的两个点：</p>
<ul>
<li>事件机制</li>
<li>异步IO模型的优越性？</li>
</ul>
<p>哪种编程语言不自带IO功能，又可以良好支持事件机制？2333</p>
<p>sth else:</p>
<blockquote>
<p>对于前端而言，虽然不是人人都要拿NodeJS写一个服务器程序，但简单可至使用命令交互模式调试JS代码片段，复杂可至编写工具提升工作效率。</p>
</blockquote>
<h4 id="安装">安装</h4>
<p><a href="http://nodejs.cn/download/" target="_blank" rel="external">http://nodejs.cn/download/</a></p>
<h4 id="使用">使用</h4>
<p>法1：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo1.png" alt=""></p>
<p>法2：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo2.png" alt=""></p>
<p>then</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_demo3.png" alt=""></p>
<blockquote>
<p>你用的Linux？</p>
</blockquote>
<blockquote>
<p>哦，那我不会。。。😒</p>
</blockquote>
<h4 id="模块">模块</h4>
<p>（这是很jb大的一个话题其实）</p>
<p><strong>将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名</strong>。在编写每个模块时，都有<a href="http://www.cnblogs.com/pigtail/archive/2013/01/14/2859929.html" target="_blank" rel="external">require</a>、<a href="https://liuzhichao.com/p/1669.html" target="_blank" rel="external">exports</a>、<a href="http://www.cnblogs.com/dolphinX/p/3485260.html" target="_blank" rel="external">module</a>三个预先定义好的变量可供使用。</p>
<p>还应该注意的点：</p>
<ul>
<li>模块初始化</li>
<li>主模块</li>
</ul>
<h4 id="二进制模块">二进制模块</h4>
<p>一般使用js编写模块就可以了，但nj也支持使用C/C++编写二进制模块。</p>
<p>编译好的二进制模块除了文件扩展名是.node外，和js模块的使用方式相同。</p>
<blockquote>
<p><code>二进制模块能使用操作系统提供的所有功能，拥有无限的潜能.</code></p>
<p><code>对于前端而言并不容易，并且难以跨平台使用。</code></p>
</blockquote>
<p>so不再多说。</p>
<h3 id="代码组织部署">代码组织部署</h3>
<p>先来说说，这第二部分是干什么的。在我自己十分有限的学识当中，我的看法是这样：</p>
<blockquote>
<p>你写的程序通常不会仅仅是一个文件一个界面这类的，那么这些东西多起来的话就得对代码（藏在文件文件夹中的代码）按着某种合理高效的方式做一些处理。比如说<code>目录结构</code>和<code>部署方式</code>，这些事情就像盖房子时搭的脚手架一样。</p>
</blockquote>
<p>####模块路径解析规则</p>
<p>在第一部分提到的<code>require</code>，是一个函数，是nj中的一个模块了。它支持一定规则的路径写法，<a href="http://nqdeng.github.io/7-days-nodejs/#1.5.1" target="_blank" rel="external">详情</a>点击即可。但这两种路径在模块之间建立了<code>耦合关系</code>，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。</p>
<p>因此，require函数支持第三种形式的路径，写法类似于<code>foo/bar</code>，并依次按照以下规则解析路径，直到找到模块位置。</p>
<ul>
<li>
<p>内置模块</p>
<p>传递给require函数的是nj内置模块名称，不做路径解析直接返回内部模块的导出对象。例如<code>require('fs')</code>。</p>
</li>
<li>
<p>node_modules目录</p>
<p>nj定义了一个特殊的<code>node_modules</code>目录用于存放模块。例如某个模块的绝对路径是<code>/home/user/hello.js</code>，在该模块中使用<code>require('foo/bar')</code>方式加载模块时，则nj依次尝试使用以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/home/user/node_modules/foo/bar</div><div class="line">/home/node_modules/foo/bar</div><div class="line">/node_modules/foo/bar</div></pre></td></tr></table></figure>
</li>
<li>
<p>NODE_PATH环境变量</p>
<p>与PATH环境变量类似，nj允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用<code>:</code>分隔，在Windows下使用<code>;</code>分隔。例如定义了以下NODE_PATH环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NODE_PATH=/home/user/lib:/home/lib</div></pre></td></tr></table></figure>
<p>当使用<code>require('foo/bar')</code>的方式加载模块时，则NodeJS依次尝试以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/home/user/lib/foo/bar</div><div class="line">/home/lib/foo/bar</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="包package">包（package）</h4>
<p>nj中一个js模块，最小也得是一个js文件，大了呢我们的描述就会变成：<strong>多个子模块组成的复杂模块</strong>。为了便于使用与管理，我们将<u>许多由子模块组成的大模块成为<strong><em>包</em></strong></u>。并把所有子模块放在同一个目录里。</p>
<p>在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- /home/user/lib/</div><div class="line">  - cat/</div><div class="line">    head.js</div><div class="line">    body.js</div><div class="line">    main.js</div></pre></td></tr></table></figure>
<p>其中<code>cat</code>目录定义了一个包，其中包含了3个子模块。<code>main.js</code>作为入口模块，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var head = require(&apos;./head&apos;);</div><div class="line">var body = require(&apos;./body&apos;);</div><div class="line"></div><div class="line">exports.create = function (name) &#123;</div><div class="line">  return &#123;</div><div class="line">    name: name,</div><div class="line">    head: head.create(),</div><div class="line">    body: body.create()</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在其它模块里使用此包的时候，需要加载包的入口模块。接着上例，使用<code>require('/home/user/lib/cat/main')</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。</p>
<h5 id="indexjs">index.js</h5>
<p>当模块的文件名是<code>index.js</code>，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var cat = require(&apos;/home/user/lib/cat&apos;);</div><div class="line">var cat = require(&apos;/home/user/lib/cat/index&apos;);</div></pre></td></tr></table></figure>
<p>这样处理后，就只需要把包目录路径传递给require函数，感觉上整个目录被当作单个模块使用，更有整体感。</p>
<h5 id="pactagejson">pactage.json</h5>
<p>如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个<code>package.json</code>文件，并在其中指定入口模块的路径。上例中的<code>cat</code>模块可以重构如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- /home/user/lib/</div><div class="line">  - cat/</div><div class="line">    + doc/</div><div class="line">      - lib/</div><div class="line">        head.js</div><div class="line">        body.js</div><div class="line">        main.js</div><div class="line">      + tests/</div><div class="line">        package.json</div></pre></td></tr></table></figure>
<p>其中package.json内容如下。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;cat&quot;,</div><div class="line">  &quot;main&quot;: &quot;./lib/main.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此一来，就同样可以使用<code>require('/home/user/lib/cat')</code>的方式加载模块。NodeJS会根据包目录下的<code>package.json</code>找到入口模块所在位置。</p>
<h4 id="命令行程序">命令行程序</h4>
<p>使用nj编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。</p>
<p>例如我们用nj写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，我们把该程序部署在<code>/home/user/bin/node-echo.js</code>这个位置。为了在任何目录下都能运行该程序，我们需要使用以下终端命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node /home/user/bin/node-echo.js Hello World</div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>这种使用方式看起来不怎么像是一个命令行程序，下边的才是我们期望的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node-echo Hello World</div></pre></td></tr></table></figure>
<p>在Windows系统(这是个不太友好的开发环境，鄙人当前依然在使用)下的做法完全不同，我们得靠<code>.cmd</code>文件来解决问题。假设<code>node-echo.js</code>存放在<code>C:\Users\user\bin</code>目录，并且该目录已经添加到PATH环境变量里了。接下来需要在该目录下新建一个名为<code>node-echo.cmd</code>的文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@node &quot;C:\User\user\bin\node-echo.js&quot; %*</div></pre></td></tr></table></figure>
<p>这样处理后，我们就可以在任何目录下使用<code>node-echo</code>命令了。</p>
<p>最后再说一下这个Windows下的做法，我没试过也压根没去想。一般情况下我要执行node去运行某个js之类的操作时，我都是用相关bash工具去执行的，并不用cmd。。。</p>
<h4 id="工程目录">工程目录</h4>
<p>了解了以上知识后，现在我们来完整地规划一个工程目录（试试看）。</p>
<p>以编写一个<code>命令行程序</code>为例，一般我们会同时提供<code>命令行模式</code>和<code>API模式</code>两种使用方式，并且我们会借助三方包来编写代码。</p>
<p>除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- /home/user/workspace/node-echo/   # 工程目录</div><div class="line">- /home/user/workspace/node-echo/   # 工程目录</div><div class="line">  - bin/                          # 存放命令行相关代码</div><div class="line">    node-echo</div><div class="line">  + doc/                          # 存放文档</div><div class="line">  - lib/                          # 存放API相关代码</div><div class="line">    echo.js</div><div class="line">  - node_modules/                 # 存放三方包</div><div class="line">    + argv/</div><div class="line">  + tests/                        # 存放测试用例</div><div class="line">  package.json                    # 元数据文件</div><div class="line">  README.md                       # 说明文件</div></pre></td></tr></table></figure>
<p>其中部分文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* bin/node-echo */</div><div class="line">var argv = require(&apos;argv&apos;),</div><div class="line">echo = require(&apos;../lib/echo&apos;);</div><div class="line">console.log(echo(argv.join(&apos; &apos;)));</div><div class="line"></div><div class="line">/* lib/echo.js */</div><div class="line">module.exports = function (message) &#123;</div><div class="line">  return message;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/* package.json */</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;node-echo&quot;,</div><div class="line">  &quot;main&quot;: &quot;./lib/echo.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上例子中分类存放了不同类型的文件，并通过<code>node_moudles</code>目录直接使用三方包名加载模块。此外，定义了<code>package.json</code>之后，<code>node-echo</code>目录也可被当作一个包来使用。</p>
<h4 id="npm">npm</h4>
<p>NPM是随同nj一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>可以看到，NPM建立了一个nj生态圈，nj开发者和用户可以在里边互通有无。以下分别介绍这三种场景下怎样使用NPM。</p>
<h5 id="下载三方包">下载三方包</h5>
<p>需要使用三方包时，首先得知道有哪些包可用。虽然官方–&gt;<a href="https://npmjs.org/" target="_blank" rel="external">npmjs.org</a>提供了个搜索框可以根据包名来搜索，但如果连想使用的三方包的名字都不确定的话，就请自行百度。知道了包名后，比如上边例子中的<code>argv</code>，就可以在工程目录下打开终端，使用以下命令来下载三方包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install argv</div><div class="line">...</div><div class="line">argv@0.0.2 node_modules\argv</div></pre></td></tr></table></figure>
<p>下载好之后，<strong><code>argv</code>包就放在了工程目录下的<code>node_modules</code>目录中</strong>，因此在<strong>代码中只需要通过<code>require('argv')</code>的方式就好，无需指定三方包路径</strong>。</p>
<p>以上命令默认下载最新版三方包，如果想要下载指定版本的话，可以在包名后边加上<code>@</code>，例如通过以下命令可下载0.0.x版的<code>argv</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install argv@0.0.1</div><div class="line">...</div><div class="line">argv@0.0.1 node_modules\argv</div></pre></td></tr></table></figure>
<p>如果使用到的三方包比较多，在终端下一个包一条命令地安装未免太人肉了。因此NPM对<code>package.json</code>的字段做了扩展，允许在其中申明三方包依赖。因此，上边例子中的<code>package.json</code>可以改写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;node-echo&quot;,</div><div class="line">  &quot;main&quot;: &quot;./lib/echo.js&quot;,</div><div class="line">  &quot;dependencies&quot;: &#123;  </div><div class="line">    &quot;argv&quot;: &quot;0.0.2&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样处理后，在工程目录下就可以使用<code>npm install</code>命令批量安装三方包了。更重要的是，当以后<code>node-echo</code>也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用<code>npm install node-echo</code>命令时，NPM会自动创建以下目录结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- project/</div><div class="line">  - node_modules/</div><div class="line">    - node-echo</div><div class="line">      - node_modules/</div><div class="line">        + argv/</div><div class="line">        ...</div><div class="line">...</div></pre></td></tr></table></figure>
<p>如此一来，用户只需关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系。</p>
<h5 id="安装命令行程序">安装命令行程序</h5>
<p>从NPM服务上下载安装一个命令行程序的方法与三方包类似。例如上例中的<code>node-echo</code>提供了命令行使用方式，只要<code>node-echo</code>自己配置好了相关的<code>package.json</code>字段，对于用户而言，只需要使用以下命令安装程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install node-echo -g</div></pre></td></tr></table></figure>
<p>参数中的<code>-g</code>表示全局安装，因此<code>node-echo</code>会默认安装到以下位置，并且NPM会自动创建好Windows系统下需要的<code>.cmd</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- /usr/local/               # Linux系统下</div><div class="line">  - lib/node_modules/</div><div class="line">    + node-echo/</div><div class="line">        ...</div><div class="line">    - bin/</div><div class="line">      node-echo</div><div class="line">        ...</div><div class="line">    ...</div><div class="line"></div><div class="line">- %APPDATA%\npm\            # Windows系统下</div><div class="line">  - node_modules\</div><div class="line">    + node-echo\</div><div class="line">        ...</div><div class="line">    node-echo.cmd</div><div class="line"> ...</div></pre></td></tr></table></figure>
<h5 id="发布代码">发布代码</h5>
<p>先给一个<a href="http://www.jianshu.com/p/26029206ad3e" target="_blank" rel="external">链接</a>。</p>
<p>第一次使用NPM发布代码前需要注册一个账号。终端下运行<code>npm adduser</code>，之后按照提示做即可。账号搞定后，接着我们需要编辑<code>package.json</code>文件，加入NPM必需的字段。接着上边<code>node-echo</code>的例子，<code>package.json</code>里必要的字段如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;node-echo&quot;,           # 包名，在NPM服务器上须要保持唯一</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,            # 当前版本号</div><div class="line">  &quot;dependencies&quot;: &#123;              # 三方包依赖，需要指定包名和版本号</div><div class="line">    &quot;argv&quot;: &quot;0.0.2&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;main&quot;: &quot;./lib/echo.js&quot;,       # 入口模块位置</div><div class="line">  &quot;bin&quot; : &#123;</div><div class="line">    &quot;node-echo&quot;: &quot;./bin/node-echo&quot;      # 命令行程序名和主模块位置</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后，我们就可以在<code>package.json</code>所在目录下运行<code>npm publish</code>发布代码了。</p>
<h5 id="版本号">版本号</h5>
<p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>
<p>语义版本号分为<code>X.Y.Z</code>三位，分别代表主版本号x、次版本号y和补丁版本号z。当代码变更时，版本号按以下原则更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ 如果只是修复bug，需要更新Z位。</div><div class="line"></div><div class="line">+ 如果是新增了功能，但是向下兼容，需要更新Y位。</div><div class="line"></div><div class="line">+ 如果有大变动，向下不兼容，需要更新X位。</div></pre></td></tr></table></figure>
<p>版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如<code>&quot;argv&quot;: &quot;0.0.x&quot;</code>表示依赖于<code>0.0.x</code>系列的最新版<code>argv</code>。NPM支持的所有版本号范围指定方式可以查看<a href="https://npmjs.org/doc/files/package.json.html#dependencies" target="_blank" rel="external">官方文档</a>。</p>
<h5 id="else">else</h5>
<p>除了本jie介绍的部分外，NPM还提供了很多功能，<code>package.json</code>里也有很多其它有用的字段。除了可以在<a href="https://npmjs.org/doc/" target="_blank" rel="external">npmjs.org/doc/</a>查看官方文档外，这里再介绍一些NPM常用命令。</p>
<ul>
<li>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</li>
<li>使用<code>npm help</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</li>
<li>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用<code>npm update</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</li>
<li>使用<code>npm update -g</code>可以把全局安装的对应命令行程序更新至最新版。</li>
<li>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</li>
<li>使用<code>npm unpublish @</code>可以撤销发布自己发布过的某个版本代码。</li>
</ul>
<h3 id="文件操作">文件操作</h3>
<p>让前端觉得如获神器的可能不是nj能做网络编程，而是nj能够操作文件。从<em>文件查找</em>到<em>代码编译</em>，几乎没有一个前端工具不操作文件。换个角度讲，几乎也只需要一些数据处理逻辑，再加上一些文件操作，就能够编写出大多数前端工具。本章将介绍与之相关的nj内置模块。</p>
<h4 id="开门红">开门红</h4>
<p>nj提供了基本的文件操作API，但是像文件拷贝这种高级功能就没有提供，因此我们先拿文件拷贝程序练手。与<code>copy</code>命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。</p>
<h5 id="小文件拷贝">小文件拷贝</h5>
<p>使用nj内置的<code>fs</code>模块简单实现这个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">function copy(src, dst) &#123;</div><div class="line">  fs.writeFileSync(dst, fs.readFileSync(src));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">  copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p>以上程序使用<code>fs.readFileSync</code>从源路径读取文件内容，并使用<code>fs.writeFileSync</code>将文件内容写入目标路径。</p>
<p>其中<code>process</code>是一个全局变量，可通过<code>process.argv</code>获得命令行参数。由于<code>argv[0]</code>固定等于nj执行程序的绝对路径，<code>argv[1]</code>固定等于主模块的绝对路径，因此第一个命令行参数从<code>argv[2]</code>这个位置开始。</p>
<h5 id="大文件拷贝">大文件拷贝</h5>
<p>上边的程序拷贝一些小文件没有问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。（试想你的服务器有一个数g的iso文件，如果想要将这个文件进行操作的话，，hh显然不可能一下进行操作，那样会弄炸你的服务器）对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">function copy(src, dst) &#123;</div><div class="line">  fs.createReadStream(src).pipe(fs.createWriteStream(dst));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">  copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p>以上程序使用<code>fs.createReadStream</code>创建了一个源文件的只读数据流，并使用<code>fs.createWriteStream</code>创建了一个目标文件的只写数据流，并且用<code>pipe</code>方法把两个数据流连接了起来。连接起来后发生的事情，说得抽象点的话，水顺着水管从一个桶流到了另一个桶。</p>
<h4 id="api">API</h4>
<p>我们大致看看nj提供了哪些和文件操作有关的API。并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h5 id="buffer数据块">Buffer（数据块）</h5>
<p><a href="https://nodejs.org/api/buffer.html" target="_blank" rel="external">官方文档</a></p>
<p>JavaScript语言自身只有字符串数据类型，没有二进制数据类型，因此nj提供了一个与<code>String</code>对等的全局构造函数<code>Buffer</code>来提供对二进制数据的操作。除了可以读取文件得到<code>Buffer</code>的实例外，还能够直接构造，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串类似，除了可以用<code>.length</code>属性得到字节长度外，还可以用<code>[index]</code>方式读取指定位置的字节，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin[0]; // =&gt; 0x68;</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串能够互相转化，例如可以使用指定编码将二进制数据转化为字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var str = bin.toString(&apos;utf-8&apos;); // =&gt; &quot;hello&quot;</div></pre></td></tr></table></figure>
<p>或者反过来，将字符串转换为指定编码下的二进制数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer(&apos;hello&apos;, &apos;utf-8&apos;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于<code>Buffer</code>，更像是可以做指针操作的C语言数组。例如，可以用<code>[index]</code>方式直接修改某个位置的字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin[0] = 0x48;</div></pre></td></tr></table></figure>
<p>而<code>.slice</code>方法也不是返回一个新的<code>Buffer</code>，而更像是返回了指向原<code>Buffer</code>中间的某个位置的指针，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]</div><div class="line">    ^           ^</div><div class="line">    |           |</div><div class="line">   bin     bin.slice(2)</div></pre></td></tr></table></figure>
<p>因此对<code>.slice</code>方法返回的<code>Buffer</code>的修改会作用于原<code>Buffer</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div><div class="line">var sub = bin.slice(2);</div><div class="line"></div><div class="line">sub[0] = 0x65;</div><div class="line">console.log(bin); // =&gt; &lt;Buffer 68 65 65 6c 6f&gt;</div></pre></td></tr></table></figure>
<p>也因此，如果想要拷贝一份<code>Buffer</code>，得首先创建一个新的<code>Buffer</code>，并通过<code>.copy</code>方法把原<code>Buffer</code>中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div><div class="line">var dup = new Buffer(bin.length);</div><div class="line"></div><div class="line">bin.copy(dup);</div><div class="line">dup[0] = 0x48;</div><div class="line">console.log(bin); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</div><div class="line">console.log(dup); // =&gt; &lt;Buffer 48 65 65 6c 6f&gt;</div></pre></td></tr></table></figure>
<p>总之，<code>Buffer</code>将JS的数据处理能力从字符串扩展到了任意二进制数据。</p>
<h5 id="stream数据流">Stream（数据流）</h5>
<p><a href="http://nodejs.org/api/buffer.html" target="_blank" rel="external">官方文档</a></p>
<p>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种<code>Stream</code>来提供对数据流的操作。</p>
<p>以上边的大文件拷贝程序为例，现在为数据来源创建一个只读数据流，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(pathname);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  doSomething(chunk);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  cleanUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Stream</code>基于事件机制工作，所有<code>Stream</code>的实例都继承于NodeJS提供的<a href="http://nodejs.org/api/events.html" target="_blank" rel="external">EventEmitter</a>。</p>
<p>上边的代码中<code>data</code>事件会源源不断地被触发，不管<code>doSomething</code>函数是否处理得过来。代码可以继续做如下改造，以解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  rs.pause();</div><div class="line">  doSomething(chunk, function () &#123;</div><div class="line">    rs.resume();</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  cleanUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上代码给<code>doSomething</code>函数加上了回调，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。</p>
<p>此外，我们也可以为数据目标创建一个只写数据流，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line">var ws = fs.createWriteStream(dst);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  ws.write(chunk);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  ws.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>把<code>doSomething</code>换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据<code>.write</code>方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据<code>drain</code>事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。因此代码可以继续改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line">var ws = fs.createWriteStream(dst);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">  if (ws.write(chunk) === false) &#123;</div><div class="line">    rs.pause();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">  ws.end();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ws.on(&apos;drain&apos;, function () &#123;</div><div class="line">    rs.resume();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上代码实现了数据从只读数据流到只写数据流的搬运，并包括了防爆仓控制。因为这种使用场景很多，例如上边的大文件拷贝程序，NodeJS直接提供了<code>.pipe</code>方法来做这件事情，其内部实现方式与上边的代码类似。</p>
<h5 id="file-system文件系统">File System（文件系统）</h5>
<p><a href="http://nodejs.org/api/fs.html" target="_blank" rel="external">官方文档</a></p>
<p>NodeJS通过<code>fs</code>内置模块提供对文件的操作。<code>fs</code>模块提供的API基本上可以分为以下三类：</p>
<ul>
<li>
<p>文件属性读写。</p>
<p>其中常用的有<code>fs.stat</code>、<code>fs.chmod</code>、<code>fs.chown</code>等等。</p>
</li>
<li>
<p>文件内容读写。</p>
<p>其中常用的有<code>fs.readFile</code>、<code>fs.readdir</code>、<code>fs.writeFile</code>、<code>fs.mkdir</code>等等。</p>
</li>
<li>
<p>底层文件操作。</p>
<p>其中常用的有<code>fs.open</code>、<code>fs.read</code>、<code>fs.write</code>、<code>fs.close</code>等等。</p>
</li>
</ul>
<p>NodeJS最精华的异步IO模型在<code>fs</code>模块里有着充分的体现，例如上边提到的这些API都通过回调函数传递结果。以<code>fs.readFile</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.readFile(pathname, function (err, data) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">      // Deal with error.</div><div class="line">  &#125; else &#123;</div><div class="line">      // Deal with data.</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如上边代码所示，基本上所有<code>fs</code>模块API的回调参数都有两个。第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回API方法执行结果。</p>
<p>此外，<code>fs</code>模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况。同步API除了方法名的末尾多了一个<code>Sync</code>之外，异常对象与执行结果的传递方式也有相应变化。同样以<code>fs.readFileSync</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  var data = fs.readFileSync(pathname);</div><div class="line">  // Deal with data.</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  // Deal with error.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>fs</code>模块提供的API很多，这里不一一介绍，需要时请自行查阅官方文档。</p>
<p><a href="http://nodejs.org/api/path.html" target="_blank" rel="external">官方文档</a></p>
<p>操作文件时难免与文件路径打交道。NodeJS提供了<code>path</code>内置模块来简化路径相关操作，并提升代码可读性。以下是几个常用的API简介。</p>
<ul>
<li>
<p>path.normalize</p>
<p>将传入的路径转换为标准路径，具体讲的话，除了解析路径中的<code>.</code>与<code>..</code>外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var cache = &#123;&#125;;</div><div class="line"></div><div class="line">function store(key, value) &#123;</div><div class="line">  cache[path.normalize(key)] = value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store(&apos;foo/bar&apos;, 1);</div><div class="line">store(&apos;foo//baz//../bar&apos;, 2);</div><div class="line">console.log(cache);  // =&gt; &#123; &quot;foo/bar&quot;: 2 &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>**坑出没注意： **标准化之后的路径里的斜杠在Windows系统下是<code>\</code>，而在Linux系统下是<code>/</code>。如果想保证任何系统下都使用<code>/</code>作为路径分隔符的话，需要用<code>.replace(/\\/g, '/')</code>再替换一下标准路径。</p>
</blockquote>
<ul>
<li>
<p>path.join</p>
<p>将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot;</div></pre></td></tr></table></figure>
</li>
<li>
<p>path.extname</p>
<p>当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>path</code>模块提供的其余方法也不多，稍微看一下官方文档就能全部掌握。</p>
<h4 id="遍历目录">遍历目录</h4>
<p>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。</p>
<h5 id="递归算法">递归算法</h5>
<p>遍历目录时一般使用递归算法，否则就难以编写出简洁的代码。递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(n) &#123;</div><div class="line">  if(n === 1) &#123;</div><div class="line">    return 1;</div><div class="line">  &#125; else &#123;</div><div class="line">    return n * factorial(n - 1);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上边的函数用于计算N的阶乘（N!）。可以看到，当N大于1时，问题简化为计算N乘以N-1的阶乘。当N等于1时，问题达到最小规模，不需要再简化，因此直接返回1。</p>
<blockquote>
<p><strong>陷阱</strong>： 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数！</p>
</blockquote>
<h5 id="遍历算法">遍历算法</h5>
<p>目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式时，下边这棵树的遍历顺序是<code>A &gt; B &gt; D &gt; E &gt; C &gt; F</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    A</div><div class="line">   / \</div><div class="line">  B   C</div><div class="line"> / \   \</div><div class="line">D   E   F</div></pre></td></tr></table></figure>
<h5 id="同步遍历">同步遍历</h5>
<p>了解了必要的算法后，我们可以简单地实现以下目录遍历函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function travel(dir, callback) &#123;</div><div class="line">  fs.readdirSync(dir).forEach(function (file) &#123;</div><div class="line">    var pathname = path.join(dir, file);</div><div class="line"></div><div class="line">    if(fs.statSync(pathname).isDirectory()) &#123;</div><div class="line">      travel(pathname, callback);</div><div class="line">    &#125; else &#123;</div><div class="line">      callback(pathname);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，该函数以某个目录作为遍历的起点。遇到一个子目录时，就先接着遍历子目录。遇到一个文件时，就把文件的绝对路径传给回调函数。回调函数拿到文件路径后，就可以做各种判断和处理。因此假设有以下目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- /home/user/</div><div class="line">  - foo/</div><div class="line">    x.js</div><div class="line">  - bar/</div><div class="line">    y.js</div><div class="line">    z.css</div></pre></td></tr></table></figure>
<p>使用以下代码遍历该目录时，得到的输入如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">travel(&apos;/home/user&apos;, function (pathname) &#123;</div><div class="line">  console.log(pathname);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">------------------------</div><div class="line">/home/user/foo/x.js</div><div class="line">/home/user/bar/y.js</div><div class="line">/home/user/z.css</div></pre></td></tr></table></figure>
<h5 id="异步遍历">异步遍历</h5>
<p>如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。<code>travel</code>函数的异步版本如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function travel(dir, callback, finish) &#123;</div><div class="line">  fs.readdir(dir, function (err, files) &#123;</div><div class="line">    (function next(i) &#123;</div><div class="line">       if(i &lt; files.length) &#123;</div><div class="line">         var pathname = path.join(dir, files[i]);</div><div class="line"></div><div class="line">         fs.stat(pathname, function (err, stats) &#123;</div><div class="line">           if(stats.isDirectory()) &#123;</div><div class="line">             travel(pathname, callback, function () &#123;</div><div class="line">               next(i + 1);</div><div class="line">             &#125;);</div><div class="line">           &#125; else &#123;</div><div class="line">             callback(pathname, function () &#123;</div><div class="line">               next(i + 1);</div><div class="line">             &#125;);</div><div class="line">           &#125;</div><div class="line">         &#125;);</div><div class="line">       &#125; else &#123;</div><div class="line">         finish &amp;&amp; finish();</div><div class="line">         &#125;</div><div class="line">       &#125;(0));</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里不详细介绍异步遍历函数的编写技巧，在后续章节中会详细介绍这个。总之我们可以看到异步编程还是蛮复杂的。</p>
<h4 id="文本编码">文本编码</h4>
<p>使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有<code>UTF8</code>和<code>GBK</code>两种，并且<code>UTF8</code>文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的<code>UTF8</code>编码字符串后才能正常处理。</p>
<h5 id="bom的移除">BOM的移除</h5>
<p>BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（&quot;\uFEFF&quot;），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    Bytes      Encoding</div><div class="line">----------------------------</div><div class="line">    FE FF       UTF16BE</div><div class="line">    FF FE       UTF16LE</div><div class="line">    EF BB BF    UTF8</div></pre></td></tr></table></figure>
<p>因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。</p>
<p>例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM。例如，以下代码实现了识别和去除UTF8 BOM的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function readText(pathname) &#123;</div><div class="line">  var bin = fs.readFileSync(pathname);</div><div class="line"></div><div class="line">  if(bin[0] === 0xEF &amp;&amp; bin[1] === 0xBB &amp;&amp; bin[2] === 0xBF) </div><div class="line">    bin = bin.slice(3);</div><div class="line">  &#125;</div><div class="line">  return bin.toString(&apos;utf-8&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="gbk转utf8">GBK转UTF8</h5>
<p>NodeJS支持在读取文本文件时，或者在<code>Buffer</code>转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助<code>iconv-lite</code>这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var iconv = require(&apos;iconv-lite&apos;);</div><div class="line"></div><div class="line">function readGBKText(pathname) &#123;</div><div class="line">  var bin = fs.readFileSync(pathname);</div><div class="line">  return iconv.decode(bin, &apos;gbk&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="单字节编码">单字节编码</h5>
<p>有时候，我们无法预知需要读取的文件采用哪种编码，因此也就无法指定正确的编码。比如我们要处理的某些CSS文件中，有的用GBK编码，有的用UTF8编码。虽然可以一定程度可以根据文件的字节内容猜测出文本编码，但这里要介绍的是有些局限，但是要简单得多的一种技术。</p>
<p>首先我们知道，如果一个文本文件只包含英文字符，比如<code>Hello World</code>，那无论用GBK编码或是UTF8编码读取这个文件都是没问题的。这是因为在这些编码下，ASCII0~128范围内字符都使用相同的单字节编码。</p>
<p>反过来讲，即使一个文本文件中有中文等字符，如果我们需要处理的字符仅在ASCII0~128范围内，比如除了注释和字符串以外的JS代码，我们就可以统一使用单字节编码来读取文件，不用关心文件的实际编码是GBK还是UTF8。以下示例说明了这种方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1. GBK编码源文件内容：</div><div class="line">    var foo = &apos;中文&apos;;</div><div class="line">2. 对应字节：</div><div class="line">    76 61 72 20 66 6F 6F 20 3D 20 27 D6 D0 CE C4 27 3B</div><div class="line">3. 使用单字节编码读取后得到的内容：</div><div class="line">    var foo = &apos;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&apos;;</div><div class="line">4. 替换内容：</div><div class="line">    var bar = &apos;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&#123;乱码&#125;&apos;;</div><div class="line">5. 使用单字节编码保存后对应字节：</div><div class="line">    76 61 72 20 62 61 72 20 3D 20 27 D6 D0 CE C4 27 3B</div><div class="line">6. 使用GBK编码读取后得到内容：</div><div class="line">    var bar = &apos;中文&apos;;</div></pre></td></tr></table></figure>
<h4 id="小结">小结</h4>
<p>本章介绍了使用NodeJS操作文件时需要的API以及一些技巧，总结起来有以下几点：</p>
<ul>
<li>学好文件操作，编写各种程序都不怕。</li>
<li>如果不是很在意性能，<code>fs</code>模块的同步API能让生活更加美好。</li>
<li>需要对文件读写做到字节级别的精细控制时，请使用<code>fs</code>模块的文件底层操作API。</li>
<li>不要使用拼接字符串的方式来处理路径，使用<code>path</code>模块。</li>
<li>掌握好目录遍历和文件编码处理技巧，很实用。</li>
</ul>
<h3 id="网络操作">网络操作</h3>
<p>一个合格的FE不能是不了解网络的，而NodeJS提供了一扇了解网络编程的窗口。通过NodeJS，除了可以编写一些服务端程序来协助前端开发和测试外，还能够学习一些HTTP协议与Socket协议的相关知识，这些知识在优化前端性能和排查前端故障时说不定能派上用场。本章将介绍与之相关的<em>NodeJS内置模块</em>。</p>
<h4 id="引入">引入</h4>
<p>NodeJS本来的用途是编写高性能Web服务器。我们首先在这里重复一下官方文档里的例子，使用NodeJS内置的<code>http</code>模块简单实现一个HTTP服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text-plain&apos; &#125;);</div><div class="line">  response.end(&apos;Hello World\n&apos;);</div><div class="line">&#125;).listen(8124);</div></pre></td></tr></table></figure>
<p>以上程序创建了一个HTTP服务器并监听<code>8124</code>端口，打开浏览器访问该端口<code>http://127.0.0.1:8124/</code>就能够看到效果。</p>
<blockquote>
<p><strong>xiao知识：</strong> 在Linux系统下，监听1024以下端口需要root权限。因此，如果想监听80或443端口的话，需要使用<code>sudo</code>命令启动程序。</p>
</blockquote>
<h4 id="api-watching">API watching</h4>
<p>先大致看看NodeJS提供了哪些和网络操作有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h5 id="http">HTTP</h5>
<p><a href="http://nodejs.org/api/http.html" target="_blank" rel="external">官方文档</a></p>
<p>'http’模块提供两种使用方式：</p>
<ul>
<li>作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。</li>
<li>作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。</li>
</ul>
<p>先来看看<strong>服务端模式</strong>下如何工作。如前文的例子所示，首先需要使用<code>.createServer</code>方法创建一个服务器，然后调用<code>.listen</code>方法监听端口。之后，每当来了一个客户端请求，创建服务器时传入的回调函数就被调用一次。可以看出，这是一种事件机制。</p>
<p>http请求本质上是一个数据流，由请求头（headers）和请求体（body）组成。例如以下是一个完整的HTTP请求数据内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">POST / HTTP/1.1</div><div class="line">User-Agent: curl/7.26.0</div><div class="line">Host: localhost</div><div class="line">Accept: */*</div><div class="line">Content-Length: 11</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>可以看到，空行之上是请求头，之下是请求体。http请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而<code>http</code>模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。在回调函数中，除了可以使用<code>request</code>对象访问请求头数据外，还能把<code>request</code>对象当作一个只读数据流来访问请求体数据。</p>
<p>以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var body = [];</div><div class="line"></div><div class="line">  console.log(request.method);</div><div class="line">  console.log(request.headers);</div><div class="line"></div><div class="line">  request.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  request.on(&apos;end&apos;, function () &#123;</div><div class="line">    body = Buffer.concat(body);</div><div class="line">    console.log(body.toString());</div><div class="line">  &#125;);</div><div class="line">&#125;).listen(80);</div><div class="line"></div><div class="line">------------------------------------</div><div class="line">POST</div><div class="line">&#123; &apos;user-agent&apos;: &apos;curl/7.26.0&apos;,</div><div class="line">  host: &apos;localhost&apos;,</div><div class="line">  accept: &apos;*/*&apos;,</div><div class="line">  &apos;content-length&apos;: &apos;11&apos;,</div><div class="line">  &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos; &#125;</div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>http响应本质上也是一个数据流，同样由响应头（headers）和响应体（body）组成。例如以下是一个完整的 http请求数据内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Content-Type: text/plain</div><div class="line">Content-Length: 11</div><div class="line">Date: Tue, 05 Nov 2013 05:31:38 GMT</div><div class="line">Connection: keep-alive</div><div class="line"></div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>在回调函数中，除了可以使用<code>response</code>对象来写入响应头数据外，还能把<code>response</code>对象当作一个只写数据流来写入响应体数据。例如在以下例子中，服务端原样将客户端请求的请求体数据返回给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">    response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</div><div class="line"></div><div class="line">    request.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">        response.write(chunk);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    request.on(&apos;end&apos;, function () &#123;</div><div class="line">        response.end();</div><div class="line">    &#125;);</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接下来看客户端模式下如何工作。为了发起一个客户端http请求，我们需要指定目标服务器的位置并发送请求头和请求体，以下示例演示了具体做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  hostname: &apos;www.example.com&apos;,</div><div class="line">  port: 80,</div><div class="line">  path: &apos;/upload&apos;,</div><div class="line">  method: &apos;POST&apos;,</div><div class="line">  headers: &#123;</div><div class="line">    &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var request = http.request(options, function (response) &#123;&#125;);</div><div class="line"></div><div class="line">request.write(&apos;Hello World&apos;);</div><div class="line">request.end();</div></pre></td></tr></table></figure>
<p>可以看到，<code>.request</code>方法创建了一个客户端，并指定请求目标和请求头数据。之后，就可以把<code>request</code>对象当作一个只写数据流来写入请求体数据和结束请求。另外，由于HTTP请求中<code>GET</code>请求是最常见的一种，并且不需要请求体，因此<code>http</code>模块也提供了以下便捷API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http.get(&apos;http://www.example.com/&apos;, function (response) &#123;&#125;);</div></pre></td></tr></table></figure>
<p>当客户端发送请求并接收到完整的服务端响应头时，就会调用回调函数。在回调函数中，除了可以使用<code>response</code>对象访问响应头数据外，还能把<code>response</code>对象当作一个只读数据流来访问响应体数据。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">http.get(&apos;http://www.example.com/&apos;, function (response) &#123;</div><div class="line">  var body = [];</div><div class="line"></div><div class="line">  console.log(response.statusCode);</div><div class="line">  console.log(response.headers);</div><div class="line"></div><div class="line">  response.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  response.on(&apos;end&apos;, function () &#123;</div><div class="line">    body = Buffer.concat(body);</div><div class="line">    console.log(body.toString());</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">------------------------------------</div><div class="line">200</div><div class="line">&#123; &apos;content-type&apos;: &apos;text/html&apos;,</div><div class="line">  server: &apos;Apache&apos;,</div><div class="line">  &apos;content-length&apos;: &apos;801&apos;,</div><div class="line">  date: &apos;Tue, 05 Nov 2013 06:08:41 GMT&apos;,</div><div class="line">  connection: &apos;keep-alive&apos; &#125;</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">...</div></pre></td></tr></table></figure>
<h5 id="https">HTTPS</h5>
<p><a href="http://nodejs.org/api/https.html" target="_blank" rel="external">官方文档</a></p>
<p><code>https</code>模块与<code>http</code>模块极为类似，区别在于<code>https</code>模块需要额外处理SSL证书。</p>
<p>在服务端模式下，创建一个HTTPS服务器的示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  key: fs.readFileSync(&apos;./ssl/default.key&apos;),</div><div class="line">  cert: fs.readFileSync(&apos;./ssl/default.cer&apos;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var server = https.createServer(options, function (request, response) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>可以看到，与创建HTTP服务器相比，多了一个<code>options</code>对象，通过<code>key</code>和<code>cert</code>字段指定了HTTPS服务器使用的私钥和公钥。</p>
<p>另外，NodeJS支持<a href="https://shansing.com/read/355/" target="_blank" rel="external">SNI技术</a> ，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。接着上例，可以使用以下方法为HTTPS服务器添加多组证书。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server.addContext(&apos;foo.com&apos;, &#123;</div><div class="line">  key: fs.readFileSync(&apos;./ssl/foo.com.key&apos;),</div><div class="line">  cert: fs.readFileSync(&apos;./ssl/foo.com.cer&apos;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.addContext(&apos;bar.com&apos;, &#123;</div><div class="line">  key: fs.readFileSync(&apos;./ssl/bar.com.key&apos;),</div><div class="line">  cert: fs.readFileSync(&apos;./ssl/bar.com.cer&apos;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在客户端模式下，发起一个HTTPS客户端请求与<code>http</code>模块几乎相同，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  hostname: &apos;www.example.com&apos;,</div><div class="line">  port: 443,</div><div class="line">  path: &apos;/&apos;,</div><div class="line">  method: &apos;GET&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var request = https.request(options, function (response) &#123;&#125;);</div><div class="line"></div><div class="line">request.end();</div></pre></td></tr></table></figure>
<p>但如果目标服务器使用的SSL证书是自制的，不是从颁发机构购买的，默认情况下<code>https</code>模块会拒绝连接，提示说有证书安全问题。在<code>options</code>里加入<code>rejectUnauthorized: false</code>字段可以禁用对证书有效性的检查，从而允许<code>https</code>模块请求开发环境下使用自制证书的HTTPS服务器。</p>
<h5 id="url">URL</h5>
<p><a href="http://nodejs.org/api/url.html" target="_blank" rel="external">官方文档</a></p>
<p>处理HTTP请求时<code>url</code>模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。首先我们来看看一个完整的URL的各组成部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                           href</div><div class="line"> -----------------------------------------------------------------</div><div class="line">                            host              path</div><div class="line">                      --------------- ----------------------------</div><div class="line"> http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash</div><div class="line"> -----    ---------   --------   ---- -------- ------------- -----</div><div class="line">protocol     auth     hostname   port pathname     search     hash</div><div class="line">                                                ------------</div><div class="line">                                                   query</div></pre></td></tr></table></figure>
<p>我们可以使用<code>.parse</code>方法来将一个URL字符串转换为URL对象，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">url.parse(&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;);</div><div class="line">/* =&gt;</div><div class="line">&#123; protocol: &apos;http:&apos;,</div><div class="line">  auth: &apos;user:pass&apos;,</div><div class="line">  host: &apos;host.com:8080&apos;,</div><div class="line">  port: &apos;8080&apos;,</div><div class="line">  hostname: &apos;host.com&apos;,</div><div class="line">  hash: &apos;#hash&apos;,</div><div class="line">  search: &apos;?query=string&apos;,</div><div class="line">  query: &apos;query=string&apos;,</div><div class="line">  pathname: &apos;/p/a/t/h&apos;,</div><div class="line">  path: &apos;/p/a/t/h?query=string&apos;,</div><div class="line">  href: &apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos; &#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>传给<code>.parse</code>方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，<code>request.url</code>不包含协议头和域名，但同样可以用<code>.parse</code>方法解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var tmp = request.url; // =&gt; &quot;/foo/bar?a=b&quot;</div><div class="line">  url.parse(tmp);</div><div class="line">  /* =&gt;</div><div class="line">  &#123; protocol: null,</div><div class="line">    slashes: null,</div><div class="line">    auth: null,</div><div class="line">    host: null,</div><div class="line">    port: null,</div><div class="line">    hostname: null,</div><div class="line">    hash: null,</div><div class="line">    search: &apos;?a=b&apos;,</div><div class="line">    query: &apos;a=b&apos;,</div><div class="line">    pathname: &apos;/foo/bar&apos;,</div><div class="line">    path: &apos;/foo/bar?a=b&apos;,</div><div class="line">    href: &apos;/foo/bar?a=b&apos; </div><div class="line">  &#125;</div><div class="line">  */</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p><code>.parse</code>方法还支持第二个和第三个布尔类型可选参数。第二个参数等于<code>true</code>时，该方法返回的URL对象中，<code>query</code>字段不再是一个字符串，而是一个经过<code>querystring</code>模块转换后的参数对象。第三个参数等于<code>true</code>时，该方法可以正确解析不带协议头的URL，例如<code>//www.example.com/foo/bar</code>。</p>
<p>反过来，<code>format</code>方法允许将一个URL对象转换为URL字符串，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">url.format(&#123;</div><div class="line">  protocol: &apos;http:&apos;,</div><div class="line">  host: &apos;www.example.com&apos;,</div><div class="line">  pathname: &apos;/p/a/t/h&apos;,</div><div class="line">  search: &apos;query=string&apos;</div><div class="line">&#125;);</div><div class="line">/* =&gt;</div><div class="line">&apos;http://www.example.com/p/a/t/h?query=string&apos;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>另外，<code>.resolve</code>方法可以用于拼接URL，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">url.resolve(&apos;http://www.example.com/foo/bar&apos;, &apos;../baz&apos;);</div><div class="line">/* =&gt;</div><div class="line">http://www.example.com/baz</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="query-string">Query String</h5>
<p><a href="http://nodejs.org/api/querystring.html" target="_blank" rel="external">官方文档</a></p>
<p><code>querystring</code>模块用于实现URL参数字符串与参数对象的互相转换，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;);</div><div class="line">/* =&gt;</div><div class="line">&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;</div><div class="line">*/</div><div class="line"></div><div class="line">querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;);</div><div class="line">/* =&gt;</div><div class="line">&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="zlib">Zlib</h5>
<p><a href="http://nodejs.org/api/zlib.html" target="_blank" rel="external">官方文档</a></p>
<p><code>zlib</code>模块提供了数据压缩和解压的功能。当处理HTTP请求和响应时，可能需要用到这个模块。</p>
<p>首先看一个使用<code>zlib</code>模块压缩HTTP响应体数据的例子。这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用<code>zlib</code>模块返回gzip之后的响应体数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var i = 1024,</div><div class="line">      data = &apos;&apos;;</div><div class="line"></div><div class="line">  while (i--) &#123;</div><div class="line">    data += &apos;.&apos;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if((request.headers[&apos;accept-encoding&apos;] || &apos;&apos;).indexOf(&apos;gzip&apos;) !== -1) &#123;</div><div class="line">    zlib.gzip(data, function (err, data) &#123;</div><div class="line">      response.writeHead(200, &#123;</div><div class="line">        &apos;Content-Type&apos;: &apos;text/plain&apos;,</div><div class="line">        &apos;Content-Encoding&apos;: &apos;gzip&apos;</div><div class="line">      &#125;);</div><div class="line">      response.end(data);</div><div class="line">    &#125;);</div><div class="line">  &#125; else &#123;</div><div class="line">    response.writeHead(200, &#123;</div><div class="line">      &apos;Content-Type&apos;: &apos;text/plain&apos;</div><div class="line">    &#125;);</div><div class="line">    response.end(data);</div><div class="line">  &#125;</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接着我们看一个使用<code>zlib</code>模块解压HTTP响应体数据的例子。这个例子中，判断了服务端响应是否使用gzip压缩，并在压缩的情况下使用<code>zlib</code>模块解压响应体数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  hostname: &apos;www.example.com&apos;,</div><div class="line">  port: 80,</div><div class="line">  path: &apos;/&apos;,</div><div class="line">  method: &apos;GET&apos;,</div><div class="line">  headers: &#123;</div><div class="line">    &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">http.request(options, function (response) &#123;</div><div class="line">  var body = [];</div><div class="line"></div><div class="line">  response.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  response.on(&apos;end&apos;, function () &#123;</div><div class="line">    body = Buffer.concat(body);</div><div class="line"></div><div class="line">  if(response.headers[&apos;content-encoding&apos;] === &apos;gzip&apos;) &#123;</div><div class="line">    zlib.gunzip(body, function (err, data) &#123;</div><div class="line">      console.log(data.toString());</div><div class="line">    &#125;);</div><div class="line">  &#125; else &#123;</div><div class="line">    console.log(data.toString());</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;).end();</div></pre></td></tr></table></figure>
<h5 id="net">Net</h5>
<p><a href="http://nodejs.org/api/net.html" target="_blank" rel="external">官方文档</a></p>
<p><code>net</code>模块可用于创建Socket服务器或Socket客户端。由于Socket在前端领域的使用范围还不是很广，这里先不涉及到WebSocket的介绍，仅仅简单演示一下如何从Socket层面来实现HTTP请求和响应。</p>
<p>首先我们来看一个使用Socket搭建一个很不严谨的HTTP服务器的例子。这个HTTP服务器不管收到啥请求，都固定返回相同的响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">net.createServer(function (conn) &#123;</div><div class="line">  conn.on(&apos;data&apos;, function (data) &#123;</div><div class="line">    conn.write([</div><div class="line">      &apos;HTTP/1.1 200 OK&apos;,</div><div class="line">      &apos;Content-Type: text/plain&apos;,</div><div class="line">      &apos;Content-Length: 11&apos;,</div><div class="line">      &apos;&apos;,</div><div class="line">      &apos;Hello World&apos;</div><div class="line">    ].join(&apos;\n&apos;));</div><div class="line">  &#125;);</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接着来看一个使用Socket发起HTTP客户端请求的例子。这个例子中，Socket客户端在建立连接后发送了一个HTTP GET请求，并通过<code>data</code>事件监听函数来获取服务器响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  port: 80,</div><div class="line">  host: &apos;www.example.com&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var client = net.connect(options, function () &#123;</div><div class="line">  client.write([</div><div class="line">    &apos;GET / HTTP/1.1&apos;,</div><div class="line">    &apos;User-Agent: curl/7.26.0&apos;,</div><div class="line">    &apos;Host: www.baidu.com&apos;,</div><div class="line">    &apos;Accept: */*&apos;,</div><div class="line">    &apos;&apos;,</div><div class="line">    &apos;&apos;</div><div class="line">  ].join(&apos;\n&apos;));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">client.on(&apos;data&apos;, function (data) &#123;</div><div class="line">  console.log(data.toString());</div><div class="line">  client.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="灵机一点">灵机一点</h4>
<p>使用NodeJS操作网络，特别是操作HTTP请求和响应时会遇到一些惊喜，这里对一些常见问题做解答。</p>
<ul>
<li>
<p>问： 为什么通过<code>headers</code>对象访问到的HTTP请求头或响应头字段不是驼峰的？</p>
<p>答： 从规范上讲，HTTP请求头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个HTTP服务端或客户端程序都严格遵循规范，所以NodeJS在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如<code>headers['content-length']</code>。</p>
</li>
<li>
<p>问： 为什么<code>http</code>模块创建的HTTP服务器返回的响应是<code>chunked</code>传输方式的？</p>
<p>答： 因为默认情况下，使用<code>.writeHead</code>方法写入响应头后，允许使用<code>.write</code>方法写入任意长度的响应体数据，并使用<code>.end</code>方法结束一个响应。由于响应体数据长度不确定，因此NodeJS自动在响应头里添加了<code>Transfer-Encoding: chunked</code>字段，并采用<code>chunked</code>传输方式。但是当响应体数据长度确定时，可使用<code>.writeHead</code>方法在响应头里加上<code>Content-Length</code>字段，这样做之后NodeJS就不会自动添加<code>Transfer-Encoding</code>字段和使用<code>chunked</code>传输方式。</p>
</li>
<li>
<p>问： 为什么使用<code>http</code>模块发起HTTP客户端请求时，有时候会发生<code>socket hang up</code>错误？</p>
<p>答： 发起客户端HTTP请求前需要先创建一个客户端。<code>http</code>模块提供了一个全局客户端<code>http.globalAgent</code>，可以让我们使用<code>.request</code>或<code>.get</code>方法时不用手动创建客户端。但是全局客户端默认只允许5个并发Socket连接，当某一个时刻HTTP客户端请求创建过多，超过这个数字时，就会发生<code>socket hang up</code>错误。解决方法也很简单，通过<code>http.globalAgent.maxSockets</code>属性把这个数字改大些即可。另外，<code>https</code>模块遇到这个问题时也一样通过<code>https.globalAgent.maxSockets</code>属性来处理。</p>
</li>
</ul>
<h4 id="小结">小结</h4>
<p>本章介绍了使用NodeJS操作网络时需要的API以及一些坑回避技巧，总结起来有以下几点：</p>
<ul>
<li><code>http</code>和<code>https</code>模块支持服务端模式和客户端模式两种使用方式。</li>
<li><code>request</code>和<code>response</code>对象除了用于读写头数据外，都可以当作数据流来操作。</li>
<li><code>url.parse</code>方法加上<code>request.url</code>属性是处理HTTP请求时的固定搭配。</li>
<li>使用<code>zlib</code>模块可以减少使用HTTP协议时的数据传输量。</li>
<li>通过<code>net</code>模块的Socket服务器与客户端可对HTTP协议做底层操作。</li>
<li>小心踩坑。</li>
</ul>
<h3 id="进程管理">进程管理</h3>
<p>NodeJS可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。本章除了介绍与之相关的NodeJS内置模块外，还会重点介绍典型的使用场景。</p>
<h4 id="开门红">开门红</h4>
<p>我们已经知道了NodeJS自带的<code>fs</code>模块比较基础，把一个目录里的所有文件和子目录都拷贝到另一个目录里需要写不少代码。另外我们也知道，终端下的<code>cp</code>命令比较好用，一条<code>cp -r source/* target</code>命令就能搞定目录拷贝。那我们首先看看如何使用NodeJS调用终端命令来简化目录拷贝，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var child_process = require(&apos;child_process&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line"></div><div class="line">function copy(source, target, callback) &#123;</div><div class="line">  child_process.exec(</div><div class="line">    util.format(&apos;cp -r %s/* %s&apos;, source, target), callback);</div><div class="line">&#125;</div><div class="line"></div><div class="line">copy(&apos;a&apos;, &apos;b&apos;, function (err) &#123;</div><div class="line">    // ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>从以上代码中可以看到，子进程是异步运行的，通过回调函数返回执行结果。</p>
<h4 id="api">API</h4>
<p>先大致看看NodeJS提供了哪些和进程管理有关的API。这里并不逐一介绍每个API的使用方法，官方文档已经做得很好了。</p>
<h5 id="process">Process</h5>
<p><a href="http://nodejs.org/api/process.html" target="_blank" rel="external">官方文档</a></p>
<p>任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。在NodeJS中，可以通过<code>process</code>对象感知和控制NodeJS自身进程的方方面面。另外需要注意的是，<code>process</code>不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。</p>
<h5 id="child-process">Child Process</h5>
<p><a href="http://nodejs.org/api/child_process.html" target="_blank" rel="external">官方文档</a></p>
<p>使用<code>child_process</code>模块可以创建和控制子进程。该模块提供的API中最核心的是<code>.spawn</code>，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。</p>
<h5 id="cluster">Cluster</h5>
<p><a href="http://nodejs.org/api/cluster.html" target="_blank" rel="external">官方文档</a></p>
<p><code>cluster</code>模块是对<code>child_process</code>模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。</p>
<h4 id="应用场景">应用场景</h4>
<p>和进程管理相关的API单独介绍起来比较枯燥，因此这里从一些典型的应用场景出发，分别介绍一些重要API的使用方法。</p>
<h5 id="如何获取命令行参数">如何获取命令行参数</h5>
<p>在NodeJS中可以通过<code>process.argv</code>获取命令行参数。但是比较意外的是，<code>node</code>执行程序路径和主模块文件路径固定占据了<code>argv[0]</code>和<code>argv[1]</code>两个位置，而第一个命令行参数从<code>argv[2]</code>开始。为了让<code>argv</code>使用起来更加自然，可以按照以下方式处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function main(argv) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<h5 id="如何退出程序">如何退出程序</h5>
<p>通常一个程序做完所有事情后就正常退出了，这时程序的退出状态码为<code>0</code>。或者一个程序运行时发生了异常后就挂了，这时程序的退出状态码不等于<code>0</code>。如果我们在代码中捕获了某个异常，但是觉得程序不应该继续运行下去，需要立即退出，并且需要把退出状态码设置为指定数字，比如<code>1</code>，就可以按照以下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    // ...</div><div class="line">&#125; catch (err) &#123;</div><div class="line">    // ...</div><div class="line">    process.exit(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="如何控制输入输出">如何控制输入输出</h5>
<p>NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应<code>process.stdin</code>、<code>process.stdout</code>和<code>process.stderr</code>，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。例如，<code>console.log</code>可以按照以下方式实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function log() &#123;</div><div class="line">  process.stdout.write(</div><div class="line">    util.format.apply(util, arguments) + &apos;\n&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="如何降权">如何降权</h5>
<p>在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。以下是这样一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">http.createServer(callback).listen(80, function () &#123;</div><div class="line">  var env = process.env,</div><div class="line">  uid = parseInt(env[&apos;SUDO_UID&apos;] || process.getuid(), 10),</div><div class="line">  gid = parseInt(env[&apos;SUDO_GID&apos;] || process.getgid(), 10);</div><div class="line"></div><div class="line">  process.setgid(gid);</div><div class="line">  process.setuid(uid);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上例中有几点需要注意：</p>
<ol>
<li>如果是通过<code>sudo</code>获取root权限的，运行程序的用户的UID和GID保存在环境变量<code>SUDO_UID</code>和<code>SUDO_GID</code>里边。如果是通过<code>chmod +s</code>方式获取root权限的，运行程序的用户的UID和GID可直接通过<code>process.getuid</code>和<code>process.getgid</code>方法获取。</li>
<li><code>process.setuid</code>和<code>process.setgid</code>方法只接受<code>number</code>类型的参数。</li>
<li>降权时必须先降GID再降UID，否则顺序反过来的话就没权限更改程序的GID了。</li>
</ol>
<h5 id="如何创建子进程">如何创建子进程</h5>
<p>以下是一个创建NodeJS子进程的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;xxx.js&apos; ]);</div><div class="line"></div><div class="line">child.stdout.on(&apos;data&apos;, function (data) &#123;</div><div class="line">  console.log(&apos;stdout: &apos; + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.stderr.on(&apos;data&apos;, function (data) &#123;</div><div class="line">  console.log(&apos;stderr: &apos; + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.on(&apos;close&apos;, function (code) &#123;</div><div class="line">  console.log(&apos;child process exited with code &apos; + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上例中使用了<code>.spawn(exec, args, options)</code>方法，该方法支持三个参数。第一个参数是执行文件路径，可以是执行文件的相对或绝对路径，也可以是根据PATH环境变量能找到的执行文件名。第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。</p>
<p>另外，上例中虽然通过子进程对象的<code>.stdout</code>和<code>.stderr</code>访问子进程的输出，但通过<code>options.stdio</code>字段的不同配置，可以将子进程的输入输出重定向到任何数据流上，或者让子进程共享父进程的标准输入输出流，或者直接忽略子进程的输入输出。</p>
<h5 id="进程间如何通讯">进程间如何通讯</h5>
<p>在Linux系统下，进程之间可以通过信号互相通信。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ]);</div><div class="line"></div><div class="line">child.kill(&apos;SIGTERM&apos;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;SIGTERM&apos;, function () &#123;</div><div class="line">  cleanUp();</div><div class="line">  process.exit(0);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上例中，父进程通过<code>.kill</code>方法向子进程发送<code>SIGTERM</code>信号，子进程监听<code>process</code>对象的<code>SIGTERM</code>事件响应信号。不要被<code>.kill</code>方法的名称迷惑了，该方法本质上是用来给进程发送信号的，进程收到信号后具体要做啥，完全取决于信号的种类和进程自身的代码。</p>
<p>另外，如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ], &#123;</div><div class="line">  stdio: [ 0, 1, 2, &apos;ipc&apos; ]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">  console.log(msg);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.send(&#123; hello: &apos;hello&apos; &#125;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">  msg.hello = msg.hello.toUpperCase();</div><div class="line">  process.send(msg);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，父进程在创建子进程时，在<code>options.stdio</code>字段中通过<code>ipc</code>开启了一条IPC通道，之后就可以监听子进程对象的<code>message</code>事件接收来自子进程的消息，并通过<code>.send</code>方法给子进程发送消息。在子进程这边，可以在<code>process</code>对象上监听<code>message</code>事件接收来自父进程的消息，并通过<code>.send</code>方法向父进程发送消息。数据在传递过程中，会先在发送端使用<code>JSON.stringify</code>方法序列化，再在接收端使用<code>JSON.parse</code>方法反序列化。</p>
<h5 id="如何守护子进程">如何守护子进程</h5>
<p>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。以下是一种实现方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* daemon.js */</div><div class="line">function spawn(mainModule) &#123;</div><div class="line">  var worker = child_process.spawn(&apos;node&apos;, [ mainModule ]);</div><div class="line"></div><div class="line">  worker.on(&apos;exit&apos;, function (code) &#123;</div><div class="line">    if(code !== 0) &#123;</div><div class="line">      spawn(mainModule);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn(&apos;worker.js&apos;);</div></pre></td></tr></table></figure>
<p>可以看到，工作进程非正常退出时，守护进程立即重启工作进程。</p>
<h4 id="小结">小结</h4>
<p>本章介绍了使用NodeJS管理进程时需要的API以及主要的应用场景，总结起来有以下几点：</p>
<ul>
<li>使用<code>process</code>对象管理自身。</li>
<li>使用<code>child_process</code>模块创建和管理子进程。</li>
</ul>
<h3 id="异步编程">异步编程</h3>
<p>NodeJS最大的卖点——事件机制和异步IO，对开发者并不是透明的。开发者需要按异步方式编写代码才用得上这个卖点，而这一点也遭到了一些NodeJS反对者的抨击。但不管怎样，异步编程确实是NodeJS最大的特点，没有掌握异步编程就不能说是真正学会了NodeJS。本章将介绍与异步编程相关的各种知识。</p>
<h4 id="回调">回调</h4>
<p>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。我们首先可以看看以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function heavyCompute(n, callback) &#123;</div><div class="line">  var count = 0,</div><div class="line">       i, j;</div><div class="line"></div><div class="line">  for(i = n; i &gt; 0; --i) &#123;</div><div class="line">    for(j = n; j &gt; 0; --j) &#123;</div><div class="line">      count += 1;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  callback(count);</div><div class="line">&#125;</div><div class="line"></div><div class="line">heavyCompute(10000, function (count) &#123;</div><div class="line">  console.log(count);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;hello&apos;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">100000000</div><div class="line">hello</div></pre></td></tr></table></figure>
<p>可以看到，以上代码中的回调函数仍然先于后续代码执行。JS本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念。</p>
<p>但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。我们接着看看以下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">setTimeout(function () &#123;</div><div class="line">  console.log(&apos;world&apos;);</div><div class="line">&#125;, 1000);</div><div class="line"></div><div class="line">console.log(&apos;hello&apos;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">hello</div><div class="line">world</div></pre></td></tr></table></figure>
<p>这次可以看到，回调函数后于后续代码执行了。如同上边所说，JS本身是单线程的，无法异步执行，因此我们可以认为<code>setTimeout</code>这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了<code>setTimeout</code>、<code>setInterval</code>这些常见的，这类函数还包括NodeJS提供的诸如<code>fs.readFile</code>之类的异步API。</p>
<p>另外，我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。以下就是这么一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function heavyCompute(n) &#123;</div><div class="line">  var count = 0,</div><div class="line">      i, j;</div><div class="line"></div><div class="line">  for (i = n; i &gt; 0; --i) &#123;</div><div class="line">    for (j = n; j &gt; 0; --j) &#123;</div><div class="line">      count += 1;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var t = new Date();</div><div class="line"></div><div class="line">setTimeout(function () &#123;</div><div class="line">  console.log(new Date() - t);</div><div class="line">&#125;, 1000);</div><div class="line"></div><div class="line">heavyCompute(50000);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">8520</div></pre></td></tr></table></figure>
<p>可以看到，本来应该在1秒后被调用的回调函数因为JS主线程忙于运行其它代码，实际执行时间被大幅延迟。</p>
<h4 id="代码设计模式">代码设计模式</h4>
<p>异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下分别介绍一些常见的模式。</p>
<h5 id="函数返回值">函数返回值</h5>
<p>使用一个函数的输出作为另一个函数的输入是很常见的需求，在同步方式下一般按以下方式编写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var output = fn1(fn2(&apos;input&apos;));</div><div class="line">// Do something.</div></pre></td></tr></table></figure>
<p>而在异步方式下，由于函数执行结果不是通过返回值，而是通过回调函数传递，因此一般按以下方式编写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fn2(&apos;input&apos;, function (output2) &#123;</div><div class="line">  fn1(output2, function (output1) &#123;</div><div class="line">    // Do something.</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，这种方式就是一个回调函数套一个回调函多，套得太多了很容易写出<code>&gt;</code>形状的代码。</p>
<h5 id="遍历数组">遍历数组</h5>
<p>在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。如果函数是同步执行的，一般就会写出以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var len = arr.length,</div><div class="line">    i = 0;</div><div class="line"></div><div class="line">for(; i &lt; len; ++i) &#123;</div><div class="line">  arr[i] = sync(arr[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// All array items have processed.</div></pre></td></tr></table></figure>
<p>如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(function next(i, len, callback) &#123;</div><div class="line">  if(i &lt; len) &#123;</div><div class="line">    async(arr[i], function (value) &#123;</div><div class="line">      arr[i] = value;</div><div class="line">      next(i + 1, len, callback);</div><div class="line">    &#125;);</div><div class="line">  &#125; else &#123;</div><div class="line">    callback();</div><div class="line">  &#125;</div><div class="line">&#125;(0, arr.length, function () &#123;</div><div class="line">    // All array items have processed.</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>可以看到，以上代码在异步函数执行一次并返回执行结果后才传入下一个数组成员并开始下一轮执行，直到所有数组成员处理完毕后，通过回调的方式触发后续代码的执行。</p>
<p>如果数组成员可以并行处理，但后续代码仍然需要所有数组成员处理完毕后才能执行的话，则异步代码会调整成以下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(function (i, len, count, callback) &#123;</div><div class="line">  for(; i &lt; len; ++i) &#123;</div><div class="line">    (function (i) &#123;</div><div class="line">      async(arr[i], function (value) &#123;</div><div class="line">        arr[i] = value;</div><div class="line">        if(++count === len) &#123;</div><div class="line">          callback();</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;(i));</div><div class="line">  &#125;</div><div class="line">&#125;(0, arr.length, 0, function () &#123;</div><div class="line">    // All array items have processed.</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员，并通过计数器变量来判断什么时候所有数组成员都处理完毕了。</p>
<h5 id="异常处理">异常处理</h5>
<p>JS自身提供的异常捕获和处理机制——<code>try..catch..</code>，只能用于同步执行的代码。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function sync(fn) &#123;</div><div class="line">  return fn();</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  sync(null);</div><div class="line">    // Do something.</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">Error: object is not a function</div></pre></td></tr></table></figure>
<p>可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个<code>try</code>语句时被捕获住。但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到<code>try</code>语句，就作为一个全局异常抛出。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function async(fn, callback) &#123;</div><div class="line">    // Code execution path breaks here.</div><div class="line">  setTimeout(function ()　&#123;</div><div class="line">    callback(fn());</div><div class="line">  &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  async(null, function (data) &#123;</div><div class="line">        // Do something.</div><div class="line">&#125;);</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">/home/user/test.js:4</div><div class="line">        callback(fn());</div><div class="line">                 ^</div><div class="line">TypeError: object is not a function</div><div class="line">  at null._onTimeout (/home/user/test.js:4:13)</div><div class="line">  at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)</div></pre></td></tr></table></figure>
<p>因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用<code>try</code>语句把异常捕获住，并通过回调函数传递被捕获的异常。于是我们可以像下边这样改造上边的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function async(fn, callback) &#123;</div><div class="line">    // Code execution path breaks here.</div><div class="line">  setTimeout(function ()　&#123;</div><div class="line">    try &#123;</div><div class="line">      callback(null, fn());</div><div class="line">    &#125; catch (err) &#123;</div><div class="line">    callback(err);</div><div class="line">    &#125;</div><div class="line">  &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">async(null, function (err, data) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">    console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">  &#125; else &#123;</div><div class="line">    // Do something.</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">Error: object is not a function</div></pre></td></tr></table></figure>
<p>可以看到，异常再次被捕获住了。在NodeJS中，几乎所有异步API都按照以上方式设计，回调函数中第一个参数都是<code>err</code>。因此我们在编写自己的异步函数时，也可以按照这种方式来处理异常，与NodeJS的设计风格保持一致。</p>
<p>有了异常处理方式后，我们接着可以想一想一般我们是怎么写代码的。基本上，我们的代码都是做一些事情，然后调用一个函数，然后再做一些事情，然后再调用一个函数，如此循环。如果我们写的是同步代码，只需要在代码入口点写一个<code>try</code>语句就能捕获所有冒泡上来的异常，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function main() &#123;</div><div class="line">    // Do something.</div><div class="line">  syncA();</div><div class="line">    // Do something.</div><div class="line">  syncB();</div><div class="line">    // Do something.</div><div class="line">  syncC();</div><div class="line">&#125;</div><div class="line"></div><div class="line">try &#123;</div><div class="line">  main();</div><div class="line">&#125; catch (err) &#123;</div><div class="line">  // Deal with exception.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，如果我们写的是异步代码，就只有呵呵了。由于每次异步函数调用都会打断代码执行路径，只能通过回调函数来传递异常，于是我们就需要在每个回调函数里判断是否有异常发生，于是只用三次异步函数调用，就会产生下边这种代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function main(callback) &#123;</div><div class="line">    // Do something.</div><div class="line">  asyncA(function (err, data) &#123;</div><div class="line">  if (err) &#123;</div><div class="line">    callback(err);</div><div class="line">  &#125; else &#123;</div><div class="line">    // Do something</div><div class="line">    asyncB(function (err, data) &#123;</div><div class="line">      if(err) &#123;</div><div class="line">        callback(err);</div><div class="line">      &#125; else &#123;</div><div class="line">        // Do something</div><div class="line">        asyncC(function (err, data) &#123;</div><div class="line">          if(err) &#123;</div><div class="line">            callback(err);</div><div class="line">          &#125; else &#123;</div><div class="line">            // Do something</div><div class="line">            callback(null);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(function (err) &#123;</div><div class="line">  if(err) &#123;</div><div class="line">    // Deal with exception.</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，回调函数已经让代码变得复杂了，而异步方式下对异常的处理更加剧了代码的复杂度。如果NodeJS的最大卖点最后变成这个样子，那就没人愿意用NodeJS了，因此接下来会介绍NodeJS提供的一些解决方案。</p>
<h4 id="域domain">域（Domain）</h4>
<p><a href="http://nodejs.org/api/domain.html" target="_blank" rel="external">官方文档</a></p>
<p>NodeJS提供了<code>domain</code>模块，可以简化异步代码的异常处理。在介绍该模块之前，我们需要首先理解“域”的概念。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过<code>process</code>对象提供了捕获全局异常的方法，示例代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">process.on(&apos;uncaughtException&apos;, function (err) &#123;</div><div class="line">  console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setTimeout(function (fn) &#123;</div><div class="line">  fn();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">Error: undefined is not a function</div></pre></td></tr></table></figure>
<p>虽然全局异常有个地方可以捕获了，但是对于大多数异常，我们希望尽早捕获，并根据结果决定代码的执行路径。我们用以下HTTP服务器代码作为例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function async(request, callback) &#123;</div><div class="line">    // Do something.</div><div class="line">  asyncA(request, function (err, data) &#123;</div><div class="line">    if(err) &#123;</div><div class="line">      callback(err);</div><div class="line">    &#125; else &#123;</div><div class="line">      // Do something</div><div class="line">      asyncB(request, function (err, data) &#123;</div><div class="line">        if(err) &#123;</div><div class="line">          callback(err);</div><div class="line">        &#125; else &#123;</div><div class="line">          // Do something</div><div class="line">          asyncC(request, function (err, data) &#123;</div><div class="line">            if(err) &#123;</div><div class="line">              callback(err);</div><div class="line">            &#125; else &#123;</div><div class="line">              // Do something</div><div class="line">              callback(null, data);</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  async(request, function (err, data) &#123;</div><div class="line">    if(err) &#123;</div><div class="line">      response.writeHead(500);</div><div class="line">      response.end();</div><div class="line">    &#125; else &#123;</div><div class="line">      response.writeHead(200);</div><div class="line">      response.end(data);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上代码将请求对象交给异步函数处理后，再根据处理结果返回响应。这里采用了使用回调函数传递异常的方案，因此<code>async</code>函数内部如果再多几个异步函数调用的话，代码就变成上边这副鬼样子了。为了让代码好看点，我们可以在每处理一个请求时，使用<code>domain</code>模块创建一个子域（JS子运行环境）。在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的<code>error</code>事件统一捕获。于是以上代码可以做如下改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function async(request, callback) &#123;</div><div class="line">    // Do something.</div><div class="line">  asyncA(request, function (data) &#123;</div><div class="line">      // Do something</div><div class="line">    asyncB(request, function (data) &#123;</div><div class="line">        // Do something</div><div class="line">      asyncC(request, function (data) &#123;</div><div class="line">          // Do something</div><div class="line">        callback(data);</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">  var d = domain.create();</div><div class="line"></div><div class="line">  d.on(&apos;error&apos;, function () &#123;</div><div class="line">    response.writeHead(500);</div><div class="line">    response.end();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  d.run(function () &#123;</div><div class="line">    async(request, function (data) &#123;</div><div class="line">      response.writeHead(200);</div><div class="line">      response.end(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，我们使用<code>.create</code>方法创建了一个子域对象，并通过<code>.run</code>方法进入需要在子域中运行的代码的入口点。而位于子域中的异步函数回调函数由于不再需要捕获异常，代码一下子瘦身很多。</p>
<h5 id="陷阱">陷阱</h5>
<p>无论是通过<code>process</code>对象的<code>uncaughtException</code>事件捕获到全局异常，还是通过子域对象的<code>error</code>事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。按照官方文档的说法，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。</p>
<p>但这里需要澄清一些事实。JS本身的<code>throw..try..catch</code>异常处理机制并不会导致内存泄漏，也不会让程序的执行结果出乎意料，但NodeJS并不是存粹的JS。NodeJS里大量的API内部是用C/C++实现的，因此NodeJS程序的运行过程中，代码执行路径穿梭于JS引擎内部和外部，而JS的异常抛出机制可能会打断正常的代码执行流程，导致C/C++部分的代码表现异常，进而导致内存泄漏等问题。</p>
<p>因此，使用<code>uncaughtException</code>或<code>domain</code>捕获异常，代码执行路径里涉及到了C/C++部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用<code>try</code>语句捕获异常时一般捕获到的都是JS本身的异常，不用担心上诉问题。</p>
<h4 id="小结">小结</h4>
<p>本章介绍了JS异步编程相关的知识，总结起来有以下几点：</p>
<ul>
<li>不掌握异步编程就不算学会NodeJS。</li>
<li>异步编程依托于回调来实现，而使用回调不一定就是异步编程。</li>
<li>异步编程下的函数间数据传递、数组遍历和异常处理与同步编程有很大差别。</li>
<li>使用<code>domain</code>模块简化异步代码的异常处理，并小心陷阱</li>
</ul>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经验之谈 </tag>
            
            <tag> 在路上 </tag>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[圣经几个读经方法]]></title>
      <url>http://zrdsj.cc/2016/09/23/Bible-reading/</url>
      <content type="html"><![CDATA[<p>几种读圣经的办法。准确点应该说是计划。圣经的通读，对基督徒来说其意义不言而喻。</p>
<a id="more"></a>
<p>最近使用了手机app—<a href="https://itunes.apple.com/cn/app/jing-du-sheng-jing/id969776780?mt=8" target="_blank" rel="external">精读圣经</a>。其中的设计与内容在我看来均为上乘，作者无偿满足了几乎全部的圣经学习需求，其平日运营的费用并不是向用户收费的。详情页面见👉 <a href="http://www.christapp.net/pay.html" target="_blank" rel="external">Love_GOD</a></p>
<p>言归正传，在app中我知道了几种不同的读经计划，也让自己平时零碎的读经变得更系统更合理了。令人十分欣慰。</p>
<h3 id="顺序读经计划">顺序读经计划</h3>
<p>这是最简单的方法了，按照对总量的计算和计划，将一年360多天的量都分出来。大概就是<code>每天3-4章的经文，一年可以读完新旧约一遍</code>。</p>
<p>此种方法也是有小细节可以优化的</p>
<ul>
<li>读的顺序可以不按照旧约新约中的排序，适量合理的编排方式也是可取的。（可以在网上进行搜寻）</li>
<li>读经贵在坚持，然天有不测风云，若因为偶然而来的事情耽误了每日读经，可在随后的周末休假找回时间来补上。相较于第二天读双倍的量，前一种方式更合理一些。</li>
</ul>
<h3 id="得胜读经计划">得胜读经计划</h3>
<p>听上去就让人舒服，我们为主祈福期盼美好得胜人间，主题一旦相通则尤显亲切​❤️​</p>
<p>这个计划在网上有比较详细的说明，我们接下来会搬运一些优质内容供学习借鉴。也会提供链接去往原文：<a href="http://blog.sina.com.cn/s/blog_a28834cb0101ce6n.html" target="_blank" rel="external">点这里</a></p>
<p>得胜读经计划有三个显著特点：</p>
<ol>
<li>每天读一篇诗篇或箴（zhen）言</li>
<li>一年读两遍福音书</li>
<li>按年代次序通读旧约</li>
</ol>
<p>每天都会读到诗篇或箴言，会让读经的过程显得新意满满。</p>
<p>几点使用建议：</p>
<ol>
<li>任何时候都可以开始：
你可以在一年中的任何时候开始使用你的《得胜读经计划》。现在就从今天的日期开始，只要你在以下的十二个月中很忠心地使用这个计划，就可以读完一遍《圣经》了。</li>
<li>假如你漏读了一天：
有时候因为一些紧急事件或意外事情使你这天不能按计划读经，我们强烈建议你：第二天不要试图一次读两天的计划，这样做只能使进度减慢。撒旦 会借机打击你的信心，使你很容易放弃整个读经计划。我们的建议是：如果你错过了一天，就越过那一天的读经计划，然后，到了周末，或你有了额外的时间，就回 过头来，补上你所漏读的那些读经计划。</li>
<li>写下特别关键的经文：
你可以记下在那一天的读经计划中神特别感动你的关键经文。若这节经文是神要你背下来的，那么你可以在这节经文的边上做一些特别记号，每周至少背一节这样的经文。</li>
<li>记下神对你所讲的话语：
神对他的儿女讲话主要通过《圣经》。假如你没有天天花时间读《圣经》的话，那么你就切断了神引导你的主要渠道。记下在这个月中神对你说话的主要内容，包括与这些话语相关的经文的出处。</li>
</ol>
<blockquote>
<p>最后，具体的计划表是什么呢？</p>
</blockquote>
<p>在我本小姐提供的链接里就有，可以打印出来加以使用效果更好。</p>
<h3 id="罗伯茨读经计划">罗伯茨读经计划</h3>
<p>此法可以帮你系统而又完整地读完一遍旧约圣经和两遍新约圣经。</p>
<p>在网上并没有找到可靠的相关资料，因此此处不再多说。大家可以下载推荐的app，并选择相应的读经计划（包括次法）。</p>
<h3 id="每日与主同行">每日与主同行</h3>
<p>全球销量突破十万本的《每日与主同行》读经计划，是一本深入经文又能引发思想的灵修书。</p>
<p>每一天在此计划中都有一个主题，有一段默想，以及与主同行的指引。可以帮助读者在一年内系统的将圣经读完。帮你对真理有深度全面的概览，扎稳一生信仰的根基。</p>
<p>提供一个在线链接：<a href="http://www.jonahome.net/files02/PI_DailyWalk/gb/index.htm" target="_blank" rel="external">BIBLE</a></p>
<h3 id="麦琴读经计划">麦琴读经计划</h3>
<p>这也是我所选择的读经计划。由十九世纪的一位英格兰牧师名叫麦琴（Robert Murray M’Chenyne）的所制定的。1842年发表，不仅影响了很多人，后来也深深影响了近代的清教徒钟马田牧师和改革宗福音派的斯托德博士。</p>
<p>他的方法是每天读四章经文，早上读一章旧约和一章新约，晚上也读一章旧约和一章新约，而晚上和早上不是连读，他把圣经分为四个开始：</p>
<ol>
<li>
<p>从创世记第一章开始——创世的开始</p>
</li>
<li>
<p>从以斯拉第一章开始——民族的更新</p>
</li>
<li>
<p>从马太福音一章开始——基督的降生</p>
</li>
<li>
<p>从使徒行传一章开始——教会的复兴</p>
</li>
</ol>
<h4 id="家庭敬拜">家庭敬拜：</h4>
<p>第一组即在早上的读经，可作为一个家庭敬拜，从创世记和马太福音开始，即上面的第①和第③项。旧约从创世记到历代志下共有403章，遇到篇章短的要读两章，在365天内读完；新约从马太福音到启示录，再加诗篇共有410章，也在一年内读完。</p>
<h4 id="个人灵修">个人灵修：</h4>
<p>第二组即在晚上的读经，可作为个人单独灵修，从以斯拉记和使徒行传开始，即上面的第②和第④项。旧约从以斯拉记到玛拉基书，（除了诗篇）共有376章，每天一章，一年读完；新约从使徒行传到启示录，再加诗篇和四福音共410章，也在一年内读完。</p>
<p>这样在一年内即可读完一遍旧约、两遍新约和两遍诗篇，并且将新旧约不停的交叉融会在一起，使我们的新生命每天都可以沉浸在新旧两约的恩典中渐渐成长。</p>
<p><a href="http://www.wellsofgrace.com/bible/resources/dujin-intro.htm" target="_blank" rel="external">点开看看</a></p>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 圣经 </tag>
            
            <tag> 读经 </tag>
            
            <tag> 生命 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《用户故事与敏捷方法》读后感1]]></title>
      <url>http://zrdsj.cc/2016/09/23/book-review1/</url>
      <content type="html"><![CDATA[<p>跟这本书的渊源，可以追溯大三的上半学期。当时在接触github的时候也得知了一位大神:<a href="https://www.phodal.com/" target="_blank" rel="external">phodal</a>。</p>
<a id="more"></a>
<p>一位芬达君2333，这位芬达君的技术很厉害，年纪轻轻却拥有令人惊叹的IT技能树。而且芬达君除了自己的工作以外，似乎在开源文化方面格外有所向往。</p>
<p>不再多说大神的事情，说说我和大神的故事。微博私信过大神几次，都得到了鼓励与帮助。。。后来大神搬家在微信上搞了个送书活动，你付邮费大神给你送书。。。我当时本想得一本《<a href="https://book.douban.com/subject/3224524/" target="_blank" rel="external">代码之美</a>》，因缘差错最后是得了这本《<a href="https://book.douban.com/subject/4743056/" target="_blank" rel="external">用户故事与敏捷方法</a>》。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1610-1611/yhgsymjff.jpg" alt="用户故事与敏捷方法"></p>
<p>由此，开始将今天第一阶段的读后感。。。</p>
<h3 id="这么点动静">这么点动静？</h3>
<p>自己拿到这本书蛮久了，却一直没怎么碰过其实。。。没什么动静确实是。。。</p>
<p>接下来打算写七篇类似的读后感，分别对应了这本书的21个章节（四大部分）</p>
<ul>
<li>第一部分 <strong>起步</strong> 1-7章</li>
<li>第二部分 <strong>估算和计划</strong> 8-11章</li>
<li>第三部分 <strong>经常讨论的话题</strong> 12-16章</li>
<li>第四部分 <strong>一个完整的实例</strong> 17-21章</li>
</ul>
<p>是第一部分2篇，第二部分1篇，第三部分2篇，第四部分2篇。计划大概就是这样。然后说说我到底想谈些什么？</p>
<h3 id="我到底想谈些什么">我到底想谈些什么？</h3>
<p>博客的标题是读后感，实际上这本书我并不是看完了才写的博客，而是看了第一部分才写的博客。说读后感的话，其实说是读书笔记或心得更合适点。</p>
<p>内容上来说，这本书并不是纯粹的技术类书籍，也许不会让你xx天精通xxx也不会让你深入浅出XXXX更不是XxXx权威指南给你指引道路。。。</p>
<p><code>这本书从一个独特的角度，对于开发人员测试人员产品分析人员管理人员等等，总之就是一个软件开发团队的所有人员，都有独特的启发和建议。</code></p>
<p>软件开发的知识，在我的大学后来专业课上是有专门的课程去讲些十年前二十年前几十年前的理论知识。且不说&quot;纸上得来终觉浅&quot;，也不说大的环境下的国内外的差异，单是时代的变换与发展，就决定了这个行业的故事，并不传统！</p>
<p>这样的技术或者说是能力，在我看来是硬技能的拓展并具有相当规模的软技能的影子。《用户故事与敏捷方法》就这样一本书—&gt;<code>为软件行业提供了一种节省时间和消除重复工作的需求管理方法，对开发更优秀的软件起着积极高效的作用</code>。</p>
<p>谈些什么？</p>
<p>不会是书里面的详细内容搬运，因为那样不如我提供一个在线的阅读或是一个电子版的下载。。。会是什么？<strong>是对于其中重点的概括介绍和名词释义。</strong></p>
<h3 id="扯不下去写出的读后感1">扯不下去写出的读后感1</h3>
<p>😂</p>
<p>1-3章：</p>
<ol>
<li><strong>概览</strong>：讲述’用户故事’的由来，并且介绍’用户故事’的过程与细节。</li>
<li><strong>编写故事</strong>：对故事更深的理解和举例讲述。</li>
<li><strong>用户角色建模</strong>：'用户角色’的一些故事</li>
</ol>
<h4 id="1111111111">1111111111</h4>
<p>软件需求是一个沟通问题。（不是我zhuangbi，在初三的那个暑假，在家看&lt;超人&gt;电视剧时候就为剧中的异国风情深深感动。当时跟一位好兄弟cgg说过的，自己觉得家庭和生活中的几乎所有不幸福，都是来源于沟通。2333）</p>
<p>软件的使用人员（包括有需求的所有角色，即使是销售人员）必须与开发者进行交流。一个项目的成功，依赖于很多不同的信息，这些信息来自于不同的人员：一方是<code>客户用户（有时还有分析人员领域专家及组织视角来观察审视软件的人）</code>另一方则是<code>开发技术团队</code>。</p>
<p>Balance是十分必要的，倘若上述的两者任何一方在沟通中把持绝对地位，项目都会遭受损失。不再列举哪一方xx的具体所示。</p>
<p>因此我们需要一种协同工作的办法，让双方都不占绝对主导地位，共同面对感情用事和办公室政治化的资源分配问题。。。</p>
<p>此外还有个问题是客观存在的，当用户看到早期版本的软件，也许新的点子就会出现，导致他们会改变自己的观点。由于这种不可控性再加上其他的因素，导致在软件开发的世界里无法勾勒出一幅完美的<a href="http://baike.baidu.com/link?url=U6arOehD5i9imDLqwvabV-Aabwpe7aNk_xuaiFRQ5xMdNFcTfRg2MLjLV7zn0N9tBf3kezc21fnLEaEtqEgGm_" target="_blank" rel="external">PERT图</a>来展示项目中所必须完成的事情。</p>
<p>So，我们该怎么办？答案是：<code>确保有一个&quot;尽量完美的&quot;获取信息过程，越早越好越频繁越好。。。</code>为此，<a href="http://baike.baidu.com/link?url=3dpOTVo3BjrHM6rUfurw77TWbdV471D9JYHRK-migWaO3spNdBwxRmuQcQUGiv3cGlvFNai-Ktgc0cRdF8-2_TCOWijkuO9SeOWNB4uDuy4StN6338M1JDnhb1ykT3_v" target="_blank" rel="external">用户故事</a>应运而生。</p>
<p>用户故事，描述了对用户、系统、软件购买者有价值的功能。由以下三部分组成：</p>
<ul>
<li>一份书面的故事描述，作为计划和提示。<strong>卡片</strong></li>
<li>有关故事的对话，用来具体化故事细节。<strong>交流（对话）</strong></li>
<li>测试，用于表达和编档故事细节且可用于确定故事完成时间。<strong>确认</strong></li>
</ul>
<p>六个问题，书中留下的目录级别问题。。。</p>
<ul>
<li>用户故事谁来编写？</li>
<li>注意哪些细节？</li>
<li>多长时间完成？</li>
<li>故事如何使用？</li>
<li><a href="http://baike.baidu.com/link?url=0SIXceVkMD-HPw0nv1T6NqNKlHGmdRSZQWX2se8eBYhEroSjXVsk9Pewv-ATmp109LGIA47kFr8k3uwrHeJsFT3a4tpoCX-kjJxkKCxPjMnXgJhJaL48oimGZPoUbClz" target="_blank" rel="external">验收测试</a>如何进行？</li>
<li>用户故事迭代过程变化如何理解？</li>
</ul>
<p>希望可以帮助去思考理解真正的&quot;用户故事&quot;！</p>
<h4 id="2222222222">2222222222</h4>
<p>这一章是讲的如何&quot;编写故事&quot;。应该说实际上是在第一章就出现过了，因为书中的第一章确确实实是出现了卡片（用户故事）的编写demo。</p>
<p>'编写故事’有六个特征，一般来说是如下那样：</p>
<ol>
<li>独立的（<strong>I</strong>ndependent）</li>
<li>可讨论的（<strong>N</strong>egotiable）</li>
<li>对用户或客户有价值的（<strong>V</strong>aluable to Purchasers or Users）</li>
<li>可估计的（<strong>E</strong>stimatable）</li>
<li>小的（<strong>S</strong>mall）</li>
<li>可测试的（<strong>T</strong>estable）</li>
</ol>
<p>总结下就是<strong>INVEST</strong>。接下来是不是要逐一的说说呢？</p>
<p>233，我懒就不说具体的每个特征是什么了。但是我总结下我的感想:</p>
<blockquote>
<p>充分考虑了问题的解决之道得来的<code>用户故事编写方法</code>，绝对是饱含了细节、人性化、管理科学、开发经验等重要内容。</p>
</blockquote>
<p>最后再来一点的补充，其实书上的总结。</p>
<ul>
<li>客户团队职责：
<ul>
<li>编写用户故事，这些故事提醒你同开发人员交谈，而不是记录详细的需求定义，它们对用户或你们自己是有价值的，它们是独立的、可测试的、大小合适的。</li>
</ul>
</li>
<li>开发人员负责：
<ul>
<li>帮助编写用户故事。这故事要能提醒你同客户交谈，而不是记录详细的记录定义，故事应该对用户或者客户有价值，它们是独立的，可测得，大小合适的。</li>
<li>如果被询问及实现用户故事所用的技术或者基础架构信息，应该使用对用户或客户有价值的术语来描述。</li>
</ul>
</li>
</ul>
<h4 id="3333333333">3333333333</h4>
<p>在许多的项目中，需求分析人员只是从一个角度分析用户故事，往往容易忽略掉一些需求（故事），因为很多时候有些故事并不针对系统的一般用户。<code>以用户为中心的设计规则会使我们懂得，在编写故事前识别用户角色和虚构人物（person）有很多好处</code>。</p>
<p>你是不是会看不懂上面那段话在bb什么？</p>
<p>通俗的讲就是说，我们为一个人群团体开发一款软件一个项目。我们可以在编写故事的时候去虚拟恰当的用户（实际并不存在，雷同另说），这样的好处在于<code>当你试图去创造有个用户的时候，本身该考虑的事情几乎都会被你考虑。因为你是在工作而不是毫无根据的吹牛逼！</code>这个好处不是在哪看的，书上我也没找着。。。是我自己写的。（书上仅仅是说这样做总是有好处的P34）</p>
<p>还是不明白看看:<a href="http://www.jianshu.com/p/9222a2baebeb" target="_blank" rel="external">这篇简书</a>。希望你会学到更多。。。</p>
<p>角色建模的步骤，这里po出来：</p>
<ul>
<li>通过<a href="http://zhidao.baidu.com/link?url=F3RVrCDWyKxb1qsPZw0U7kOk7p2WZdTkaTvbhnKdr7mSAQphNZpvcJvvSbnY9QHl2aDCeMc_hTm3prn-_1kGIa" target="_blank" rel="external">头脑风暴</a>，列出初始的用户角色集合</li>
<li>整理最初的角色集合</li>
<li>整合角色</li>
<li>提炼角色</li>
</ul>
<p>上面的四个步骤，一般情况下是耗时很短的，2333毕竟是头脑风暴。此外书中也给出了两个值得探讨的’技术’—:<em>虚拟人物</em>与<em>极端人物</em>。留给自己做备注了。。。</p>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 经验之谈 </tag>
            
            <tag> 用户故事 </tag>
            
            <tag> 敏捷方法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SEO的一些理解]]></title>
      <url>http://zrdsj.cc/2016/09/23/seo/</url>
      <content type="html"><![CDATA[<p>简单说明，是来写一些关于搜索引擎搜索的事情。与算法优化、数据服务器什么的没太大的交集（才不告诉你是博主不怎么精通2333）。</p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=18794244&auto=0&height=66"></iframe>
<h3 id="seo的基本介绍">SEO的基本介绍</h3>
<p>搜索引擎优化（<code>Search Engine Optimization</code>）即是通常所说的SEO，在说这个之前先来过一遍各大搜索引擎的工作原理。</p>
<p><img src="http://p9.qhimg.com/t0148b997530eefc9a7.jpg" alt="seo"></p>
<h4 id="搜索引擎的工作原理白话文">搜索引擎的工作原理（白话文）</h4>
<p>无论是国内的百度还是国际上的谷歌，在工作原理上，两家的搜索引擎原理是基本相通的。接下来的几乎全是大白话，哈哈。</p>
<p>搜索引擎供应商会在互联网上放出自己的特殊程序（一般称为蜘蛛Spider或者Bot），这些程序的作用就是在网络上发现新的网站并加以收录，收录进自家的数据服务器里面。在经过了足够多的<code>爬行抓取</code>之后，便可以攒取很多网站的网址及其信息。</p>
<p>有了以上所说的数据，搜索引擎便可以<code>建立索引</code>。在之后用户的搜索操作中，搜索引擎会根据用户给出的关键词关键字进行<code>搜索词处理</code>，这个过程会进行判断等处理，然后再进行<code>排序</code>，之后便可以将结果按照<strong>最准群—&gt;最不准确</strong>的顺序输出作为搜索结果。</p>
<h4 id="">???</h4>
<p>所以呢，我们当然希望百度谷歌收录我们想要的精准网站而不是不准确的网站以及一些无用的垃圾网站。这所谓的优化学问便是<code>SEO，是指为了增加网页在搜索引擎自然搜索结果中的收录数量以及提升排序位置而做的优化行为</code>。</p>
<p><em>SEO的技术大体分为两种，白帽SEO和黑帽SEO</em>。</p>
<p>前者是合理优化网站，提高用户体验，合理与其他网站互联。从而使站点在搜索引擎排名提升。白帽SEO关注的是长远利益，需要的时间长，但效果稳定。这一种是我们支持和提倡的。</p>
<p>后者黑帽SEO则是利用相关的技术漏洞去‘欺骗’引擎与消费者。不太明白？我给你举个栗子。</p>
<blockquote>
<p>前天0921晚上腾讯发布了<code>微信小程序</code>的相关通知说明，随后呢就在昨天许多相关的工具与破解方法甚至教程都是铺天盖地的全网一搜就是。</p>
<blockquote>
<p>现在呢我假想自己有一个与此内容(微信小程序)不相干的网站（比如说是个图书批发网站），我利用黑帽SEO这时候就可以做点事情了。我可以在我的网站上散步许多的与微信小程序的关键词关键字，而事实上这些东西只是假象，对我的网站来说也许会影响访问者的阅读。</p>
<p>但是！总的来说我的网站会因此在这几天被许多想要访问想要知道<code>微信小程序</code>的人看到,对我来说访问量和知名度都是在提升,也不失为是一种手段。</p>
</blockquote>
</blockquote>
<h4 id="作用效果">作用效果</h4>
<p>看了上面一小节所说的东西，估计你明白了。黑帽SEO的效果来得快，去的也快！因为黑帽SEO技术只能获取短暂的排名，被搜索引擎发现就会K掉，也许是得不偿失。而白帽SEO才是正确的公平的合理的优化方式。。</p>
<p>白帽SEO的作用效果：
-网站标题、关键字、描述（精心设计，反映网站定位）
-网站内容（增加关键字密度。增加长尾关键字）
-合理设置robot.txt文件
-网站地图
-增加外链引用
前端工程师可以进行网站结构布局优化，网页代码优化。</p>
<h3 id="seo与前端的关系">SEO与前端的关系</h3>
<p>在上一小节的末端，我引出了前端与白帽SEO的关系。做为一名前端，基本上了解SEO就可以了，而不需要精通。接下来就说一说两者的一些故事。。。</p>
<p>前端的工作主要是负责页面的HTML+CSS+JS，优化好这几个方面会为SEO工作打好一个坚实的基础。突出重要内容可以让搜索引擎判断当前页面的重点是什么，提升网站访问速度可以让搜索引擎的蜘蛛顺利、快速、大量的抓取网页内容。</p>
<p>仅仅是<strong>网站布局优化</strong>，<strong>网页代码优化</strong>这两方面么？</p>
<blockquote>
<p>我们要清楚，这世界上的很多技能同一些道理奥义一样。因为它永远都在变，没有一成不变的优化方案可供套用。</p>
</blockquote>
<p>那这两个方面可以做到的事情我们来说一下。。。</p>
<h4 id="网站布局优化">网站布局优化</h4>
<p>以下几个方面：</p>
<ul>
<li>
<p>结构布局优化：用扁平化结构（简单简洁的层次结构，超过三层小蜘蛛就不愿意爬了）</p>
</li>
<li>
<p>控制首页链接数量（中小网站100以内，包括页面导航、底部导航、锚文字链接等）</p>
</li>
<li>
<p>扁平化的目录层次（尽量使小蜘蛛跳转3次可以到达网站内任何一个内页，网站的设计主页、栏目、内容页，不要用纵线性的结构）</p>
</li>
</ul>
<p>看看下面的图片，从植物开始访问直到香蕉的话，就得走4步。这对于SEO小蜘蛛优化是不友好的。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/zhiwu1.png" alt="其一"></p>
<p>但是，如果同样的内容我们将目录层次做成下面这样，就会好很多！</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/zhiwu.png" alt="其二"></p>
<ul>
<li>
<p>导航SEO优化（头部、底部、内容部分，主导航、副导航、分类导航，尽量用文字。）</p>
</li>
<li>
<p><a href="http://baike.baidu.com/link?url=IxYqLFXaoyk0_JYfG_YlWWtRE5gxLpwX_sgiUqHiWB3XSCD1TK5wVtHKUvRkuKMSbrPGIUnrIX-agO8Kulp4dK" target="_blank" rel="external">面包屑导航</a>（在每个网页上留下面包屑，使用户可以了解网站组织形式，放于正文的左上方）</p>
</li>
<li>
<p>内容页面的布局细节</p>
</li>
</ul>
<p>比如说在底部的分页栏，下面三种就是依次增强优化的三种设计。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/enene.jpg" alt="如下"></p>
<ul>
<li>网站的加载速度会影响小蜘蛛的爬行，页面最好不要超过100k</li>
</ul>
<h4 id="网页代码优化">网页代码优化</h4>
<p>A、title标题：强调重点
B、meta keywords关键词：列举几个关键词
C、meta description网页描述：高度概括网页的内容
以上信息不要堆积、重复</p>
<p>语义化代码（HTML 标签有自己的意义，在适当的位置用适当的标签）
1、h1~h6 多用于标题
2、ul 多用于无序列表
3、ol 多用于有序列表
4、dl 用于定义数据列表
5、em、strong 表示强调</p>
<p><em>div、span 是 html 标签中最没有语义的！</em></p>
<p>有利搜索引擎</p>
<ol>
<li>a：访问外部链接时要加上 rel=“nofollow”，告诉搜索引擎外部链接无需追踪，加上 title 说明</li>
<li>h1：搜索引擎外认为 h1 最重要，使用 css 调整，网页正文标题用 h1，副标题用 h2，其他不要乱用 h 标签</li>
<li>br用于文本间的换行，用在p标签内，也可以在一对p标签中插入&lt; br/ &gt;表示空行</li>
<li>caption：表格标题</li>
<li>img：使用 title、alt 说明</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/hahap.png" alt="like this"></p>
<p>当网络速度很慢，或者图片地址失效的时候，就可以体现出alt属性的作用，他可以让用户在图片没有显示的时候知道这个图片的作用。</p>
<ol start="6">
<li>strong、em表示强调，em的权重仅次于strong,如果只想表示加粗斜体，建议使用b、i,表示强调则使用strong、i</li>
<li>重要内容 HTML 代码放在最前面（使用 css 改变布局）</li>
<li>重要内容不要用 JS 输出（<strong>搜索引擎看不懂 JS</strong>）</li>
<li>尽量少使用 iframe 框架（搜索引擎不喜欢）</li>
<li>谨慎使用 display:none（搜索引擎会过滤掉其内容，设置 z-index 代替）</li>
<li>尽量外链css和js，保证网页代码的整洁，也利于日后的维护。</li>
<li>css放在头部，js在尾部，可使用工具分别对其进行压缩！</li>
<li>为了减少http请求而使用<a href="http://baike.baidu.com/link?url=kS9KkFi_pOULzuJQTbml5w7SBkQJc30tJKO81OAO-U4E0x1EvS9zeo2fTLqrcd3Wk9YKt9SZZ9tWGTWRqwzz0a" target="_blank" rel="external">CSS Sprites</a>技术。</li>
</ol>
<p>就像下面这样</p>
<p><img src="http://p4.qhimg.com/t01dc2e2bb8a3ffd4ab.png" alt=""></p>
<p><img src="http://p3.qhimg.com/t01b0212a745da3af2e.png" alt=""></p>
<h3 id="再说几句">再说几句？</h3>
<p>好吧，再说几句！😮</p>
<h4 id="合理的title-description和keywords">合理的title、description和keywords</h4>
<p>对于SEO，一般从的宏观的角度来说，<code>SEO有三条最重要的规律---&gt;原创的内容、高质量的外部链接和持之以恒适度的优化</code>。</p>
<p>先看下面两张图:</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/google_douban.png" alt="豆瓣"></p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/google_360.png" alt="360"></p>
<p>合理的<code>title</code>、<code>description</code>和<code>keywords</code>。我们逐条来分析说明。。。</p>
<p>先说<code>title</code>，前者的风格可以说是清新脱俗简洁明了，网站就是豆瓣！后者针对关键字&quot;360&quot;做出了搜索，结果的<code>title</code>竟然有5个&quot;360&quot;！总结下：<em>一般情况下只强调重点即可，重要关键词出现不要超过3次，而且要靠前，每个页面title要有所不同</em>。</p>
<p>再说<code>description</code>，两者的差别又来了。豆瓣一句话说清楚了自己的things，360很有话说都tm没说完😓同样总结下<code>description</code>:<em>把网页内容高度概括到这里，长度要合理，不可过分堆砌关键词，每个页面description要有所不同</em>。</p>
<p>最后是简单提一下<code>keywords</code>,主要拿360说了，描述中出现了5次keywords！实际上<em>列举出几个重要关键词即可，也不可过分堆砌</em>。</p>
<h4 id="语义化书写html代码符合w3c标准">语义化书写HTML代码，符合W3C标准</h4>
<p>对于搜索引擎来说，最直接面对的就是网页HTML代码，如果代码写的语义化，搜索引擎就会很容易的读懂该网页要表达的意思。例如文本模块要有大标题，合理利用h1-h6，列表形式的代码使用ul或ol，重要的文字使用strong等等。总之就是要充分利用各种HTML标签完成他们本职的工作，当然要兼容Chrome、IE等主流浏览器。</p>
<p>看看著名的禅意花园网站（<a href="http://www.csszengarden.com/" target="_blank" rel="external">http://www.csszengarden.com/</a>），在没有样式的情况下，代码非常语义化，看起来很工整，加载不同的样式之后可以随心所欲的改变页面外观。</p>
<p>无样式时候:</p>
<p><img src="http://p3.qhimg.com/t01b092401c7e1db43f.png" alt=""></p>
<p>换个样式：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/ccc1.png" alt=""></p>
<p>再换个样式（33%的比例）：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/ccc.png" alt=""></p>
<h4 id="利用布局把重要内容html代码放在最前">利用布局，把重要内容HTML代码放在最前</h4>
<p>搜索引擎抓取HTML内容是从上到下，利用这一特点，可以让主要代码优先读取，广告等不重要代码放在下边。例如，在左栏和右栏的代码不变的情况下，只需改一下样式，利用float:left;和float:right;就可以随意让两栏在展现上位置互换，这样就可以保证重要代码在最前，让爬虫最先抓取。同样也适用于多栏的情况</p>
<p><img src="http://p4.qhimg.com/t015fe3481879a32091.jpg" alt=""></p>
<h3 id="写在最最后">写在最最后</h3>
<p>能力有限，不详细的地方不完美的地方还有许多。以后的日子还请多多关照233😬</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/faladi.jpg" alt="faladi"></p>
<blockquote class="blockquote-center"><p>1831.09.23 法拉第发明发电机。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 杂谈 </tag>
            
            <tag> SEO </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[三位班主任，几个熊孩子]]></title>
      <url>http://zrdsj.cc/2016/09/10/old-faces/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>献给曾经我爱过的几个人，，，，，，，，，，三位班主任几个熊孩子。😄</p>
</blockquote>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=18127640&auto=0&height=66"></iframe>
<p>久违的节日，教师节。</p>
<p>“啊，好久不见”</p>
<p>“不是也一年么，至于么？”</p>
<pre><code>maybe现在不至于，以后就没机会了。。。
</code></pre>
<h3 id="一如既往地sao下去">一如既往地sao下去</h3>
<p>应该是北京奥运会前的那个学期，不！是学年。那一年发生了许多事情，其中有几个熊孩子在那一年认识了。和地球上许多角落发生的故事一样，他们也没啥惊奇的地方。在外人眼中，太平常了。</p>
<p>应该说，对于其中的一部分人，包括我，这群人的存在在八年后的2016看来，注定是记忆中抹不去的一片色彩。</p>
<p>当年sao的不可救药的孩子们，如今都是走向学业尽头的老年轻了。南方，家乡，魔都，闽南，都有过你们的影子，不会抒情，也没啥通气的话语，有的话算是有个小愿望。。。“希望在这一天，你也想起你曾经的恩师和伴你成长的熊孩子们”</p>
<blockquote>
<p>人是感情动物，而且很怕动了情。</p>
</blockquote>
<p>不管现在过得如不如意，我总会想到过去。过去有很长一段时间，都觉得这是毛病。事实上，在确认自己的嬉皮梦想与分裂人格之前，内心也是默认了一个事实—“自己作为复杂情感载体（人？）的话，并不具备一般大众的特性（至少长时间肯定不具备）”</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/saozhu.gif" alt="骚猪"></p>
<p>我若是外人，了解自己的情况下，会不会喜欢上自己？</p>
<p>对我来说，上面那个问题还是蛮有意义的。平平常常的自我认可，若是不被自己讨厌，都会让自己倍感温暖，，，这样的情况发生在一个喜欢黑色幽默+轻度精分+轻度斯德哥尔摩的人身上，，，本身也算是顶级黑色幽默了吧2333😂</p>
<blockquote class="blockquote-center"><p>sao下去，不计代价！hahaha，你们也是哦</p>
</blockquote>
<h3 id="几位班主任">几位班主任</h3>
<p>扯完了熊孩子，今天也是想到了几位老师。是我曾经的几位班主任，一样是我过去22年里值得留恋的魅力光景。</p>
<p>一个原则：因为鄙人不会抒情不会叙事更不会讲故事。。。so，<code>这里基本上只搬事实</code>。</p>
<h4 id="zsh老师">Zsh老师</h4>
<p>身量苗条、体格风骚的少妇老师，我小学中有四年的光景拜此班主任所赐。</p>
<p><code>爱一年恨两年最后又爱一年</code>，就是这样。在张老师保佑的这四年里，健康成长得到了光大&amp;发扬。</p>
<p>在那些年里，我已经见识了与“人之初性本善”很相悖的画面，不必说拖鞋背心口哨，也不必说揪头发掏jj挠脸，单是男厕所的墙上的“武林风”几个大字，就算是宣告了吧。。。宣告了汝阳男儿的气魄与胆识。😒:</p>
<p>上面所描述的画面中叱咤风云的几个扛把子的，后来的生活我不得而知，但听说了，，，听说都洗白了！</p>
<blockquote>
<p>？？？</p>
</blockquote>
<p>和我一样白的时候，他们还没变黑，后来不见他们的日子我也懒得去知道发生了什么。‘洗白’听上去仿佛是一段段的故事，而不是个人生历程。</p>
<p>张老师也许没有教会我很多，但我知道，是因为我太小了233.</p>
<p>最近的一次见面，是去年的暑假，一个人走过县城防洪渠的过道上（那里也是老师家）。一干人在老师家们口说笑。我，又看到了十年的故人，hh，除了嘴唇的淡粉色口红替代了十年前的大红口红，似乎就只剩我的变化了。。。</p>
<p>四目相觑，大眼瞪小眼。我都屏住呼吸了，tm的像是在演戏？</p>
<p>哦，她看起来好像不记得我了。我的脸型圆圆的还是没变，却也没什么卵用。last,我走过路口，嘴角微扬，忍不住回了下头，，，</p>
<h4 id="zlr老师">Zlr老师</h4>
<p>初三，八年前的生活。奥运会结束后的那个学年，那一学年还有件事情，火箭打进了西部半决赛和湖人拼到了抢七2333.我无意搞什么大事情，😂老提奥运会这锅我背了233.</p>
<p>赵老师，最初记得的印象是听说的。。。只记得大家程其为“NB班主任”。语数英三门学科的问题都可以指导，作为班主任出色的带班成绩，中青年女教师特有的和蔼，，，可以了，这确实很NB!</p>
<p>这位似乎看透了我的心，一开始就是。整整一年对我都是爱理不理爱管不管的，我的成绩出现过明显的变化而且一度在班里我是成绩考前的人群中唯一一个座位在最后的（最后座位的孩子们也都很帅，但不是在学业上）？</p>
<p>影不影响只有自己知道。赵老师掌控下的那个班级，那一年，对我学习方法和性格的影响—shi 深远 de.</p>
<pre><code>评价好坏这件事从来都带了情感，灵魂的权衡中，失败成功也许都是一样的
</code></pre>
<p>日后我明白了这个道理，也因此我尤为怀念赵老师，还有那一年的时光。为何她能看透我的心？呵呵，还不是被自己人给卖了，是吧@妈。</p>
<h4 id="zkf老师">Zkf老师</h4>
<p>基基基基哈哈哈哈</p>
<p>终于是个男的了！这位对我影响最大的老师，高中教了我三年的物理，当了一年半的班主任。。。所能提及的事情太多，不说了。</p>
<blockquote class="blockquote-center"><p><code>江东儿郎多才俊,闻君入吴夜不啼</code></p>
</blockquote>
<p>​<br>
<img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/zhangliao.png" alt="zkf"></p>
<p>不知道怎么结尾了，特别想对老师说一声：“莫愁前路无知己”。。。哎:happy:</p>
<p>好了，说了了。</p>
<blockquote class="blockquote-center"><p>L</p>
<p>A</p>
<p>S</p>
<p>T</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/zuisaode.jpg" alt="memeda"></p>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 回忆 </tag>
            
            <tag> 黑色幽默 </tag>
            
            <tag> sunshine </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[吆喝几句Thomas Hobbes托马斯·霍布斯]]></title>
      <url>http://zrdsj.cc/2016/08/29/Thomas-hobbes/</url>
      <content type="html"><![CDATA[<p>这是2016八月的最后一篇博客了，算是想来宣传一个人的，这个人我接下来统称为’老霍’。</p>
<a id="more"></a>
<p>最初的标题我说的有点大：<code>《普及Thomas Hobbes》</code>，真是不知天高地厚233.讲道理知道老霍的人自然知道，不知道的人就是说破了天效果也是对牛弹琴。😄</p>
<h3 id="老霍生平">老霍生平</h3>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/th.jpg" alt="托马斯·霍布斯"></p>
<p>托马斯·霍布斯（Thomas Hobbes,1588.4.5-1679.12.4）,英国政治家，哲学家。英语世界产出的最为深刻和系统的思想家之一，经典契约理论奠基人，政治哲学方法论转型的界碑，恐惧政治学的发端，近代国际关系的理论渊源…总之可以总结说老霍就是政治哲学界的牛顿。</p>
<p>老霍终其一生干过下面几件事情：</p>
<ul>
<li>写了一些著作（搞得自己无处安顿却）</li>
<li>提出了一些想法（得尊称：现代政治哲学创始人）</li>
<li>干过贵族家教（得益于此游历欧洲）</li>
<li>翻译过希腊古籍（翻译希腊文为英文的第一人）</li>
</ul>
<p>哈哈，无论怎样看上去都好厉害的一个人。事实上也确实如此，现代让全世界头疼的全球化问题，老霍在400年前的17世纪就开始研究相关现象了，其贡献的价值可见一斑。</p>
<h3 id="我到底想xie什么">我到底想xie什么</h3>
<p>我在自己的博客中写过，自己是有个基督徒的身份的。在信仰主耶稣的道路上，我有所了解到老霍这个人。老霍对于基督教，没什么可说的，至少在我鄙陋的学识中，我说不上什么。</p>
<p>之所以会写篇宣传介绍老霍的博客，我想了想算是我的难言之隐。在最后，我会表明我的态度，立上flag!:flag:</p>
<h3 id="老霍最重要的书">老霍最重要的书</h3>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/liweitan.jpg" alt="利维坦封面卷头插画"></p>
<p>上面这幅图是老霍一生集大成之作—<code>《利维坦》</code>的封面卷头插画。</p>
<p>作为后人，而且所涉领域并不是政治哲学。因此十分畏惧，不仅仅是主观性的不确定，更进一步是由于对其人其书其时空背景的&quot;深度无知&quot;。我到写这博客时候，其实一句都没看过，我是努力以客观为准则找到评述此书的论述，并给予展示。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/haiguai.jpg" alt=""></p>
<p>过去，说到利维坦，往往先从西方神话开始，这个名词被用于神话中从裂缝里蹦出来的海怪。</p>
<p>它象征着“邪恶”，同时又被冠以“嫉妒”，与这个被期待以“真善美”的世界格格不入。</p>
<p>在老霍的书中，利维坦成了一个强势国家的名字，他把这个国家比作是人工造的人。</p>
<blockquote class="blockquote-center"><p>“主权是它的灵魂，官员是它的关节，财富是它的实力，安全是它的事业，公平法律是它的理智，和平是它的健康，动乱是它的疾病，而内战，是它的死亡。”</p>
</blockquote>
<p>如是说，利维坦这三个字已经逐渐曲并于亚文化。</p>
<p>此书有三个部分—&gt;是论人、论国家、、论基督教国家与黑暗王国。简单总结为下面的几种形式。</p>
<ul>
<li>论人是说人生活在自然状态下，人会为了个人利益会必然会挑起争斗，霍布斯提出了建立国的观点。</li>
<li>论国家，在人人都愿意遵守的前提下签订合约建立成国家，让人人遵守合约和平生活。</li>
<li>论基督教国家与黑暗王国就是我们要信仰什么？霍布斯说假如有一个人对他说，上帝以超自然的方式直接传授给他，而又让我感到怀疑这样我就特难相信他提出的论据的存在性，再者说他是我的管理者，他就可以强行让我服从，我只能从之，没办反驳。总得来说霍布斯是想宣传国家的权力，和统一的管理，让人更好的生存。</li>
</ul>
<p>《利维坦》中老霍的十九条自然法原则，完全符合我们今天的普世价值《国际公民权利公约》，自由、平等、博爱什么都有。</p>
<h3 id="老霍的思想及其影响">老霍的思想及其影响</h3>
<h4 id="思想">思想</h4>
<p>老霍的思想基本上可以分为哲学和政治。</p>
<blockquote>
<p>其哲学主张又分为自然哲学、偶性哲学。自然哲学其意思就是老霍指出就是某个东西，是由于它的广袤，所以把它叫做物体，它的存在并不是依赖我们的思想而生存，所以说这个物体它是独立存在的。</p>
<blockquote>
<p>老霍的物体的解说充分的突出了数学和力学的发展成效，老霍完全的呈现机械唯物主义。偶性哲学，老霍提出偶性就是存在物体是不被看到的物体，它的存在于某个物体中，不能因为你的看不到就说他不存在。老霍通过用机械的方式把人的存在，也看作是自然的物体，人不过有自己的思想、意识，但是人也得遵从自身的生存规律。</p>
</blockquote>
</blockquote>
<blockquote>
<p>政治思想的主张就是老霍主要提倡的是国家要订立的制度，老霍通过他的假设自然状态的情况进行过的分析，从而引出的人们想要和谐的生活就要走出自然生存的状态。</p>
<blockquote>
<p>老霍的政治思想他主要张契约论，就是说人要促成国家的主要因素就是，每个人都是国家的一部分，要想人人相互平等，就要签订合约，并推选出主宰者来掌控，从而形成国家。但前提是主宰者也要公平公正的对待每个人每个事情，否则就失去了走出自然状态的初衷，所以老霍的思想主张主要的意思是老霍讲述生存之道，让人能够产生的仁爱之心。</p>
</blockquote>
</blockquote>
<h4 id="影响">影响</h4>
<p>老霍是西方国家的政治思想家，他的思想论在当时他生存的时代受到欢迎不太理想，得到很多人的大力反对。他阐述的自然思想，被人们误会他维护专权主张，其实他的思想是为了人都能够自然规律下安然生活，他在理性的解说自然状态。</p>
<p>老霍思想影响了后世许多伟大政治学家思想家。其中也有人坚定的推崇老霍的思想。老霍生活在社会转型的时代，这个时代无论经济、生活等多方面都有了突飞的进步人类的思想也在改变，人的部分权力得到了尊重，宗教信仰也深入了人类的生活。</p>
<p>老霍的自然状态思想也被人们慢慢接受，他的思想在影响着现在在生存的人们，他们要想生存就必须约束自然权力，不然就会不得安宁，自然的原则就是寻求自然的和平，老霍思想强调的提出人们就该放下部分的权力，来接受所谓的约束。在这一时期老霍的思想完全得到了释放，他影响了这一代人，他们开始学习老霍坚持的从自然状态走出来，建立国家，自愿放弃部分自然权力，接受国家制度的约束，签订契约并遵守它，体现了公共的意义。</p>
<p>直至如今老霍思想的影响具有理论价值的重要性，老霍思想为如今法律研究做出了贡献。还未我们有了很好的探讨话题，老霍思想的影响已经不在是他一人的思想而是属于每个法律遵循着的思想。</p>
<h3 id="写在最后">写在最后</h3>
<p>关于老霍这个无神论者，我是在两个月前才知道这个人，如今只是一心的佩服而已！没办法，生命中总有些时刻想去关心政治关心是非，so…通过对老霍的些许了解，结合作为基督徒的内在自我认可，，，我来说些自己的感受。</p>
<blockquote>
<p>基督教的伦理世界都是善恶分明，黑白分明？</p>
</blockquote>
<blockquote>
<p>恐怕是也不是</p>
</blockquote>
<p>基督教的善恶是以神为中心的，凡蒙神喜悦的都是善，反之是恶。神只有一个，因此善恶公义标准唯一，清晰，永恒。世俗的善恶，因为人有无数且死生相继代代无穷，善恶标准无数无数，且死生相继代代无穷，善恶标准无数、混乱和漂浮不定。</p>
<p>即使是按世俗标准，爱是人类独有的最高级的精神活动。如果猴子之间有和人类相同的爱，那么猴子显然是比人类更高级的物种，比如他们不破坏地球。</p>
<p><a href="http://baike.baidu.com/link?url=LL49YSFlyqPCzufjU5iS8HQmyoTBVxBE_EH9LH09m1ohsF0SUEbRK6EOaSSDgnTZ_hhkn-1zBw1sfYWr_Bc7Xn9aVtsCa0xyivZxEIKNm5C8_50WEKoIOuL1zQ3i7NmdhawXDQkOe69YfNnSg6dOpxKWpHuV3bBdS8ZoO2V7b2q" target="_blank" rel="external">洛克</a>说了，无神论者不可能真正理解平等，老霍也从自然状态和自然法出发，雄辩地证明了一群自由主义猴子，只配得到一个利维坦。</p>
<p>四百年了，真的，某国的无神论者。。。述鄙人直言，都是辣鸡。</p>
<p>研究与信仰在哪里？23333</p>
<blockquote class="blockquote-center"><p>出于对死亡的恐惧，对肉身的迷恋，对永生的渴望，人天然是宗教的动物。即使在最愚昧卑微的群体，或者泛无神论群体，都会遏制不住与比人更高的力量或存在合一的渴望。前者诉诸祭祀、巫术或图腾崇拜，后者则试图投身创造历史的伟大功业或惊世骇俗的举动，在历史的黑洞中留下痕迹，在肉身速朽之后，以精神或名声与世界保持联系。</p>
<p>在最实际最庸俗的层面，广义的宗教为人在彻底无能为力的死亡面前，提供了永生的选项，是一生中最豪华的赌博。</p>
<p>我们为了日常的小赌局殚精竭虑，为什么却会对一生中最大的赌博无所用心呢？</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基督教 </tag>
            
            <tag> 人生 </tag>
            
            <tag> 政治 </tag>
            
            <tag> 文化掰扯 </tag>
            
            <tag> 霍布斯 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的-编译原理-de故事]]></title>
      <url>http://zrdsj.cc/2016/08/29/Compile-principle-story/</url>
      <content type="html"><![CDATA[<p>这是篇发表在0829的文章，今天是0915.半个多月了</p>
<p>昨天是九月十三日，结束了自己的‘编译原理’补考。这是大学我的最后的考试了，编译原理。</p>
<a id="more"></a>
<p>这篇文章的几个标签，看上去似乎是有故事的。正如博大精深的计算机，其发展历史中离不开编译原理这学科（其实我更愿意将之称为科学）一样。。。我的学业进展过程中遇到了编译原理，也颇有了一番渊源。</p>
<h3 id="that-winter">that winter</h3>
<p>2015结束2016就来了，北方这时间自然是冬天。紧接着的一个学期是大三的下学期，我很难受。</p>
<p>因为大学的大多数同学都出去实训了，我决定留在学校还不想出去。出的人多了，自然会有爱的人。</p>
<p>所以难受。</p>
<p>在这个难受的学期中，编译原理到来了。原以为是一门有意思的学科，可以知道很多理论很多学识。然而事实不遂人愿，一切活动充满了无聊，瞌睡还都堕落。</p>
<p>回忆到这里，足够了。再写的话自然啰嗦了更无意义了。</p>
<p>我想说关于自己的故事，也就从此处引进来了。</p>
<h3 id="why-why-why">why why why</h3>
<p>人活着，做事情，到了我这个阶段，即使好多事情还会出问题。也不要再找借口寻理由了，脸上挂不住自然难堪so可以嘴硬，但是不要总是找借口寻理由了。</p>
<p>从上个章节你们知道了，在无聊瞌睡堕落中，我终于化身智障，挂掉了《编译原理》。我无奈，但是自己在睡觉时候确实没想过往后的日子，挂科倒也是不负我心了。</p>
<blockquote class="blockquote-center"><p>why why why</p>
</blockquote>
<p>主要问的是在复习时候发生的事情，在过去的半个月吧。都是这样的事情。</p>
<p>“这一章讲的什么啊？”</p>
<p>“这一道例题什么情况啊？”</p>
<p>“这个是不是重点？”</p>
<p>也许你觉得我没那么糟糕,然而，就有那么糟糕。。。第一次考试几乎是会的题型答在哪儿都不知道233😂</p>
<p>见笑了。我称之为自己的<code>智障人生</code>。</p>
<blockquote>
<p>不去学，不好好学，等死。
死了之后才知道得搞清楚。</p>
</blockquote>
<p>名副其实，没问题！</p>
<h3 id="夕阳下的综合楼">夕阳下的综合楼</h3>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/0914heda.JPG" alt="beauty"></p>
<p>先来说说谶语的事情。看下面的截图先</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/667830.jpg" alt="mdzz"></p>
<p>考试时间是6月25日的话，这句话应该是怎么理解？</p>
<p>一种耀武扬威的mdzz？还是发自内心的mdzz？</p>
<p>2333</p>
<p>反正都一样，mdzz。一语成谶，挂了科没通过考试。其他的学科，或多或少都是有难度的，但我都挺过来了，这一门偏偏整个这出。</p>
<blockquote>
<p>怀疑奇怪的事情久了，自己也会变得很奇怪。</p>
</blockquote>
<p>我觉得自己差不多就是这样，神经兮兮的。过去的半个月，各种博客，书上的每个章节，每道课后题，我都遍复一遍的复盘着。如今这段<code>往事</code>，已经过去。</p>
<p>我想，失意的日子带给我的不仅仅是失意，更是怀恋美好的感觉。说深了是“斯德哥尔摩综合征”，说简单了，这就是生活吧。。。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=116337&auto=0&height=66"></iframe>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 智障人生 </tag>
            
            <tag> 回忆 </tag>
            
            <tag> 谶语少bb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[几点物联网及量子计算的感想]]></title>
      <url>http://zrdsj.cc/2016/08/25/Internet-of-Things-and-Quantum-Computing/</url>
      <content type="html"><![CDATA[<p>说两个不算是新鲜的新鲜thing.</p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=25657229&auto=0&height=66">
</iframe>
<h3 id="物联网">物联网</h3>
<p>物联网<code>The Internet of Things</code>—我先列举几个问题，来引出接下来的讨论或者是陈述。</p>
<p><img src="https://raw.githubusercontent.com/phodal/designiot-images/master/chapter1/devices-iot.jpg" alt="enter description here"></p>
<blockquote class="blockquote-center"><p>物联网是什么？物联网什么用？听上去和互联网还蛮像的，是不是另一种互联网？物联网的发展大概是怎么的过程？现在到了什么阶段？…</p>
</blockquote>
<p>我在键盘敲下这些问题的时候，也是又一遍问了问自己。其实啊，如不借助外力，我也是说不太清楚这些问题。上面那些问题，不会一一详细解答讲述。</p>
<p>两个原因</p>
<blockquote>
<p>1能看到我这博客的人水平都是ok的这都很清楚不用我说</p>
<blockquote>
<p>2问题是很简单的问题可以去百度谷歌一波，你会得到更多</p>
</blockquote>
</blockquote>
<p>不会详细说，简单说还是要的。。。</p>
<h4 id="物联网的核心">物联网的核心</h4>
<p>说这个其实我觉得很有必要，及时你对物联网一无所知，但maybe你看完了这一节，你就会发现身边的许多事物都可以在物联网的范畴内考虑！</p>
<p>顾名思义讲，物联网<code>Internet of Things</code>即世间万物的互联网，是物物相连的互联网。这里有两层意思：第一，物联网是建立在互联网上的，在一定程度上物联网是互联网的拓展和延伸；第二，在物联网的用户端（末端）延伸到了物品与物品之间，进行信息通信和交换。</p>
<p>基本上，本质核心已经被我说出来了，，，，互联网！？</p>
<p>是的，核心和互联网有关，准确地讲，是<strong>网络</strong>。</p>
<p>物联网不是一个几个thing,而是一个系统。系统内几乎包括了所有与网络相关的thing！照我这样说的话，物联网的概念拓展的方面已经包括了我们生活的方方面面？</p>
<p><strong>是的</strong>😋</p>
<h4 id="物联网这么大">物联网这么大？</h4>
<p>上一小节说了，网络应该是物联网的核心本质。然后呢，这一小节提供一些场景供你去巩固物联网的概念。</p>
<ul>
<li>
<p>场景1：基于<a href="http://baike.baidu.com/subview/531097/13865303.htm#16" target="_blank" rel="external">RFID</a>的物联网应用架构</p>
<p>在这个场景中，一些看上去风马牛不相及的技术得到了延伸，比如穿孔卡，键盘，条码等。电子标签（RFID）是最能把“物”改变成为智能物件的，其主要用途是将移动和非移动的资产贴上标签以便于跟踪管理使用等。再提供两个物联网框架下的关键技术:<a href="http://baike.baidu.com/subview/81070/5047843.htm#viewPageContent" target="_blank" rel="external">ONS|对象名解析服务</a>和<a href="http://baike.baidu.com/view/1250450.htm" target="_blank" rel="external">PML|物理标示语言</a>。</p>
<p>这个框架下的具体场景，最常见的我说一个吧。你住的小区你进入的商场停车场都会有<a href="http://baike.baidu.com/view/163885.htm" target="_blank" rel="external">门禁系统</a>。其应用射频识别技术，可以实现持有效电子标签的车不停车，方便通行又节约时间，提高路口的通行效率，更重要的是可以对小区或停车场的车辆出入进行实时的监控，准确验证出人车辆和车主身份，维护区域治安，使小区或停车场的安防管理更加人性化、信息化、智能化、高效化。</p>
</li>
<li>
<p>基于传感器的物联网应用架构</p>
<p>当我们谈论传感网络的时候，一般主要是指无线传感网络（<a href="http://baike.baidu.com/item/%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C/3794?" target="_blank" rel="external">WSN</a>, Wireless Sensor Networks），此外还有视觉传感网（VSN, Visual Sensor Networks）以及人体传感网（BSN， Body Sensor Networks）等其他传感网，这里我们也主要讨论WSN。
　　
就是传感器获得数据，通过网络将数据传递到程序当中，于是各种通过科技驱动的变化（行为）开始发生。最后，物联 网改变了我们的生活。</p>
<p>国外的IBM，微软在十多年前都开始了WSN的研究，成果肯定有但是在商业领域可以说是收效甚微。目前大企业已经不是做纯WSN的研究。目前存在的矛盾是：企业能赚钱的WSN技术对研究人员来说太简单，算不上成果，而研究机构做的东西离实用差距又太远。</p>
<p>WSN的研究大多还专注于网络底层（包括非IP协议的ZigBee、TinyOS和基于IP的6LoWPAN等），以及电源的持久性等问题，按照其目前的发展，WSN离真正的“物联网”还很有一定距离，对像上一小节中提及的中ONS和PML等物联网层面的问题研究还不够。</p>
<p>相关领域的一些声音表示，WSN的研究者太热衷于无线技术，忽略了感知层用有线现场总线和传输层用长距离无线通信的组合。从实用和商业推广的角度，这个组合早已经达到稳定和大规模应用的水平。</p>
</li>
<li>
<p>基于M2M的物联网应用架构</p>
<p>业界认同的<a href="http://baike.baidu.com/view/2230180.htm" target="_blank" rel="external">M2M</a>理念和技术架构覆盖的范围应该是最广泛的，包含了<a href="http://baike.baidu.com/view/5865205.htm" target="_blank" rel="external">EPCglobal</a>(本节第一小节的内容)和WSN的部分内容，也覆盖了有线和无线两种通信方式。</p>
<p>哈哈，这并不是新技术。只是在物联网的发展中引入了新的<code>通信方式</code>。M2M的发展缺乏ONS和PML那样的“物联网”标准规范和统一体系架构，虽然有一些像<a href="http://baike.baidu.com/view/4782261.htm" target="_blank" rel="external">oBIX</a>、BITXML、oMIX那样的尝试，但像ONS和PML那样的统一的规范还未形成，还有很长的路要走。</p>
</li>
</ul>
<h4 id="thinking">thinking</h4>
<p>先来扯个淡，讲个故事：</p>
<blockquote>
<p>感冒，你最开始只是喝点热水，两三天就好了。后来你开始吃青霉素，发现一天就好了。再后来你开始吃头孢N代，再再后来，试遍了热水、青霉素、头孢都没有好的效果，你开始吊水打针…可能再再再后来，逼不得已，你跑去中医院，找个老爷子，摸半天，眼睛一闭胡子一吹，开了所谓的麻黄汤或者桂枝汤，回家咕嘟咕嘟，喝药的时候心里想着：妈的，最恨的一招，老子用上了，再不行，就没招儿了！</p>
</blockquote>
<blockquote>
<p>结果喝了半个月，感冒好了，你还在自我安慰：还是祖国医学神奇啊！</p>
</blockquote>
<blockquote>
<p>瞎折腾啥？</p>
</blockquote>
<blockquote>
<p>仔细想想：究竟是什么让我们去追求所谓的疗效？</p>
</blockquote>
<p>over</p>
<p>最后留了个问题，答案是有的。但我更希望你看完自己去想想，在心里告诉自己一些事情。一些难以言传的事情。</p>
<p>科技的发展，在我的眼里。和下面这动画中的主题是一样的：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/zhxdj.jpg" alt="中华小当家"></p>
<blockquote class="blockquote-center"><p>料理是给人们带来幸福的东西</p>
</blockquote>
<p>过去我们写信传书去寄托相思，融融深情-自然是我们身为情感动物的傲娇。如今呢？键盘屏幕前的我们是不是偶尔也会怅然若失呢？</p>
<p>物联网在一些方面代替着互联网，几乎是强行的进入了我们的生活，我们别无选择。因为可以出现的’美好愿景’，几乎在梦里才会发生，至少仅是因此到了现实里我们就无法拒绝，更不用提生产力与经济背后的复杂事情了。233</p>
<p>无论如何，人们花费时间研究科技去改变生活是应该的的，个人觉得没什么可反驳的。问题是，这个过程催生的诸多结果中，我们真的幸福了？我们真的拉近了与别人的距离并且生活得更有诗意更高质量？</p>
<p>杞人忧天？一语成谶？2333付诸一笑了😄</p>
<h3 id="量子计算">量子计算</h3>
<p>八月的上中旬有几则新闻让我着实感到焦急？哈哈哈，说烦躁也许更准确点。。。是这样的几则新闻:</p>
<p>我找具有代表性的两条列举下：<a href="http://mil.news.sina.com.cn/2016-08-19/doc-ifxvcsrn8676691.shtml" target="_blank" rel="external">其一</a>、<a href="http://news.sciencenet.cn/htmlnews/2016/8/354147.shtm" target="_blank" rel="external">其二</a>。</p>
<p>我先不说那几=些天所出现新闻的真假与意义，单单说字面的文字意思。意思大概是说：<code>中国的量子计算研究取得了一些突破，这些突破在中国官方的眼里是巨大的，然后全球量子计算的实力或许就要重新洗牌了</code>。看上去然人有一种很珍惜身边人的感觉！</p>
<h4 id="量子计算基本的一些changshi">量子计算基本的一些’changshi’</h4>
<p>讲道理在一年前，我还没怎么听过量子计算。当时《计算机网络》课程的小组任务是做PPT及演讲，其中某小组的主题提到了<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B" target="_blank" rel="external">摩尔定律</a>，进而在演讲中以及互动中老师也提到了摩尔定律当前的一些处境以及一些新的科技探索方面，其中就有<a href="http://baike.baidu.com/view/689634.htm" target="_blank" rel="external">量子计算</a>。</p>
<p>我在这里简单的提及一些量子计算的知识，班门弄斧全做抛砖引玉了。2333</p>
<p>在摩尔定律大行其道的年代里，量子计算的理论就出现了。上世纪的七十年代，计算机科学领域的几位科学家就开始了“<code>基于量子力学的计算设备</code>”的研究，随后的十多年里先关的概念以及论文被几位先先驱发表。为何会想到研究量子计算？</p>
<p>传统硅芯片的性能在那个年代确实不强劲，而且硅芯片及其先关的技术是有可预见的极限的。时间走到尽头硅芯片的极限就到了，并不是空穴来风！</p>
<p>因此当时的科学家将眼光转向了其他的可结合的领域中，包括量子计算机在内，<a href="http://baike.baidu.com/view/18639.htm" target="_blank" rel="external">生物计算机</a>、<a href="http://baike.baidu.com/view/381305.htm" target="_blank" rel="external">光计算机</a>都是早早在那个年代获得了青睐。终究因为其他的原因，如今看来量子计算机的前景最为光明。</p>
<p>量子具有常人难以理解的特性，5000个量子位的量子计算机30s内解决的<a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3#.E9.9B.A3.E5.BA.A6.E8.88.87.E8.A4.87.E9.9B.9C.E5.BA.A6" target="_blank" rel="external">素因数分解问题</a>，传统的硅芯片超级计算机要几十亿年才能解决。量子计算机利用了原子具有的量子特性进行信息处理。原子会旋转，而且规律不是向上就是向下，正好和计算机数位科技中的二进制0、1完全吻合。</p>
<p>如果把一群原子聚在一起，它们不会像现在的计算机一样进行线性运算，而是会同时惊醒所有可能的计算。其性能，40个原子一起计算就相当于一部超计算机。利用处于<a href="https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E6%85%8B" target="_blank" rel="external">量子态</a>的原子做CPU以及内存，其运算性能比目前的硅电路传统计算机快上亿倍。</p>
<p>本节完。推荐阅读：<a href="https://www.zhihu.com/question/26933442" target="_blank" rel="external">11111111111</a>.</p>
<h4 id="直接上感想">直接上感想</h4>
<p>哈哈哈，我不是这个领域的。即使是在我自己的FE开发领域，都还是个新人。因此呢，即便可以找到一些看上去让人不明觉厉的资料站点并po出来显得别样傲娇。。。我也是不会那么做的。</p>
<p>本篇博客的标题写了了，是几点感想，不是科普类的！</p>
<p>回到最初我说到了八月初的看到的那些新闻，中国人常常喜欢一个说法：流言止于智者。</p>
<blockquote>
<p>因此，我见了太多的微博微信在呼吁一些所谓的正能量！不轻信不传播不造谣。。。</p>
</blockquote>
<p>我此刻已经是满脸笑容了。</p>
<p>权力与体制本身即为社会最大负能量，而以最大负能量之身倡导社会正能量，实为顶级黑色幽默。！</p>
<p>即使所倡导的确属正能量，那也不过是有利于自身的选择性正能量。以倡导表象性的正能量来掩盖自身根源性的最大负能量，而占领道德制高，僭越正能量以俨然成为正能量的化身，与“扬小善隐大恶，则自塑为善”如出一辙。</p>
<p>很久都看不到真正的新闻了，也是不敢想象诸多流言最后怎么样了。。。233。。。成也好，坏也罢。我是觉得，科学这一块儿，比如说量子计算出现的这些新闻来说，不能装逼！步子大了肯定扯着蛋。。。</p>
<p>轻则打脸，重则💊。</p>
<blockquote class="blockquote-center"><p>流言不是止于智者，而是止于真相！永生的选项提供了善良，默然于眼前的丑陋无动于衷好过助纣为虐，然后呢？</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/heihei.jpg" alt="hhh"></p>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> 物联网 </tag>
            
            <tag> 量子计算 </tag>
            
            <tag> 黑色幽默 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Blog--Hexo_NexT搭建遇到的troubles]]></title>
      <url>http://zrdsj.cc/2016/08/21/Blog-troubles/</url>
      <content type="html"><![CDATA[<p>来分享一些搭建博客时候发生的故事吧.！</p>
<a id="more"></a>
<h3 id="谈点技术">谈点技术？！</h3>
<p>看起来是要谈一些技术？😆然而只是说一些pi大点儿的<code>小儿科</code>。。。若你是想要得到完整的<code>Hexo_NexT</code>博客搭建讲解，亦或是想知道怎么安装及使用Git，Node.js…请移步相关的官方网站去查看说明，或者去到专业教学博客的介绍页。</p>
<p>过去的六七天，在每天不那么忙的时候，在<a href="https://github.com/" target="_blank" rel="external">github</a>上，利用<a href="https://pages.github.com/" target="_blank" rel="external">github pages</a>和自己5个月前🙉脑抽🙉买的域名。。。在自己pc的某个盘上搭建了博客网站，使用了博客框架<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a>及其相应主题<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT</a>。然后通过<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">git</a>以及网站<a href="https://github.com/" target="_blank" rel="external">github</a>,完成了本地博客及其网站部署。</p>
<p>就像现在，你看见这博客的时候，其实是在我的博客网站<a href="http://zrdsj.cc">http://zrdsj.cc</a>上，看着我的第四篇博客😂。</p>
<hr>
<h3 id="用到的工具">用到的工具</h3>
<p>本节最后我提到一些<code>工具</code>，其实说起来的话，还应该提到<code>材料</code>。</p>
<p>⬆️个🌰‘说明一下——我有食材、调料，又有火、锅、碗、筷。。。才可能做出熟了能吃的东西。</p>
<p>这里搭建博客需要的软件，网站，环境可以说是<code>工具</code>了，其中有些可以称之为<code>材料</code>的这里就不再专门说明了。</p>
<p>动手做过这类事情的话，是很好理解的；没做过不理解也是没有关系，因为理不理解也就仅仅说明你意识会好一些，跟你自己动手搭建博客成功与否没关系。</p>
<p>本节的最后来了，说<code>工具</code>了：</p>
<table>
<thead>
<tr>
<th>pc</th>
<th>net</th>
<th>web site</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://nodejs.cn/" target="_blank" rel="external">Node.js</a></td>
<td>可以连接<a href="https://github.com/" target="_blank" rel="external">Github</a></td>
<td><a href="https://github.com/" target="_blank" rel="external">Github</a>账号</td>
</tr>
<tr>
<td><a href="https://git-scm.com/" target="_blank" rel="external">Git</a></td>
<td>使用node install时有反应的npm镜像</td>
<td>Baidu账号</td>
</tr>
<tr>
<td><a href="https://desktop.github.com/" target="_blank" rel="external">GitHub Desktop</a>*</td>
<td>必要时可fq</td>
<td><a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>账号*</td>
</tr>
<tr>
<td>给力的浏览器</td>
<td>你自己的域名</td>
<td><a href="https://www.google.com" target="_blank" rel="external">Google</a>账号*</td>
</tr>
<tr>
<td>给力的编辑器</td>
<td>~~~</td>
<td>~~~</td>
</tr>
</tbody>
</table>
<p><code>带*的表示可有可无</code></p>
<p>有这些<code>工具</code>就可以实现全部的从0-100%功能的博客部署，鄙人几天<code>（也是tn的够笨）</code>的摸索下来总结了这些。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/mldke01.jpg" alt="555"></p>
<hr>
<h3 id="troubles-list">troubles list</h3>
<p>前面说了过去几天干了什么，用什么干。网上的hexo博客搭建教程，如果不是专门针对某n项问题做解答做讲述的话（n一般取3、4、5、2、1），就一定会变成如下两个地方的剪切粘贴。</p>
<ul>
<li>pos1:<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a></li>
<li>pos2(不同主题也有不同):<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT</a></li>
</ul>
<p>最后那些到处粘贴的教程也许能解决你的问题，<code>因为你看了许多篇几乎一样的教程花费了数十分钟迷茫着急之余，，，突然的！你自己就想到了问题的解决办法</code>。。。</p>
<blockquote>
<p>嘿嘿，人生的惊喜就是这样。你不去找解决方法就是tmd解决不了！虽然你并不是因为找到解决办法而解决了问题。。。🎉不要想着着急时候去c翻世界，c翻自己的心，往往问题就解决了。233</p>
</blockquote>
<p>鄙人自诩不是个反应快够灵活的人，因此我接下来给出的自己<strong>碰到</strong>的问题，除了本人之外并不具有代表性。。。只是blog自己!，假使顺带着帮到你们了，，，嘿嘿嘿😚上帝爱你，</p>
<ol>
<li>本地安装工具阶段：
<ol>
<li>Node.js安装配置</li>
<li>npm install无反应</li>
<li>git配置ssh连接github不成功</li>
</ol>
</li>
<li>本地安装博客阶段
<ol>
<li>Hexo的安装目录问题</li>
<li>安装博客的心理误区</li>
<li>安装完成后的文件误解</li>
<li><a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 调试不成功</li>
</ol>
</li>
<li>本地博客部署远方阶段
<ol>
<li>git<code>传</code>本地的博客到远端github page不成功</li>
<li>几句废话</li>
</ol>
</li>
<li>博客调试功能阶段
<ol>
<li>侧栏社交外链图标问题</li>
<li>站点地图提交问题</li>
<li>emoji图标</li>
<li>文章自动生成目录</li>
<li>gif图的压缩问题</li>
<li>文本居中</li>
<li>markdown一些操蛋的地方</li>
</ol>
</li>
</ol>
<p>一共是四个大方面共计是16个troubles。</p>
<p>接下来的<strong>四个章节</strong>：Ⅰ Ⅱ Ⅲ Ⅳ 将与上面<code>无序列表</code>一一对应，去聊聊这些troubles…</p>
<hr>
<h3 id="i-本地安装工具阶段">Ⅰ 本地安装工具阶段</h3>
<p>本地安装工具阶段</p>
<h4 id="nodejs安装配置">Node.js安装配置</h4>
<p>安装nj的方法应该是很简单的，<u>找到所谓的安装包open然后一路‘同意’‘确认’下来就装好了</u>。其实，</p>
<p>就是上面说的那样简单。💊</p>
<p>但是，</p>
<p>鄙人有个“不好”的习惯：瞎jb折腾没事喜欢把东西往c盘之外挪挪挪！！！而且从近来鄙人自我反省思考的结果来看，hehe，鄙人离<code>正常</code></p>
<blockquote class="blockquote-center"><p>还差得远呢</p>
</blockquote>
<p>我的问题来源，就是上面的内容。</p>
<p>接下来的些许描述，脱离了专业职业敬业完全是在自我描述。😂nj这玩意儿的使用通常都是在命令行下敲出一行行的指令，这是经典计算机灵魂形式上的传承🙏其中的下载和配置都是由命令行中的指令去完成的。照着上面的下划线方法安装的nj我们称之为<strong>基本安装</strong>。之后可以调用一些简单的命令：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_jietu.png" alt="test"></p>
<p>在“基本安装”之后，为了更好地使用nj，还需要<em>配置npm的全局模块的存放路径以及cache的路径！</em>。npm是什么？为什么会<code>乱入</code>？此处不予赘述，不明白可以<a href="https://v2ex.com/t/210858" target="_blank" rel="external">点这里</a>。</p>
<p>安装了nj，默认的话是安装在c盘其本身没多大不占太多位置。而我，当时将其安装在了g盘根目录同名文件夹，路径就是：G:\node.js。上面提到了<em>配置npm的全局模块的存放路径以及cache的路径！</em>，，，所以你可能想到了——我想把“全局模块的存放路径以及cache的路径”放在其他的地方–&gt;比如说G:\node.js。</p>
<p>我在这里被困扰了一下下，因为最初安装nj我装在c盘看了下觉得不大就算了。等到我进一步学习才知道，md这东西以后什么一言不合的路径全是跟着之前的，，，也就是跟着c盘你装nj的目录走。其实，</p>
<p>全装到C盘也没多大关系，真的没多大关系！我说的是实话。</p>
<p>关键，</p>
<p>鄙人毕竟是有毛病😂</p>
<p>所以卸载nj，重新安装。</p>
<p>选好了盘（路径），建好了文件夹，一路确认安装好nj。。。</p>
<p>*配置npm的全局模块的存放路径以及cache的路径！*的解决办法如下：</p>
<pre><code>npm config set prefix &quot;G:node.js\node_global&quot;
        //全局模块的存放路径
npm config set cache &quot;G:node.js\node_cache&quot;
        //cache的路径
</code></pre>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/node_jietu1.png" alt="test1"></p>
<p>最后了，这个问题算是讲完了。后面会有内容和这个呼应，到时候串起来看效果更好。这问题对于博客安装本身来说，说没用的话，就是没用233☺️</p>
<h4 id="npm-install无反应">npm install无反应</h4>
<p>这里其实是个小问题，但是影响出的实际效果是贼jb大。装环境装不好不过是影响后期使用（比如说各种东西堆c盘堆不下去了2333），初期都是不会出错的。然而这里的没反应会让你的电脑一连几十分钟都静静地显示着:</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/jingzhi.png" alt="hehe"></p>
<p>这里简单说几点，<code>npm install xxxxxx</code>其实是npm安装xxx的意思。无奈的是国内访问外网都很慢，甚至不能访问！我没发现很慢，因为我觉得就是不能访问，不是甚至！😒</p>
<p>解决方法，我自己的方法是换了<a href="https://npm.taobao.org/" target="_blank" rel="external">淘宝镜像</a>。</p>
<pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<p>之后安装了博客，还有一些node上的软件，再也没有出现没反应一个小时都不会动的现象。</p>
<p>给出两个网上的解决办法。。。</p>
<ul>
<li>讨论篇<a href="https://www.v2ex.com/t/134244" target="_blank" rel="external">here1</a></li>
<li>解决篇<a href="http://www.uedbox.com/npm-install-slow-solution/" target="_blank" rel="external">here2</a></li>
</ul>
<h4 id="git配置ssh连接github不成功">git配置ssh连接github不成功</h4>
<p>如何在安装完了git之后，去继续进行自己的博客搭建？网上有专门的各种办法，全篇教你建博客，教你敲git命令行去一步步的进行配置设置，</p>
<p>我在这个阶段感受到了孤独，一是因为我很笨，二是因为真的没几个博客作者在给你讲清楚你要做什么（以及原因原理）！</p>
<blockquote class="blockquote-center"><p>不要一头雾水，鄙人文笔不好大家凑合看看得了。。。好了可以把刀石头放下了。。2333</p>
</blockquote>
<p>先把自己笨的事情交代清楚，。我在看了教程的过程中，是存在着这样的现象的。“单纯”的照着做，突然那一步有问题了，我才意识到：md为啥啊？。。然而这个时候自己连思绪都不能整理了，特别容易情绪激动而试图去c翻世界。<code>诚然做一件事请若事先都知根知底，那么即使新手上路，怕是也会轻车熟路轻而易举了。</code>然而，事实上鲜有那种事情发生，因为这世界你真的其实你不曾来过！！！我这里自责说自己笨，是因为是我很久之前都算是深谙此理却在如今依然二逼。😂</p>
<p>然后我说的是一个现象，不怪任何独立客观在我之外的人物与机构，纯属掰扯。在如今中文引擎可以搜索到的教程步骤经验百科等等资料中，我发现一个现象：</p>
<blockquote>
<p>简单你不知道的事情，会有比较多的人跟你说为什么并且教你怎么做！
异常温馨的结局。</p>
</blockquote>
<blockquote>
<p>不那么简单你不知道的事情，就那几个人教你！往往还是这样教的：<code>从头到尾照着那几个愿意教你的人那样做</code>，没出问题恭喜你就ok事情办成了，，，出问题了啊哈自己找问题去吧，跟你说你也是一头雾水，因为你从头都是照做的，知道为什么的话早自己做成了！！！</p>
</blockquote>
<p>这现象多了久了，似乎不是问题了。而是真理。</p>
<p>我想说的是，很多高手的教程<code>“完美的完整步骤”</code>，过程详尽到太多人照着一步步做只要不出问题都能成。然而这样低廉的学习代价带来的就是：过了就忘，啥都不懂。只要照着完成的工作不是一劳永逸，学习的效果与价值就存在了被争议的属性。要是出问题的话，<code>“完美的完整步骤”</code>反而成了初学者学习者的累赘。</p>
<p>在学习进步的路上要有探索精神，但是有些时候路上的磕磕绊绊，若是不去纠结而是有人拉了一把真的是<code>什么都没丢下反而轻装前行</code>。</p>
<p>有人跟你说为什么？怎么做？你再自己去做，这模式是我目前比较心仪的。然而我的现实是：<code>一堆问题，无限谷歌。自己解决的差不多了，剩下的再去请教别人</code>，我这样的“成长”带来的问题是自己动手了，于是对一些领域技术有所了解和探索，但最终归于智力和效率的欠缺，我所得的十分有限。</p>
<blockquote class="blockquote-center"><p>我tm的都忘了这一节博客是😂干啥了2333</p>
</blockquote>
<p>我刚刚指出了一堆问题发牢骚，现在我来解决下自己当初遇见过的ssh的配置问题。两个点切入：</p>
<ul>
<li>
<p>干什么</p>
</li>
<li>
<p>怎么干</p>
</li>
</ul>
<p>第一个：git是分布式代码管理工具，远程的代码（未来服务器上的博客）管理是基于SSH（一个‘钥匙’，联通你的pc上博客与远端服务器）的，所以要使用远程的Git则需要<code>SSH的配置</code>。</p>
<p>第二个:打开git配置所谓的‘钥匙’ssh，以便下一步的进行。</p>
<blockquote>
<p>步骤1 打开git bash,设置git的user name和email，是用来做认证的，否则以后的命令也是没法用没法commit：</p>
</blockquote>
<pre><code>$ git config --global user.name &quot;xxx&quot;

$ git config --global user.email &quot;xxxxxxxx@xxx.xx&quot;
</code></pre>
<blockquote>
<p>步骤2 生成密钥</p>
</blockquote>
<pre><code>ssh-keygen -t rsa -C “xxxxxxxx@xxx.xx”
</code></pre>
<p>C是大写！！！</p>
<p>我是默认你没有ssh，所以直接生成不用管以前的。你若是有ssh那就认为这些东西你都会了。这一步本来还要设置密码的步骤，我之所以卡在这里就是因为设了该死的密码，后来没见有什么安全作用到时什么东西都传不到远端。mdzz
<em>不设密码，连续三个回车直接跳过</em></p>
<blockquote>
<p>步骤3 最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code>.</p>
</blockquote>
<p>位置一般是在C盘，很好找。</p>
<blockquote>
<p>步骤4 添加密钥到ssh-agent。</p>
</blockquote>
<p>ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实s就是一个密钥管理器，运行ssh-agent以后，使用<code>ssh-add</code>命令将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。</p>
<pre><code>ssh-add 文件名
</code></pre>
<blockquote>
<p>步骤5 登陆github，将ssh添加进去。</p>
</blockquote>
<p>…
…
…
之后的就不说了，因为剩下的我都没碰到问题，我觉得真有人看这博客的话，估计也是没问题。
给个随手找的<a href="http://zuyunfei.com/2013/04/10/setup-github-ssh-key/" target="_blank" rel="external">链接</a>，可以看看作参考。</p>
<hr>
<h3 id="ii-本地安装博客阶段">Ⅱ 本地安装博客阶段</h3>
<h4 id="hexo的安装目录问题">Hexo的安装目录问题</h4>
<p>这个问题其实让我羞羞的，太不值一提的问题了。</p>
<p>说情况：：：问题I当中我有说道Node.js的全局安装与配置问题，记得那个</p>
<pre><code>npm config set prefix &quot;G:node.js\node_global&quot; 
</code></pre>
<p>就把全局的下载设置定在了g盘的文件夹node.js内。</p>
<p>这里呢，我安装的博客Hexo就是nj的应用。用如下的方法就可以下载Hexo，</p>
<p>在合适的地方创建一个文件夹，然后在文件夹空白处按住Shift+鼠标右键，然后点击在此处打开命令行窗口。（同样要记住啦，下文中会使用在当前目录打开命令行来代指上述的操作）</p>
<pre><code>npm install hexo-cli -g
</code></pre>
<p>接下来发生了什么事情？电脑之前安装的nj会启动npm去下载Hexo的<code>博客安装包</code>（不算是安装包，一般称之为下载xxx而不说是xxx的安装包），这Hexo下载存在了之前设置的<code>g盘的文件夹node.js</code>。</p>
<p>再来该做的事情是安装Hexo，命令如下：</p>
<pre><code>npm install hexo --save
</code></pre>
<p>安装好了可以选择查看安装成功的版本信息。。。</p>
<pre><code>hexo -v
</code></pre>
<p>出现下面的图示说明安装好了。。。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/yanzheng.png" alt="验证"></p>
<p>好了这个问题说完了。自己就是因为不知道这简单的几步到底是在干啥？虽然执行代码没出错，但安装完了找不到安装的文件心里就慌（其实就是找不到，-g全局变量安装的话都是在设定的那个路径）。明白了原理知道了指令的含义，其实回头看看这操作根本不会出错的除非你nj没弄好。:happy:</p>
<p>安装这个博客，走了很多弯路但摸索了试探了知道了许多配置路数的原因原理。如今写出来，也是为了告诫自己。</p>
<blockquote>
<p>在自己小白的领域里，，，搞清楚干什么怎么干，比起埋头去干要好很多。</p>
</blockquote>
<h4 id="安装博客的心理误区">安装博客的心理误区</h4>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/quan.gif" alt="papapa"></p>
<p>看到流程图了吧，很好懂。‘111111111111111111111’是个分隔点，两部分任务从这里被隔开。</p>
<p>我所谓的“安装博客的心理问题”，其实是对于全局的理解不够，也没有合理够高的计算机素养，以至于在操作中会发生低级失误or一头雾水面临成功也不敢迈出临门一脚。经验和基础才是决定你高度的，不够聪明机灵的话，勤奋点也足够了。！</p>
<p>这里需要感谢一位萝莉控——<a href="http://puyart.net" target="_blank" rel="external">PuYart</a>，是我的一位故人，一位腻害的前端开发者，他最重要的身份如今看来应该是<code>“萝莉控”</code>，特别强调下。😂此控在我的搭建博客的过程中，每天都要经历我多次低级问题的骚扰，依然笑着（深圳与上海是我俩的距离，我yy的。是为了突出人物正面形象，不是hei）帮我解决问题。。。好在大家都挺过来了，世界和平，上帝爱你！:love:</p>
<h4 id="安装完成后的文件误解">安装完成后的文件误解</h4>
<p>在nj和git都完整搞好的情况下，事实上我在下载Hexo以及安装Hexo上都没有问题。但是得益于自己的经验不足，我误以为发生了错误。</p>
<p>是这样的，在nj我配置了全局变量的安装位置是g盘的某个文件夹，因此Hexo下载存在了Hexo，这没问题。安装的话在上面的“安装目录问题”已经说了，也是很简单的操作，不要有太多想法照着做其实就一切ok了。！</p>
<p>我想太多了。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/mulu.png" alt="hehe">
​<br>
这是我的博客安装时候会产生的文件（这是后来的截图，当时可能少一两个），不明白的话会觉得很疑惑么（怎么这么多？？？node_modules不是在nj目录下见过么？怎么跑这里了！！！）？反正我是很疑惑</p>
<p>疑惑+知道的少+弄清楚的心情迫切。。。</p>
<p>最后我卸载了又装</p>
<p>当然，又是那些面孔。后来自己谷歌了，也问了问别人。。最终搞清楚了</p>
<blockquote>
<p>全局来看，博客的安装会产生截图中那样的文件是合理的。</p>
<blockquote>
<p>不明白？当然没关系</p>
<p><code>安装了之后，需要经常接触的其实是很有限的几个文件及文件夹。在不明白的情况下，不用修改任何东西。</code></p>
<p>好了，说完了。每个文件夹有什么用，当然会在后续配置的过程中有所了解有所学习。</p>
</blockquote>
</blockquote>
<p>遇到不知道的事情，通常会是产生恐惧。呵呵，哈哈，233.。。:love:
​</p>
<h4 id="httplocalhost4000-调试不成功"><a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 调试不成功</h4>
<p>这又是一个机器傻逼的问题，？</p>
<p>“什么，错别字”</p>
<p>“不不我没打错，就是机器傻逼的问题。”</p>
<p>那么直说了，这个问题是<strong>电脑运行程序的问题，跟你的使用没有必然关系。即使因为你运行着什么程序导致本地查看博客不成功，也是前因所在并不怪你</strong>。。。。。</p>
<p>我在网上照这个问题的时候，有些一根筋。我当时第一反应就是我的nj是不是装对了？我的博客下载不是最新版？我的博客安装正确了？我的命令行是否部署了博客供本地预览？我的localhost；4000没加<code>http://</code>没关系？…</p>
<p>然后找了一堆发现没问题，而后我才开始想到——端口这种东西，被来就是被程序占用使用的啊。然后恍然大悟。</p>
<p>问题解决的方向-&gt;<code>4000端口有木有被占用？能否确认端口的可用性？</code>（为何不说使用其他端口是因为，Hexo最新版本已经是不支持server修改了，安装 hexo-server 才能使用此功能。因此端口的使用不想往常一般“随意”）。</p>
<p>然后随便找了几下，找到了解决办法之一。</p>
<p>电脑的进程当中，端口的使用是可以全部查询的。在win自带的PowerShell中输入命令行：</p>
<pre><code>neratat -aon
</code></pre>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/zzz1.png" alt="问题1"></p>
<pre><code>netstat -aon|findstr 4000
</code></pre>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/zzz2.png" alt="问题2">
​<br>
懂命令行的可以继续在此界面利用指令杀死4000端口的进程。。以释放端口。。。</p>
<p>然后在任务管理器中查看pid号为2816的程序到底是什么，找到了，我自己产看的详细内容是一款阅读器软件的保护程序。右键结束进程，再进行本地调试。ok！</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/zzz3.png" alt="解决！">
​<br>
至此在进行本地调试环节，没有出问题了。Hexo博客安装详细的教程上都会有这一块的步骤指令，大家可以自寻所爱。。。
​</p>
<hr>
<h3 id="iii-本地博客部署远方阶段">Ⅲ 本地博客部署远方阶段</h3>
<h4 id="git传本地的博客到远端github-page不成功">git<code>传</code>本地的博客到远端github page不成功</h4>
<p>这次必须承认是我自己sb的问题。</p>
<p>如果你看了之前写的的几个我碰见的问题，你会觉得我在安装博客的时候心情应该是很混乱，操作也是很糟糕的。这个传远端不成功的问题，对此就很有代表性。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/mulu.png" alt="hehe"></p>
<p>这图之前出现过，是本地安装完成后出现的文件文件夹等。。。</p>
<p>远端则是这个样子的：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/yuanduan.png" alt="远端"></p>
<p>完全不一样。我是怎么操作的？</p>
<blockquote>
<p>按着正确的命令行一行一行敲出来的！</p>
</blockquote>
<p>实话，真的按着命令敲得。也没敲错。</p>
<p>那么问题出哪了？</p>
<p><strong>其实没出问题！</strong></p>
<p>那么我们打开图一中的public文件夹看看再说：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/222.png" alt="呵呵"></p>
<p>不知，你是否发现了什么。总之，我不说太多了。直接给出解答。</p>
<pre><code>$ hexo g -d
</code></pre>
<p>上面的命令是将本地修改好的最新的博客，进行生成（本地生成,<code>generate</code>）并部署（远程部署按照之前设置的github账号sshKey地址仓库名字等等…<code>deploy</code>）</p>
<pre><code>$ hexo generate --deploy
$ hexo deploy --generate
</code></pre>
<p>最重要的是：：：这个操作并不需要<code>git push</code>将所有文件传向远端仓库！</p>
<p>所以其实我是一直在做正确的事情，而不知道自己处在哪个位置。也是可悲啊。</p>
<p>这是很简单的问题，当时我找了很多的教程，详细的可以都可以精确到命令行的单词释义，文件夹文件说明。。。但是本地博客目录文件的大致命运（该不该push？哪个是哪个？谁动谁不动？），却找不到说明。</p>
<p>我是不聪明的人，也许在这个过程中，我并没有进行真正的思考，一切都是我咎由自取。😢</p>
<p>但也许，大家所谓的“手把手”的各种教程。也是<code>‘残废的超人’</code>呢？</p>
<h4 id="几句废话">几句废话</h4>
<p>怎么样，?若你是安装博客，也一定会看了些文档教程，看我的这篇若是看到这里估计你也是装得差不多了甚至78成我都感觉你装完了—<code>all finished!</code></p>
<p>这么说当然是因为我之前本地的问题传输的问题都说了，肯定呢博客的部署安装都ok了。确实如此！</p>
<p>这里要说的<code>几句废话</code>，其实在之前诉苦遇到具体问题的时候也说得差不多了。要特别说明一下的话，也就是对自己的不满意。</p>
<p>想来自己算是计算机专业的，说起来这方面算是科班出身都不算是半路出家。但是实际的操作效果看上去，比起许多文科生甚至高中生啥的都逊色太多了。很惭愧。</p>
<p>这种情况搁以前我可能还会说：<code>我身边有的人比我还不行哩</code>😂</p>
<p>现在呢，我不会再说了。真的有人比我还差跟我也没关系！我觉得自己应该明白应该拿下的事情，跟别人有什么关系？倒不是说一个人该正三观该正心态啥的，也不是说那种“有人不如我”的思想让我难收益好吃亏等等。。。只是啊，</p>
<blockquote class="blockquote-center"><p>一个愿意与月亮单独相处的人，又何必去选择喧嚣聒噪的说辞呢？</p>
</blockquote>
<p>说完了，，，人笨多勤奋，人丑多读书。。。</p>
<h3 id="iv-博客调试功能阶段">Ⅳ 博客调试功能阶段</h3>
<h4 id="侧栏社交外链图标问题">侧栏社交外链图标问题</h4>
<p><a href="http://theme-next.iissnan.com/theme-settings.html#author-sites" target="_blank" rel="external"><code>这个网页</code></a>其实已经解决了问题。</p>
<p>我简单强调一下我自己遇见的问题。。。部分图标显示不全。。。</p>
<p>根据代码可以看出图标的原理是：<code>social_icons</code>确认使用后就从一个地方得到了图标，然后再链接的前方去显示。效果大概是下面那样;</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/hehehe.png" alt="hehehe"></p>
<p>我是很无奈，之前有过的尝试发现了国内的很多都没办法显示。2333</p>
<p>weibo偶尔显示出来过，后来索性把国内的全都<code>false</code>掉了。若你想好好把这个设置的话。随便百度谷歌几篇教程绝对没任何问题了。不再赘述，祝各位修改顺利。</p>
<h4 id="站点地图提交问题">站点地图提交问题</h4>
<p>这个问题其实也可以说是拓展设置问题，在我看来设置的必要性存在却不是必须。<code>站点地图</code>的作用是：<code>将你的个人网站站点地图提交给搜索引擎，然后搜索引擎蜘蛛就可以方便的索引你的网站了。</code></p>
<p>怎么设置？看着这博客的尿性。估计你也想到了，我会告诉你，去找吧2333.。。<a href="http://tengj.top/2016/03/14/hexo6seo/#%E8%AE%A9%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95%E6%88%91%E4%BB%AC%E7%9A%84%E5%8D%9A%E5%AE%A2" target="_blank" rel="external"><code>click</code></a></p>
<p>如果你照着一步步成功的话恭喜你，很厉害！我照着做了，但是百度方面一直不成功。</p>
<p>谷歌的话最早在安装配置博客时候我在‘站点配置文件’中添加了Google分析—google_analytics.以至于后来直接在谷歌就可以搜索到我的博客以及内容。</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/google.png" alt="谷歌"></p>
<p>百度的话，结果是如下所示：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/baidu.png" alt="百度"></p>
<p>其中的缘由，不得而知。设置的话，也许有问题吧。更多的，我想说几点</p>
<ol>
<li>因为网站最终是属于github上的静态网站，因此获取站点认证的方式就比较单一。添加了xml文件并写好相应的内容，也是不一定就ok的。</li>
<li>就事论事，在hexo配置中Google展现的实力，或者说对于初级开发者（like me），优化了太多的地方。轻而易举的发现你的网站并且收录，不是啥大事情，但是让人心情愉悦。</li>
<li>baidu的有些事情，让人心生喷意。不曾想到了也许不用认真的地方，依然呵呵。。。</li>
</ol>
<h4 id="emoji图标">emoji图标</h4>
<p>这个是我个人很想使用的，可以给平淡的文字增添一丝亮色，很好用。</p>
<p>起先我以为这个问题不会存在，因为使用自己的编辑器用markdown格式书写博客时候，并没有发现异常，生成的预览很完美。我知道hexo的博客之中，是有着自己的一套渲染系统的，但是并不知道会出现emoji识别的情况。</p>
<p>网上有些支持emoji的插件，但是考虑以下两点：</p>
<ol>
<li>都需要在浏览器端进行处理</li>
<li>本身使用的js库已经很多</li>
</ol>
<blockquote>
<p>所以emoji的渲染，当然是提前进行！。</p>
</blockquote>
<p>hexo当前已经是3.0的版本，在这个版本之中的<code>hexo-tag-emojis</code>插件并不起作用，！那么使用的方法当然是有的，我们可以改变hexo默认的markdown渲染器来渲染emoji。</p>
<p>hexo默认的markdown渲染插件是hexo-renderer-marked，也就是marked渲染器的hexo版本，这个渲染器不支持插件扩展。</p>
<p>在相关的PR中有提到要支持emoji，但是却迟迟没有marge进来。然后就是另外一个markdown渲染器hexo-renderer-markdown-it，这个渲染器支持插件配置可以使用markdown-it-emoji插件来支持emoji。</p>
<p>我们要将原来的markdown渲染器换成这个<code>hexo-renderer-markdown-it</code>。</p>
<p>so，先卸载原渲染器，再安装新的渲染器。在博客目录进行git操作即可</p>
<pre><code>$ npm un hexo-renderer-marked --save

$ npm i hexo-renderer-markdown-it --save
</code></pre>
<p>then,下载markdown-it-emoji插件</p>
<pre><code>$ npm i markdown-it-emoji --save
</code></pre>
<p>全部完成了下载安装，下面需要的是最后一步配置编辑hexo的配置文件<code>_config.yml</code>来配置markdown渲染器</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/md_edit.png" alt="md_edit"></p>
<p>像这样。。。输入<code>:smile: :smirk: :relieved: :joy:</code>，会渲染成😄 😏 😌 😂</p>
<p>不喜欢Unicode表情的话，可以选择图片样式的emoji表情。需要你修改源代码并下载<code>twemoji</code>，并修改<code>markdown-it-emoji</code>模块里的<code>index.js</code>文件。。。此处不再赘述。</p>
<p>最后提供几个福利—<a href="http://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="external">点开</a>—<a href="https://markdown-it.github.io/" target="_blank" rel="external">瞅瞅</a></p>
<h4 id="文章自动生成目录">文章自动生成目录</h4>
<p>这里说的仅仅是生成目录，是自带的功能！正常使用就ok了。鄙人比较不幸运，之前一直出不来，后来几番调试才算是理解了什么是正常的目录生成！😢</p>
<p>先给出三个在谷歌上排名靠前的几个调整（解决）方案：</p>
<ol>
<li>
<p><a href="http://kuangqi.me/tricks/enable-table-of-contents-on-hexo/#%E4%BF%AE%E6%94%B9Landscape%E4%B8%BB%E9%A2%98%E7%9A%84ejs%E6%96%87%E4%BB%B6" target="_blank" rel="external">p1</a></p>
</li>
<li>
<p><a href="http://moxfive.xyz/2016/06/13/hexo-collapsible-toc/#comments" target="_blank" rel="external">p2</a></p>
</li>
<li>
<p><a href="http://darren90.github.io/2015/08/02/Hexo%E6%B7%BB%E5%8A%A0%E9%A1%B5%E5%86%85%E7%9B%AE%E5%BD%95/" target="_blank" rel="external">p3</a></p>
</li>
</ol>
<p>看完了之后，我也不问你是啥感想，反正这就是事实。</p>
<p>我的问题是像他们那样解决的？</p>
<blockquote>
<p>“no”</p>
</blockquote>
<p>md的书写经常使用“#”,来形成标题，标题的层级就是以使用“#”的数量来区分的。so,简单的层级像</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/hehe.png" alt="hehe"></p>
<p>这样的，其实只需要注意上级与次级的“#”数量差一个就可以了。多了少了反正我是出不来。至于目录的样式，参考那三个链接即可。</p>
<h4 id="gif图的压缩问题">gif图的压缩问题</h4>
<p>是的，确实和hexo博客关系不大。当你需要在md中插入一张gif，好吧也不会出现什么也是很简单。。。</p>
<p>我的问题是这样出现的，某次我想插入一张gif图片。大小我没有概念，大概是1080p电影画面的6s时长那样一个片段，起先我用某款录屏工具足足录制了100+MB的gif。</p>
<blockquote>
<p>wtf</p>
</blockquote>
<p>后来很懵逼，问了其他专业懂图像的同学，明白了一些事情。现在简要交代一下：</p>
<ul>
<li>我所使用的gif的生成与制作工具当中有几个设置选项，其中的<code>录制窗口大小</code>、<code>每秒最大帧数</code>等选项。对最终的大小有较大影响。</li>
<li>在录制完毕，生成gif的过程中，会有<code>编辑</code>、<code>调整</code>、<code>绘制</code>等选项，这些选项在一定程度上决定了最终形成的gif的质量。</li>
<li>第二阶段所做的事情，利用<code>Photoshop</code>也是可以完成的，而且更为彻底。详情见<a href="http://jingyan.baidu.com/article/f0e83a25a2ccaa22e591011e.html" target="_blank" rel="external">点开看看</a>，其中所述的基本原理很简单，操作也容易。此处所述并不是专业的图片编辑制作，因此不具有代表性，仅仅是简单的临时gif生成使用方案。</li>
</ul>
<p>over···</p>
<h4 id="文本居中">文本居中</h4>
<p>直接上解决方案:<a href="http://theme-next.iissnan.com/tag-plugins.html#center-blockquote" target="_blank" rel="external">click here</a></p>
<p>为何我会有这样sb的问题出现？</p>
<p>我也不知道</p>
<p>我的md写的好好的，部署提交就出不来。</p>
<p>后来找啊找，找到了。就是这里，因为hexo并不是每个地方都支持的完美无缺，就像之前emoji的问题，md的渲染引擎有差别，自然最终的结果，也有差别。</p>
<p>全当自let慰it了go。💥</p>
<h4 id="markdown一些操蛋的地方">markdown一些操蛋的地方</h4>
<p>流水账一般，到这里已经写了14000+的字数。还没讲多少技术！2333</p>
<p>鄙人也还真tm的不一般，标榜是篇技术博客bb了上万字写的狗屁模样。也是难得2333🙀</p>
<p>上面开始说这样的话，是否让你会看眼目录，继而发现：啊哈，这篇写完了？</p>
<blockquote class="blockquote-center"><p>是的，要写完了🌛</p>
</blockquote>
<p>最后想说些什么，从题目上看是要对markdown吐槽一番了。。其实，此时到时有心无力了。</p>
<p>markdown的存在，是的写作的效果得到了较低成本的实现，并且通俗的讲：简单容易简单容易还是tm的简单容易！博主的水平有限，又不想到处寻章摘句不留名的ctrl+C/V.因此呢，竟有些落寞了。</p>
<p>在通篇的最后，竟至于：“<code>无语凝噎</code>”。💊</p>
<p>在初步部署好了博客之后遇到的问题，都在’Ⅳ’这一部分。通篇看去都不是啥大问题。为何最在这部分的最后留下这样的子标题，我想的话，原因应该是</p>
<blockquote>
<p>反复调试的过程中，md这部分的问题尤为直观让人一眼就看到。</p>
</blockquote>
<p><code>效果</code>，对吧</p>
<p>有就是有，没有就是没有，不对就是不对</p>
<p>所以，让人很珍惜了。很珍惜调试的机会，期待着成功的那种心情。</p>
<p>这里，我所吐槽的我想吐槽的，，，与其说是出了问题的md，不如说是自己<code>FE</code>这条路的现状。磕磕绊绊无人问津的路上，还要走多远说得清楚，还能走多久我都不知道了。。。</p>
<p>前路漫漫，当前的话—照顾好这条命，安顿好这颗心⚓️</p>
<p>深圳住的地方，阳台的晾衣架子特别高。几乎每个人都得跳着才能用好。有根配套的杆子可以很轻松的将衣裳撑子取下来挂上去，but杆子平时见不着面。直到有天，看到ios的竞成拿着个带角的撑子将衣服一件件取下。。。我才明白了</p>
<p>明白了简单的道理是多么难让人学会！</p>
<blockquote class="blockquote-center"><p>君子性非异也，善假于物也</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> sixpence </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 诉苦呻吟 </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
            <tag> 经验之谈 </tag>
            
            <tag> 在路上 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[‘昨日的世界’]]></title>
      <url>http://zrdsj.cc/2016/08/19/zrdsj/</url>
      <content type="html"><![CDATA[<p>来bb下自己的这个博客为啥叫-昨日的世界。😆</p>
<a id="more"></a>
<h2 id="a-book">a book</h2>
<p>来源是一本书：</p>
<blockquote>
<p>《Die Welt von Gestern,Erinnerungen eines Europäers》—Stefan Zweig</p>
</blockquote>
<blockquote class="blockquote-center"><p>`“说中文是吧，哈哈，你早把刀拿出来我就不装逼le。。！早就说中文了”</p>
</blockquote>
<blockquote>
<p>《昨日的世界，一个欧洲人的回忆》—斯蒂芬·茨威格</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/zrdsj.jpg" alt="昨日的世界"></p>
<p>就是上面那本书。</p>
<p>内容用一句话来说就是<code>茨威格的自传体文学作品</code>。具体一些，百度百科是这样说的：<a href="http://baike.baidu.com/view/7198468.htm" target="_blank" rel="external">传送门</a>，维基百科是那样说的：<a href="https://zh.wikipedia.org/wiki/%E6%98%A8%E6%97%A5%E7%9A%84%E4%B8%96%E7%95%8C" target="_blank" rel="external">传送门</a>。两者对于此书内容的<code>简介</code>，在<code>20160819</code>的中午时刻，加起来也就是百科界面的7行文字！</p>
<p>重点在于<a href="https://zh.wikipedia.org/wiki/Wikipedia:%E9%A6%96%E9%A1%B5" target="_blank" rel="external">维基百科</a>的最后一句是这样说的：</p>
<blockquote>
<p>关于在这部作品里，茨威格在多大程度上展现了自己的一生，仍存在争议。</p>
</blockquote>
<p>书说到这里差不多够了,就是说我是<code>因为这本书而命名了自己的博客</code>。那么，因为书而命名博客名字为书名，动机很随意还可以说是瞎jb起的😝那么我是如何知道<code>这</code>本书呢？</p>
<h2 id="a-movie">a movie</h2>
<p>下面是一张电影海报：</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/The_Grand_Budapest_Hotel_Poster.jpg" alt="布达佩斯大饭店"></p>
<p>2014年，英国和德国合拍了一部喜剧剧情电影<code>《布达佩斯大饭店》</code>，这部电影当年很火。我想夸这部电影，但怕不知道如何点到为止。。。so，给下面两张图你们自己感受一下：</p>
<blockquote class="blockquote-center"><p>国外的IMDb评分：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/%E8%AF%84%E5%88%86.png" alt="imdb评分"></p>
<blockquote class="blockquote-center"><p>我们的豆瓣：</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/%E8%AF%84%E5%88%86-douban.png" alt="豆瓣评分"></p>
<p>这电影的由来，只和一个人有关的话，这人应该只能是<strong>茨威格</strong>。</p>
<p>这电影让人想起来什么地方的场景？如果看过《<strong>昨日的世界</strong>》的话，恐怕不会回答说别的书名。</p>
<p>关于这电影我说一点点，电影的好在于其本身艺术上的升华—<code>没有笑点的喜剧，没有泪点的悲剧。缺点，也许是电影的名字糟蹋了剧情</code>。😓</p>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/moviecut.png" alt="影片截图"></p>
<p>电影中有句台词是这样的：</p>
<blockquote>
<p>“But I love it all just the same，this enchcanting old ruin.”</p>
</blockquote>
<blockquote>
<p>“但我喜欢这旧模样，迷人的破败感.”</p>
</blockquote>
<p>从<code>文艺复兴</code>开始，欧洲繁荣了文化、经济，开始逐渐接管了世界。这是无尚的荣光和骄傲，对于每一位欧洲人来说都是如此！</p>
<p>上个世纪上半页，欧洲爆发了两次世界大战,<code>深痛的苦难+辉煌的泯灭！</code>😢</p>
<p>如今看来茨威格不仅仅是经历了战争！在生命的后几年，流亡巴西并抓紧时间在写这本《昨日的世界》。当时他给友人的信中说 <code>“出于绝望我正在写我一生的历史”</code> ，但《昨日的世界》绝不是一般的传记，事实上这本书主要不是写他的生平。书的副标题是<code>“一个欧洲人的回忆”</code>。</p>
<p>正因如此，茨威格在某些方面的的确确超越了个人，而成为那个时代—欧洲的见证者。</p>
<p>书的序言有这样一句：</p>
<blockquote>
<p>“（自诩）成了理性遭到最可怕的失败和野蛮在时代的编年史上取得最大胜利的见证人”</p>
</blockquote>
<h2 id="sth-else">sth else</h2>
<p>在<code>part 1</code>笼统说了：<code>喜欢电影，电影来自于书</code>。。。因此把博客的名字叫做···</p>
<p>然后扯点别的东西，😂</p>
<p>我看了看上面自己的解释，无非是说清楚了喜欢的电影和书，多了再带上作者茨威格，实在不行再加上导演安德森主演费因斯…可以了很多了。。。那么，这件事请就算是单纯的崇拜，追求？像追星那样？？？</p>
<p>我也不知道该怎么说</p>
<p>但，不是上面写的那样。⛔️</p>
<h2 id="edit-in-the-last">edit in the last</h2>
<p>2014电影<code>《布达佩斯大饭店》</code>上映，在2015年初关注奥斯卡时候我才得知了这部电影的存在。后来的故事，当然就是一发的喜欢上了相关的sth…</p>
<p><code>喜欢当然需要理由，却不一定要说出来。</code>这句话在如今的世上显得无趣无聊，但却描述了太多的事实。。。</p>
<p>So，即使15年就看了《昨日的世界》纸质书，16年的上半年又看了些许茨威格的短篇集之后。。。到如今的八月。。。我都不知道，该怎么去恢弘一篇牛逼的影评文评！☺️</p>
<p>就像是做了很长时间的梦，一如半生的梦。欢欢喜喜，哭哭啼啼，是你永远会记起的梦。。醒了;生活也许不如梦里来的那般刻骨铭心，可是也渐渐得到了成长。</p>
<p>这梦，这昨日的梦，这<code>昨日的世界</code>。。。终究会让人记起：夕阳下院子里的木头饭桌，阴雨天滴水的青苔屋檐，通向学校泥泞的曲折小径，，，还有那些声音，那些容颜…</p>
<blockquote class="blockquote-center"><p>这tm跟本不只是个欧洲人的回忆！💥</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zrdsj/xiaoshujiang/master/pic_1608-1609/last.gif" alt="last"></p>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生命 </tag>
            
            <tag> 文学 </tag>
            
            <tag> 装逼（文艺） </tag>
            
            <tag> 文化掰扯 </tag>
            
            <tag> 茨威格 </tag>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[呸呸呸]]></title>
      <url>http://zrdsj.cc/2016/08/17/Pei!/</url>
      <content type="html"><![CDATA[<h1 id="️">☺️</h1>
<p>我写博客的时候，不知道比你高的哪里去了。</p>
<a id="more"></a>
<p>是啊，那么厉害哦。哦，仔细再想想。。。</p>
<p>好像也没啥？今天的日子是？？？20160817？？？</p>
<p>其实啊，今天还</p>
<p>真的</p>
<h1 id="">🐸</h1>
<p>是个了不得的日子！</p>
<p>这么说吧，在某个国度，有一种奇怪的现象：<code>给你一个最坏的，你们会对上一个感恩戴德，把再上一个奉为神明。</code></p>
<p>早些时候，在我的心中，此国的命运与前途，大可付之一笑中。hahaha</p>
<p>在今天这个日子，记录一下。也不是合适的，也不是故意的，是的话，就当是凑字数发博客了吧。。。</p>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活随笔 </tag>
            
            <tag> 情感 </tag>
            
            <tag> 政治 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一篇blog？]]></title>
      <url>http://zrdsj.cc/2016/08/16/No1/</url>
      <content type="html"><![CDATA[<p>鲁迅先生的文章，很有意思。这里引用下</p>
<h2 id="记念刘和珍君">记念刘和珍君</h2>
<a id="more"></a>
<h3 id="一">一</h3>
<p>中华民国十五年三月二十五日，就是国立北京女子师范大学为十八日在段祺瑞执政府前遇害的刘和珍杨德群两君开追悼会的那一天，我独在礼堂外徘徊，遇见程君，前来问我道，“先生可曾为刘和珍写了一点什么没有？”我说“没有”。她就正告我，“先生还是写一点罢；刘和珍生前就很爱看先生的文章。”</p>
<p>这是我知道的，凡我所编辑的期刊，大概是因为往往有始无终之故罢，销行一向就甚为寥落，然而在这样的生活艰难中，毅然预定了《莽原》全年的就有她。我也早觉得有写一点东西的必要了，这虽然于死者毫不相干，但在生者，却大抵只能如此而已。倘使我能够相信真有所谓“在天之灵”，那自然可以得到更大的安慰，——但是，现在，却只能如此而已。</p>
<p>可是我实在无话可说。我只觉得所住的并非人间。四十多个青年的血，洋溢在我的周围，使我艰于呼吸视听，那里还能有什么言语？长歌当哭，是必须在痛定之后的。而此后几个所谓学者文人的阴险的论调，尤使我觉得悲哀。我已经出离愤怒了。我将深味这非人间的浓黑的悲凉；以我的最大哀痛显示于非人间，使它们快意于我的苦痛，就将这作为后死者的菲薄的祭品，奉献于逝者的灵前。</p>
<h3 id="二">二</h3>
<p>真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。这是怎样的哀痛者和幸福者？然而造化又常常为庸人设计，以时间的流驶，来洗涤旧迹，仅使留下淡红的血色和微漠的悲哀。在这淡红的血色和微漠的悲哀中，又给人暂得偷生，维持着这似人非人的世界。我不知道这样的世界何时是一个尽头！</p>
<p>我们还在这样的世上活着；我也早觉得有写一点东西的必要了。离三月十八日也已有两星期，忘却的救主快要降临了罢，我正有写一点东西的必要了。</p>
<h3 id="三">三</h3>
<p>在四十余被害的青年之中，刘和珍君是我的学生。学生云者，我向来这样想，这样说，现在却觉得有些踌躇了，我应该对她奉献我的悲哀与尊敬。她不是“苟活到现在的我”的学生，是为了中国而死的中国的青年。</p>
<p>她的姓名第一次为我所见，是在去年夏初杨荫榆女士做女子师范大学校长，开除校中六个学生自治会职员的时候。其中的一个就是她；但是我不认识。直到后来，也许已经是刘百昭率领男女武将，强拖出校之后了，才有人指着一个学生告诉我，说：这就是刘和珍。其时我才能将姓名和实体联合起来，心中却暗自诧异。我平素想，能够不为势利所屈，反抗一广有羽翼的校长的学生，无论如何，总该是有些桀骜锋利的，但她却常常微笑着，态度很温和。待到偏安于宗帽胡同，赁屋授课之后，她才始来听我的讲义，于是见面的回数就较多了，也还是始终微笑着，态度很温和。待到学校恢复旧观，往日的教职员以为责任已尽，准备陆续引退的时候，我才见她虑及母校前途，黯然至于泣下。此后似乎就不相见。总之，在我的记忆上，那一次就是永别了。</p>
<h3 id="四">四</h3>
<p>我在十八日早晨，才知道上午有群众向执政府请愿的事；下午便得到噩耗，说卫队居然开枪，死伤至数百人，而刘和珍君即在遇害者之列。但我对于这些传说，竟至于颇为怀疑。我向来是不惮以最坏的恶意，来推测中国人的，然而我还不料，也不信竟会下劣凶残到这地步。况且始终微笑着的和蔼的刘和珍君，更何至于无端在府门前喋血呢？</p>
<p>然而即日证明是事实了，作证的便是她自己的尸骸。还有一具，是杨德群君的。而且又证明着这不但是杀害，简直是虐杀，因为身体上还有棍棒的伤痕。</p>
<p>但段政府就有令，说她们是“暴徒”！</p>
<p>但接着就有流言，说她们是受人利用的。</p>
<p>惨象，已使我目不忍视了；流言，尤使我耳不忍闻。我还有什么话可说呢？我懂得衰亡民族之所以默无声息的缘由了。沉默呵，沉默呵！不在沉默中爆发，就在沉默中灭亡。</p>
<h3 id="五">五</h3>
<p>但是，我还有要说的话。</p>
<p>我没有亲见；听说，她，刘和珍君，那时是欣然前往的。自然，请愿而已，稍有人心者，谁也不会料到有这样的罗网。但竟在执政府前中弹了，从背部入，斜穿心肺，已是致命的创伤，只是没有便死。同去的张静淑君想扶起她，中了四弹，其一是手枪，立仆；同去的杨德群君又想去扶起她，也被击，弹从左肩入，穿胸偏右出，也立仆。但她还能坐起来，一个兵在她头部及胸部猛击两棍，于是死掉了。</p>
<p>始终微笑的和蔼的刘和珍君确是死掉了，这是真的，有她自己的尸骸为证；沉勇而友爱的杨德群君也死掉了，有她自己的尸骸为证；只有一样沉勇而友爱的张静淑君还在医院里呻吟。当三个女子从容地转辗于文明人所发明的枪弹的攒射中的时候，这是怎样的一个惊心动魄的伟大呵！中国军人的屠戮妇婴的伟绩，八国联军的惩创学生的武功，不幸全被这几缕血痕抹杀了。</p>
<p>但是中外的杀人者却居然昂起头来，不知道个个脸上有着血污……。</p>
<h3 id="六">六</h3>
<p>时间永是流驶，街市依旧太平，有限的几个生命，在中国是不算什么的，至多，不过供无恶意的闲人以饭后的谈资，或者给有恶意的闲人作“流言”的种子。至于此外的深的意义，我总觉得很寥寥，因为这实在不过是徒手的请愿。人类的血战前行的历史，正如煤的形成，当时用大量的木材，结果却只是一小块，但请愿是不在其中的，更何况是徒手。</p>
<p>然而既然有了血痕了，当然不觉要扩大。至少，也当浸渍了亲族；师友，爱人的心，纵使时光流驶，洗成绯红，也会在微漠的悲哀中永存微笑的和蔼的旧影。陶潜说过，“亲戚或余悲，他人亦已歌，死去何所道，托体同山阿。”倘能如此，这也就够了。</p>
<h3 id="七">七</h3>
<p>我已经说过：我向来是不惮以最坏的恶意来推测中国人的。但这回却很有几点出于我的意外。一是当局者竟会这样地凶残，一是流言家竟至如此之下劣，一是中国的女性临难竟能如是之从容。</p>
<p>我目睹中国女子的办事，是始于去年的，虽然是少数，但看那干练坚决，百折不回的气概，曾经屡次为之感叹。至于这一回在弹雨中互相救助，虽殒身不恤的事实，则更足为中国女子的勇毅，虽遭阴谋秘计，压抑至数千年，而终于没有消亡的明证了。倘要寻求这一次死伤者对于将来的意义，意义就在此罢。</p>
<p>苟活者在淡红的血色中，会依稀看见微茫的希望；真的猛士，将更奋然而前行。</p>
<p>呜呼，我说不出话，但以此记念刘和珍君！</p>
<p>四月一日。</p>
<h2 id="">😂</h2>
<p>如果百度百科里面在0815没弄错的话，上面的文章就没问题。复制粘贴的。</p>
<h2 id="">😂</h2>
<p>我也没什么诚意，更没什么想法。博客建立的第一天。趁着新鲜劲，随便摘抄些罢了。。。</p>
]]></content>
      
        <categories>
            
            <category> moon </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 鲁迅 </tag>
            
            <tag> 文学 </tag>
            
            <tag> 装逼（文艺） </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
